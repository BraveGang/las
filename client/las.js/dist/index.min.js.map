{"version":3,"sources":["webpack://Las/webpack/universalModuleDefinition","webpack://Las/webpack/bootstrap","webpack://Las/./src/core/events.ts","webpack://Las/./src/utils/log.ts","webpack://Las/./src/core/errors.ts","webpack://Las/./src/demux/flv/flv.ts","webpack://Las/./src/polyfills/object-assign.js","webpack://Las/./src/utils/browser.ts","webpack://Las/./node_modules/events/events.js","webpack://Las/./src/core/observer.ts","webpack://Las/./src/types/remux.ts","webpack://Las/./src/polyfills/number-isFinite.js","webpack://Las/./src/remux/aac-helper.ts","webpack://Las/./src/remux/mp4-generator.ts","webpack://Las/./src/remux/mp4-remuxer.ts","webpack://Las/./src/demux/asc.ts","webpack://Las/./src/demux/get-audio-config.ts","webpack://Las/./src/demux/exp-golomb.ts","webpack://Las/./src/demux/sps-parser.ts","webpack://Las/./src/utils/decodeUTF8.ts","webpack://Las/./src/demux/flv/amf.ts","webpack://Las/./src/demux/flv/avc-helper.ts","webpack://Las/./src/demux/flv/flv-demuxer.ts","webpack://Las/./src/demux/flv/flv-demuxer-inline.ts","webpack://Las/./node_modules/webworkify-webpack/index.js","webpack://Las/./node_modules/url-parse/index.js","webpack://Las/(webpack)/buildin/global.js","webpack://Las/./node_modules/requires-port/index.js","webpack://Las/./node_modules/querystringify/index.js","webpack://Las/./src/demux/flv/flv-demuxer-worker.ts","webpack://Las/./src/config.ts","webpack://Las/./src/core/media.ts","webpack://Las/./src/utils/mediasource-helper.ts","webpack://Las/./src/core/mse-controller.ts","webpack://Las/./src/abr/abr-get-url.ts","webpack://Las/./src/abr/abr-level.ts","webpack://Las/./src/abr/abr-manifest.ts","webpack://Las/./src/utils/matrix.ts","webpack://Las/./src/abr/abr-algorithm.ts","webpack://Las/./src/abr/multirate.ts","webpack://Las/./src/io/cache.ts","webpack://Las/./src/io/xhr.ts","webpack://Las/./src/demux/flv/flv-tag-dump.ts","webpack://Las/./src/io/fetch.ts","webpack://Las/./src/io/loader.ts","webpack://Las/./src/core/report-types.ts","webpack://Las/./src/core/trans-flv.ts","webpack://Las/./src/utils/get-error-code.ts","webpack://Las/./src/monitor/fps.ts","webpack://Las/./src/monitor/stream-monitor.ts","webpack://Las/./src/monitor/monitor.ts","webpack://Las/./src/types/monitor-data.ts","webpack://Las/./src/index.ts","webpack://Las/./src/utils/is-supported.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","LasEvents","MEDIA_INFO","PARSING_INIT_SEGMENT","PARSING_DATA","PARSED_DATA","SCRIPT_PARSED","LOAD_END","DISCONTINUITY","ERROR","LEVEL_SWITCH_FAILED","LEVEL_SWITCHING","LEVEL_SWITCHED","MANIFEST_PARSED","BUFFER_FLUSHING","INIT_PTS_FOUND","FLV_HEAD","REPORT","HEARTBEAT","LOG_LEVEL","formatter","tag","msg","length","unshift","Log","level","ENABLE_ERROR","ENABLE_WARN","ENABLE_INFO","ENABLE_DEBUG","ENABLE_VERBOSE","LEVEL_WARN","LEVEL_INFO","LEVEL_DEBUG","LEVEL_VERBOSE","e","out","console","error","warn","log","apply","w","info","debug","v","ErrorTypes","ErrorDetails","FlvTagType","FlvSize","FLV_HEAD_LEN","FLV_TAG_HEAD_LEN","FLV_TAG_SIZE_LEN","AVC_KEY_FRAME_CHECK_LEN","FlvTag","tagType","VIDEO","dataSize","timestamp","size","cts","frameType","codecId","body","fill","ObjectAssign","assign","target","varArgs","TypeError","to","index","arguments","nextSource","nextKey","Browser","ua","self","navigator","userAgent","toLowerCase","match","exec","indexOf","platform_match","matched","browser","version","majorVersion","platform","versionArray","split","major","parseInt","string","minor","build","chrome","opr","safari","webkit","rv","iemobile","edge","android","detect","ReflectOwnKeys","R","Reflect","ReflectApply","receiver","args","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","$getMaxListeners","that","_addListener","type","listener","prepend","events","existing","warning","newListener","emit","push","warned","Error","String","emitter","count","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","copy","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","err","message","context","handler","len","listeners","addListener","on","prependListener","once","prependOnceListener","list","position","originalListener","shift","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","Observer","trigger","event","TrackType","RemuxerTrackIdConfig","isFiniteNumber","isFinite","AAC","getSilentFrame","codec","channelCount","Uint8Array","UINT32_MAX","Math","pow","MP4","types","charCodeAt","videoHdlr","audioHdlr","HDLR_TYPES","video","audio","dref","stco","STTS","STSC","STCO","STSZ","VMHD","SMHD","STSD","majorBrand","avc1Brand","hev1Brand","minorVersion","FTYP_AVC","box","ftyp","FTYP_HEVC","DINF","dinf","payload","result","byteLength","hdlr","mdat","data","mdhd","timescale","duration","upperWordDuration","floor","lowerWordDuration","mdia","track","minf","mfhd","sequenceNumber","smhd","stbl","vmhd","moof","sn","baseMediaDecodeTime","traf","moov","tracks","boxes","trak","mvhd","mvex","trex","bytes","sdtp","flags","samples","dependsOn","isDependedOn","hasRedundancy","stsd","stts","stsc","stsz","avc1","sps","pps","slice","avcc","avcC","width","height","hSpacing","pixelRatio","vSpacing","btrt","pasp","hev1","hvcc","codecWidth","codecHeight","hvcC","esds","configlen","config","mp4a","samplerate","mp3","isAAC","tkhd","id","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","tfhd","tfdt","trun","offset","sample","arraylen","array","isLeading","paddingValue","isNonSync","degradPrio","initSegment","movie","MP4Remuxer","observer","typeSupported","vendor","_observer","_config","_typeSupported","_isSafari","_forceFirstIDR","_stash","_stashInfo","_stashLastVideoSample","_ISGenerated","_videoTime","_extra","_nextAudioPts","_nextAvcDts","_initPTS","_initDTS","_initSegment","gopRemux","_resetVideoTime","setStat","stat","ISGenerated","nextAudioPts","nextAvcDts","initPTS","initDTS","nbSamples","videoTime","firstDTS","sampleDuration","vLastPTS","aLastPTS","endDts","getStat","destroy","setExtra","resetTimeStamp","defaultTimeStamp","resetInitSegment","resetStash","getLastPTS","flush","audioTrackLength","videoData","remuxVideo","timeOffset","accurateTimeOffset","remux","audioTrack","videoTrack","contiguous","isFlush","generateIS","pts","dts","nbVideoStashSamples","nbAudioSamples","nbVideoSamples","audioTimeOffset","videoTimeOffset","audiovideoDeltaDts","inputTimeScale","max","audioData","remuxAudio","endPTS","startPTS","startDTS","endDTS","remuxEmptyAudio","audioSamples","videoSamples","computePTSDTS","container","Infinity","mpeg","metadata","audioSampleRate","fps","profile","chromaFormat","min","MUX_ERROR","details","PARSING_ERROR","fatal","reason","lastPTS","lastDTS","timeScale","inputSamples","outputSamples","ptsNormalize","_PTSNormalize","streamDTS","time","mp4SampleDuration","firstPTS","isSafari","abs","forEach","sort","a","b","deltadts","deltapts","PTSDTSshift","reduce","prev","curr","round","delta","nbNalu","naluLen","units","nbUnits","sampleLen","j","mdatSize","REMUX_ALLOC_ERROR","view","DataView","buffer","setUint32","avcSample","avcSampleUnits","mp4SampleLength","compositionTimeOffset","unit","unitData","unitDataLen","lastFrameDuration","refSampleDuration","stretchShortVideoTrack","maxBufferHole","gapTolerance","deltaToFrameEnd","fix","dropped","_mergeBoxes","hasAudio","hasVideo","nb","extra","mp4Sample","fillFrame","mp4timeScale","scaleFactor","inputSampleDuration","rawMPEG","resetPts","filter","maxAudioFramesDrift","nextPts","toFixed","splice","missing","newStamp","manifestCodec","subarray","audioSample","numMissingFrames","unitLen","lastSampleDuration","start","end","frameDuration","ceil","silentFrame","stamp","reference","cur","initTrackConfig","audioCodec","extensionSampleingIndex","objectType","sampleingIndex","chanelConfig","sampleingRates","test","getAudioConfig","parseData","ExpGolomb","uint8array","_buffer","_buffer_index","_total_bytes","_total_bits","_current_word","_current_word_bits_left","_fillCurrentWord","buffer_bytes_left","bytes_read","word","getUint32","readBits","bits","bits_need_left","bits_read_next","result2","readBool","readUByte","readUShort","readUInt","readByte","_skipLeadingZero","zero_count","readUEG","leading_zeros","readSEG","readSliceType","getBitsLeft","HEVC_MAIN","1","2","3","4","HEVC_LEVELS","30","60","63","90","93","120","123","150","153","156","180","183","186","255","SPSParser","_ebsp2rbsp","src","src_length","dst","dst_idx","parseHEVCSPS","rbsp","gb","ptl","general_ptl","sub_layer_ptl","max_sub_layers","_parsePTL","chroma_format_idc","chroma_format_string","profile_string","level_string","max_num_sub_layers","_decodeProfileTierLevel","level_idc","getHEVCLevelString","sub_layer_profile_present_flag","sub_layer_level_present_flag","profile_space","tier_flag","profile_idc","profile_compatibility_flag","progressive_source_flag","interlaced_source_flag","non_packed_constraint_flag","frame_only_constraint_flag","getHEVCProfileString","parseSPS","getProfileString","getLevelString","chroma_format","bit_depth","scaling_list_count","_skipScalingList","pic_order_cnt_type","num_ref_frames_in_pic_order_cnt_cycle","pic_width_in_mbs_minus1","pic_height_in_map_units_minus1","frame_mbs_only_flag","frame_crop_left_offset","frame_crop_right_offset","frame_crop_top_offset","frame_crop_bottom_offset","sar_width","sar_height","fps_fixed","fps_num","fps_den","aspect_ratio_idc","num_units_in_tick","time_scale","sarScale","crop_unit_x","crop_unit_y","codec_width","codec_height","present_width","getChromaFormatString","frame_rate","fixed","sar_ratio","codec_size","present_size","last_scale","next_scale","chroma","checkContinuation","checkLength","decodeUTF8","input","fromCharCode","ucs4","join","AMF","parseMetadata","parseScript","toString","parseObject","arrayBuffer","dataOffset","parseString","isObjectEnd","objectEnd","parseVariable","parseLongString","parseDate","getFloat64","localTimeOffset","getInt16","Date","getUint16","dv","getUint8","amfstr","amfobj","amfvar","strictArrayLength","val","date","amfLongStr","configBody","frameI","AVC","getFlvVideoTag","FlvDemux","remuxer","_remuxer","_duration","_naluLengthSize","_hasVideo","_hasAudio","_videoTrack","_audioTrack","_remuxStat","_currentTimestamp","_aLastDTS","_vLastDTS","_nonMonotonousCache","_fillAtStart","enabled","avcConfig","pid","append","tags","_fillFrame","_parseVideoData","AUDIO","_parseAudioData","SCRIPT","_parseScriptTag","st","ed","_remux","flvHead","scriptData","onMetaData","framerate","spec","packetType","_parseAVCDecoderConfigurationRecord","_parseAVCVideoData","avcProfile","spsCount","spsList","codecArray","codecString","h","ppsCount","ignoreNonMonotonous","lengthSize","keyframe","_onNonMonotonous","_flushNonMonotonousCache","naluSize","unitType","aacFrameLen","ASC","aacData","dtsDiff","sampleDts","aacSample","cache","lastPts","ptsSync","nonMonotonousCache","audiotrack","videotrack","REMUX_ERROR","sec","FlvDemuxerInline","extraData","_extraData","_demuxer","_bitrate","_vendor","bitrate","Mp4Remuxer","mp4","demuxer","FlvDemuxer","discontinuity","webpackBootstrapFunc","configurable","oe","f","ENTRY_MODULE","default","dependencyRegExp","quoteRegExp","str","replace","getModuleDependencies","sources","queueName","retval","fnString","wrapperSignature","webpackRequireName","re","RegExp","hasValuesInQueues","queues","hasValues","options","main","requiredModules","all","modulesQueue","seenModules","moduleToCheck","newModules","newModulesKeys","getRequiredModules","entryModule","JSON","stringify","map","blob","window","Blob","bare","workerUrl","URL","webkitURL","mozURL","msURL","createObjectURL","worker","Worker","objectURL","required","qs","slashes","protocolre","left","trimLeft","rules","address","NaN","ignore","hash","query","lolcation","loc","location","global","finaldestination","protocol","Url","unescape","pathname","href","extractProtocol","rest","parser","relative","extracted","parse","instruction","instructions","url","charAt","base","path","last","up","resolve","port","host","hostname","username","password","auth","origin","part","fn","char","ins","g","has","decode","decodeURIComponent","obj","prefix","pairs","encodeURIComponent","flv","forwardMessage","ev","postMessage","addEventListener","cmd","URL_REG","DEFAULT_CONFIG","webWorker","autoCleanupMaxBackwardDuration","autoCleanupMinBackwardDuration","appendErrorMaxRetry","credentials","defaultSpts","LEVEL_ERROR","connectionTimeout","transmissionTimeout","ConfigHelper","processConfig","userConfig","setSrc","detectStreamingMux","opera","manifest","Media","_video","_mse","_streamTime","_localTime","reset","attachVideo","attachMSE","mse","isTimeinBuffered","buffered","bufferedSec","currentTime","bufferedSecByType","bufferedEndByType","mseBufferedSecByType","bufferedByType","bufferSliceNumByType","pendingNum","pendingSecByType","currentBuffer","nextBuffer","updateStreamTime","streamTime","localTime","getLocalTime","readyState","getMediaSource","MediaSource","WebKitMediaSource","MSEController","_sourceBuffer","_mediaSource","_mimeCodec","_cleanUpTask","_appendQueue","_endOfData","_appendEnabled","_appendError","_appendBufferError","_sbHandler","_souceBufferLocked","_onSourceOpen","removeEventListener","_checkSourceBuffer","refresh","_onSourceEnded","_onSourceClose","_onSourceBufferUpdateEnd","_update","_endOfStream","_onSourceBufferError","MSE_ERROR","SOURCEBUFFER_ERROR","audiovideo","attach","MediaSourceDef","ms","load","setTimeout","MEDIASOURCE_ERROR","trackInfo","mediaInfo","hasSourceBuffer","updateend","videoCodec","expected","codecs","_addSourceBuffer","addSourceBuffer","ADDSOURCEBUFFER_ERROR","sb","_hasPendingData","_doAppend","_getBufferQueueSize","APPENDBUFFER_ERROR","updating","_appendBuffer","mediaSegment","segment","queue","current","num","_calculateRemoveRange","seeking","task","_cleanUpRange","range","bufStart","firefox","bufEnd","removeStart","removeEnd","remove","appendBuffer","code","conf","useless","MIN_CLEANUP_DURATION","hasCleanUpTask","_cleanUp","startSec","endSec","flushType","POSITIVE_INFINITY","setAppendEnabled","getAppendEnabled","endOfData","ended","endOfStream","ENDOFSTREAM_ERROR","removeSourceBuffer","getBufferQueueSec","prevDuration","currentSeg","item","abrGetUrl","spts","urlparse","lasSpts","AbrLevel","maxBitrate","avgBitrate","qualityType","qualityLabel","hidden","enableAdaptive","defaultSelect","AbrManifest","_levels","_abrLevels","_default","verify","adaptationSet","representation","disableAdaptive","isArray","Matrix","Float32Array","shape","_init","add","subtract","augment","multiply","zeros","identity","ArrayBuffer","BYTES_PER_ELEMENT","constructor","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Uint8ClampedArray","Float64Array","flatten","acc","next","matrix","r1","c1","r2","c2","k","sum","d1","d2","x","alpha","equilateral","equidimensional","l1","transpose","inverse","gauss","right","equals","pivot","leadValue","lead","swap","check","copyWithin","D","s1","s2","every","dim","l2","CONFIG","beacon","predictStep","minBuffer","bufferOffset","smoothRatioToTarget","speedSmoothRatio","switchPenalty","slidingWindowSize","kalmanR","kalmanQ","initBitrateLevel","speedPredictNum","AbrAlgorithm","MATRIX_E","MATRIX_G","_conf","_xPrev","_PPrev","_pastBuffer","_pastThroughput","_availableList","_current","_next","_processConfig","levels","setAvailableBitrates","onGOP","speed","_nextRateIndex","_recentSpeed","onLevelLoad","_quantization","_nextRateBySpeedAndBuffered","_resetAlgorithm","_recentBuffer","_adjustedTargetBuffer","targetBuffer","_rateChangeArray","switchPenaltyArray","estimatedThroughput","Bk","br","targetBufferArray","_printFirstColumn","matrixG","predictedBufferArray","matrixF","_diag","futureThroughput","_multistepPred","rateChangeArray","_printFirstRow","dist","pastThroughput","pastThroughputClone","bandwidthSum","nonzeroCnt","_multistepKalmanfilter","xLast","z","PLast","Q","xPrev","PPrev","xRet","PRet","PMinus","K","predX","P","Multirate","media","_media","_downloadSize","_downloadStartTime","_keyCount","_index","_alg","_manifest","_autoLevelEnabled","abrLevels","performance","now","nextLevel","currentLevel","destory","onLoaderChunk","onKeyFrame","_getRequestUrl","Cache","_size","_readOffset","_writeOffset","_storage","_cache","DEFAULT_CACHE_SIZE","put","chunk","_collateCache","expandCache","byteOffset","read","skip","clear","MAX_CACHE_SIZE","_transfer","remain","source","sourceView","destView","XHR_TYPE","FlvTagDump","onAbr","_tag","_result","_parseLen","_parseFunc","_onAbr","_parseFlvHead","abr","unreadLen","_parseFlvTagHead","_detectKeyFrame","_parseFlvTag","FetchLoader","_context","_callbacks","_controller","_reader","_abort","isSupport","fetch","ReadableStream","callbacks","reqHeaders","Headers","headers","element","header","params","method","referrerPolicy","signal","_getAbortSignal","then","res","responseUrl","responseHeader","onConnect","status","ok","getReader","cancel","responseType","progress","_pump","responseData","_onEnd","text","statusText","_onError","catch","abort","_onProgress","onProgress","onEnd","onError","reader","done","AbortController","ChunkLoader","XHR","_xhr","_msBufferOffset","_msBufferUpper","_progress","UNKNOW","isSupportChunk","supportChunk","xhr","XMLHttpRequest","open","MOZ_CHUNK","UNSUPPORT","MS_STREAM","MSStreamReader","onprogress","_msrOnProgress","onload","_onLoadEnd","onerror","onreadystatechange","_onReadyStateChange","withCredentials","setRequestHeader","send","responseURL","getAllResponseHeaders","readAsArrayBuffer","response","Loader","_loader","_loaderCallback","_stats","_retryDelay","_loading","_aborted","_requestTimeout","_transTimer","_retryTimeout","_rangeStart","_continuedTransmissionRetry","_progressTime","useFetch","maxRetry","retryDelay","_onConnect","_getInternalLoader","msie","msedge","_loadInternal","_stopTimer","_abortInternal","_destroyLoader","rangeStart","trequest","retry","loaded","output","tfirst","tload","total","tsload","tstart","stats","clearTimeout","_onTimeout","rangeEnd","onAbort","_stopTransmissionTimer","_startTransmissionTimer","tmp","_callProgress","timeout","setInterval","clearInterval","REPORT_TYPES","TransFLV","_w","_flv","_loaderConf","_loaderCallbacks","_multirate","_contiguous","_remuxId","_discontinuity","_accurateTimeOffset","_baseTimeSec","_tagDump","_currentUrl","_lastDTS","_isAbr","_onKeyframe","smooth","_onMessage","remuxId","framesInfo","_onLoaderError","_onLoaderEnd","_onAbort","onMessage","_onWorkMessage","work","loadSource","mr","_load","OTHER_ERROR","terminate","sync","_append","timeCost","errInfo","NETWORK_ERROR","LOAD_ERROR","statusCode","_refreshRemuxId","autoLevelEnabled","ErrorCodeList","400","401","403","404","other4xx","serverError","timeoutOpen","timeoutIO","200","206","FPS","_lastDroppedFrames","_lastDecodedFrames","_isVideoPlaybackQualityAvailable","_lastTime","_decoded","_dropped","attachMedia","HTMLVideoElement","getVideoPlaybackQuality","videoPlaybackQuality","totalVideoFrames","droppedVideoFrames","webkitDecodedFrameCount","webkitDroppedFrameCount","checkFPSInterval","decoded","currentPeriod","currentDropped","currentDecoded","droppedFPS","decodedFPS","parseFloat","StreamMonitor","_qos","traffic","streams","download","keyFrame","onStreamOpen","startPos","loadTimeCost","videoDataRate","audioDataRate","segments","onMediaInfo","loadingInfo","onDataReceive","onMediaSegment","qos","stream","totalLen","getInfoByTime","updateStartPos","tsEnd","ts","Monitor","_fps","_data","_playing","_sm","_hbTimer","_heartbeat","_refresh","sm","hb","totalReceive","downloadSpeed","decodedFrames","droppedFrames","loadStartTime","firstFrameTime","blockDuration","blockCount","downloadedBytes","onReport","_stopHeartbeat","onLoad","_startHeartbeat","onSegmentInit","onLoadeddata","_onFirstFrame","_waitingEnd","onCanplay","onPlaying","onWaiting","block","_waitingStart","onStopLoad","onSegment","bufferingStartMS","STAT","Las","_trans","_stat","INIT","_seekOnCanplay","_audioCodecSwap","_error","_audioCodec","_recoverMediaErrorTime","_mainTimer","_nextLevel","_mediaInfo","_bufferThreshold","_loadStopped","_seekOnUpdateEnd","_playingLevel","_startLevel","_monitor","_onVideoPlay","_onVideoEnded","_resetMSE","revokeObjectURL","removeAttribute","_destroyMSE","_initMSE","_mainLoop","WAITING","SEEK","SELECT_BITRATE","jumpTo","_internalSeek","_checkLevelChange","_onVideoLoadeddata","_onVideoCanplay","NONE","_detectSeekOnCanplay","paused","_onVideoPlaying","_onVideoWaiting","_onVideoError","_recoverMediaError","_recoverSwapAudioCodec","MEDIA_ERROR","VIDEO_ERROR","_startMainTimer","_initMonitor","UNSUPPORTED","CONFIG_ERROR","mediaSource","sourceBuffer","SourceBuffer","WebKitSourceBuffer","isTypeSupported","sourceBufferValidAPI","streaming","__VERSION__","_bindVideoEvents","resume","play","_stopMonitor","_stopMainTimer","_unbindVideoEvents","_stopVideo","_initTrans","stopLoad","_destroyTrans","getMediaInfo","_unbindMediaSourceEvent","errorMessage","_verifyLevel","_transmuxerEvent","trans","manifestAudioCodec","EPS","errorCode","detail","httpStatusCode","getErrorCode","TransFlv","audioCodecSwap"],"mappings":"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,IAAjBC,EACA,OAAO,IAAIC,WAAW,CAAC,EAAM,IAAM,EAAM,IAAM,GAAM,MAClD,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAAC,GAAM,EAAM,GAAM,IAAM,EAAM,GAAM,EAAM,GAAM,MACpE,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,MAED,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,IACA,GACA,IACA,EACA,EACA,KAED,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,IACA,GACA,EACA,IACA,EACA,GACA,IACA,EACA,KAED,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,IACA,GACA,EACA,IACA,EACA,GACA,IACA,EACA,EACA,IACA,EACA,GACA,EACA,MAIR,MAEJ,QACI,GAAqB,IAAjBD,EAIA,OAAO,IAAIC,WAAW,CAClB,EACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,GACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAED,GAAqB,IAAjBD,EAIP,OAAO,IAAIC,WAAW,CAClB,EACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAED,GAAqB,IAAjBD,EAIP,OAAO,IAAIC,WAAW,CAClB,EACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAKhB,OAAO,M,eFjTHR,K,cAAAA,E,eAAAA,M,cAKAC,O,iBAAAA,I,kBAAAA,M,KGDZ,IAAMQ,EAAaC,KAAKC,IAAI,EAAG,IAAM,EAE/BC,E,kCAeKrF,KAAP,WA0CI,IAAIzJ,EACJ,IAAKA,KA1CL8O,EAAIC,MAAQ,CACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,OAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,IAIFD,EAAIC,MACND,EAAIC,MAAMlN,eAAe7B,KACzB8O,EAAIC,MAAM/O,GAAK,CAACA,EAAEgP,WAAW,GAAIhP,EAAEgP,WAAW,GAAIhP,EAAEgP,WAAW,GAAIhP,EAAEgP,WAAW,KAIxF,IAAMC,EAAY,IAAIP,WAAW,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGEQ,EAAY,IAAIR,WAAW,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGJI,EAAIK,WAAa,CACbC,MAAOH,EACPI,MAAOH,GAGX,IAAMI,EAAO,IAAIZ,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,EACA,EACA,EACA,IAGEa,EAAO,IAAIb,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGJI,EAAIU,KAAOV,EAAIW,KAAOX,EAAIY,KAAOH,EAEjCT,EAAIa,KAAO,IAAIjB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEJI,EAAIc,KAAO,IAAIlB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEJI,EAAIe,KAAO,IAAInB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGJI,EAAIgB,KAAO,IAAIpB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGJ,IAAMqB,EAAa,IAAIrB,WAAW,CAAC,IAAK,IAAK,IAAK,MAC5CsB,EAAY,IAAItB,WAAW,CAAC,GAAI,IAAK,GAAI,KACzCuB,EAAY,IAAIvB,WAAW,CAAC,IAAK,IAAK,IAAK,KAC3CwB,EAAe,IAAIxB,WAAW,CAAC,EAAG,EAAG,EAAG,IA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B,EAAG,CAAKA,EAAIC,MAAMuD,MAAf,OAAwBH,K,EAG/BE,KAAP,SAAYrB,EAAmBC,GAC3BA,GAAYD,EACZ,IAAME,EAAoBtC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxDyC,EAAoBxC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxD6D,EAAQ,IAAI9D,WAAW,CACzB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAsC,GAAa,GAAK,IAClBA,GAAa,GAAK,IAClBA,GAAa,EAAI,IACL,IAAZA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,MAEJ,OAAOtC,EAAIsB,IAAItB,EAAIC,MAAMsD,KAAMG,I,EAG5BC,KAAP,SAAYnB,GACR,IAEIoB,EACA1S,EAHA2S,EAAUrB,EAAMqB,SAAW,GAC3BH,EAAQ,IAAI9D,WAAW,EAAIiE,EAAQrP,QAKvC,IAAKtD,EAAI,EAAGA,EAAI2S,EAAQrP,OAAQtD,IAC5B0S,EAAQC,EAAQ3S,GAAG0S,MACnBF,EAAMxS,EAAI,GAAK0S,EAAME,WAAa,EAAIF,EAAMG,cAAgB,EAAIH,EAAMI,cAG1E,OAAOhE,EAAIsB,IAAItB,EAAIC,MAAM0D,KAAMD,I,EAG5Bb,KAAP,SAAYL,GACR,OAAOxC,EAAIsB,IACPtB,EAAIC,MAAM4C,KACV7C,EAAIiE,KAAKzB,GACTxC,EAAIsB,IAAItB,EAAIC,MAAMiE,KAAMlE,EAAIU,MAC5BV,EAAIsB,IAAItB,EAAIC,MAAMkE,KAAMnE,EAAIW,MAC5BX,EAAIsB,IAAItB,EAAIC,MAAMmE,KAAMpE,EAAIa,MAC5Bb,EAAIsB,IAAItB,EAAIC,MAAMQ,KAAMT,EAAIY,Q,EAI7ByD,KAAP,SAAY7B,GACR,IAEItR,EACA8Q,EACAjE,EAJAuG,EAAW,GACXC,EAAW,GAMf,IAAKrT,EAAI,EAAGA,EAAIsR,EAAM8B,IAAI9P,OAAQtD,IAE9B6M,GADAiE,EAAOQ,EAAM8B,IAAIpT,IACN2Q,WACXyC,EAAI1I,KAAKmC,IAAQ,EAAI,KACrBuG,EAAI1I,KAAW,IAANmC,GAGTuG,EAAMA,EAAIhK,OAAOwC,MAAMhK,UAAU0R,MAAMnT,KAAK2Q,IAIhD,IAAK9Q,EAAI,EAAGA,EAAIsR,EAAM+B,IAAI/P,OAAQtD,IAE9B6M,GADAiE,EAAOQ,EAAM+B,IAAIrT,IACN2Q,WACX0C,EAAI3I,KAAKmC,IAAQ,EAAI,KACrBwG,EAAI3I,KAAW,IAANmC,GAETwG,EAAMA,EAAIjK,OAAOwC,MAAMhK,UAAU0R,MAAMnT,KAAK2Q,IAGhD,IAAMyC,EAAOzE,EAAIsB,IACTtB,EAAIC,MAAMyE,KACV,IAAI9E,WACA,CACI,EACA0E,EAAI,GACJA,EAAI,GACJA,EAAI,GACJ,IACA,IAAO9B,EAAM8B,IAAI9P,QAEhB8F,OAAOgK,GACPhK,OAAO,CACJkI,EAAM+B,IAAI/P,SAEb8F,OAAOiK,KAGpBI,EAAQnC,EAAMmC,MACdC,EAASpC,EAAMoC,OACfC,EAAWrC,EAAMsC,WAAW,GAC5BC,EAAWvC,EAAMsC,WAAW,GAEhC,OAAO9E,EAAIsB,IACPtB,EAAIC,MAAMoE,KACV,IAAIzE,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA+E,GAAS,EAAI,IACL,IAARA,EACAC,GAAU,EAAI,IACL,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,KAEJH,EACAzE,EAAIsB,IACAtB,EAAIC,MAAM+E,KACV,IAAIpF,WAAW,CACX,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,OAGRI,EAAIsB,IACAtB,EAAIC,MAAMgF,KACV,IAAIrF,WAAW,CACXiF,GAAY,GACZA,GAAY,GAAK,IACjBA,GAAY,EAAI,IACL,IAAXA,EACAE,GAAY,GACZA,GAAY,GAAK,IACjBA,GAAY,EAAI,IACL,IAAXA,O,EAMTG,KAAP,SAAY1C,GACR,IAAM2C,EAAO3C,EAAM2C,KACbR,EAAQnC,EAAM4C,WAChBR,EAASpC,EAAM6C,YACbrD,EAAO,IAAIpC,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA+E,IAAU,EAAI,IACN,IAARA,EACAC,IAAW,EAAI,IACN,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,MAEJ,OAAO5E,EAAIsB,IAAItB,EAAIC,MAAMiF,KAAMlD,EAAMhC,EAAIsB,IAAItB,EAAIC,MAAMqF,KAAMH,K,EAG1DI,KAAP,SAAY/C,GACR,IAAMgD,EAAYhD,EAAMiD,OAAOjR,OAC/B,OAAO,IAAIoL,WACP,CACI,EACA,EACA,EACA,EAEA,EACA,GAAO4F,EACP,EACA,EACA,EAEA,EACA,GAAOA,EACP,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,GAEClL,OAAO,CAACkL,IACRlL,OAAOkI,EAAMiD,QACbnL,OAAO,CAAC,EAAM,EAAM,M,EAI1BoL,KAAP,SAAYlD,GACR,IAAMmD,EAAanD,EAAMmD,WACzB,OAAO3F,EAAIsB,IACPtB,EAAIC,MAAMyF,KACV,IAAI9F,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA4C,EAAM7C,aACN,EACA,GACA,EACA,EACA,EACA,EACAgG,GAAc,EAAI,IACL,IAAbA,EACA,EACA,IAEJ3F,EAAIsB,IAAItB,EAAIC,MAAMsF,KAAMvF,EAAIuF,KAAK/C,M,EAIlCoD,IAAP,SAAWpD,GACP,IAAMmD,EAAanD,EAAMmD,WACzB,OAAO3F,EAAIsB,IACPtB,EAAIC,MAAM,QACV,IAAIL,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA4C,EAAM7C,aACN,EACA,GACA,EACA,EACA,EACA,EACAgG,GAAc,EAAI,IACL,IAAbA,EACA,EACA,M,EAKL1B,KAAP,SAAYzB,GACR,OAAIA,EAAMpH,OAASgE,EAAUmB,MACXiC,EAAOqD,OAAyB,QAAhBrD,EAAM9C,MAI7BM,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAI0F,KAAalD,IAH/CxC,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAI4F,IAAYpD,IAK7B,IAAhCA,EAAM9C,MAAMrH,QAAQ,QACb2H,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAIkF,KAAa1C,IAEvDxC,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAIqE,KAAa7B,K,EAGvDsD,KAAP,SAAYtD,GACR,IAAMuD,EAAKvD,EAAMuD,GACb5D,EAAWK,EAAML,SAAWK,EAAMN,UAClCE,EAAoBtC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxDyC,EAAoBxC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxD8E,EAAQ,EACRC,EAAS,EAOb,OANIpC,EAAMzP,eAAe,WACrB4R,EAAQnC,EAAMmC,OAEdnC,EAAMzP,eAAe,YACrB6R,EAASpC,EAAMoC,QAEZ5E,EAAIsB,IACPtB,EAAIC,MAAM6F,KACV,IAAIlG,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAmG,GAAM,GAAK,IACXA,GAAM,GAAK,IACXA,GAAM,EAAI,IACL,IAALA,EACA,EACA,EACA,EACA,EACA3D,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACAqC,GAAS,EAAI,IACL,IAARA,EACA,EACA,EACAC,GAAU,EAAI,IACL,IAATA,EACA,EACA,M,EAKL1B,KAAP,SAAYV,EAAcS,GACtB,IAAM+C,EAAwBhG,EAAI2D,KAAKnB,GACnCuD,EAAKvD,EAAMuD,GACXE,EAA+BnG,KAAKuC,MAAMY,GAAuBpD,EAAa,IAC9EqG,EAA+BpG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CR,IAAI8pB,EAAoBL,EAAGvI,UAAU/M,GACrCA,GAAU,EACV,IAAK,IAAIpV,EAAI,EAAGA,EAAI+qB,EAAmB/qB,IAAK,CACxC,IAAIgrB,EAAMxB,EAAIE,YAAY/L,EAAQvI,GAClCnU,EAAMyJ,KAAKsgB,EAAIla,MACfsE,EAAS4V,EAAIrlB,KAEjB,MAEJ,KAAK,GAED,IAAIslB,EAAOzB,EAAIY,UAAUzM,EAAQvI,EAAS,GAC1CnU,EAAQgqB,EAAKna,KACbsE,GAAU6V,EAAKtlB,KACf,MAEJ,KAAK,GAED,IAAIulB,EAAa1B,EAAIO,YAAYpM,EAAQvI,EAAS,GAClDnU,EAAQiqB,EAAWpa,KACnBsE,GAAU8V,EAAWvlB,KACrB,MAEJ,QAEIyP,EAAS3P,EACTjC,IAAIqB,EArMF,MAqMS,MAAO,8BAAgCqF,GAE1D,MAAO,CACH4G,KAAM7P,EACN0E,KAAMyP,EACN6U,c,YC5MNkB,EAAa,IAAIzc,WAAW,CAC9B,GACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,GACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,GACA,GACA,EACA,EACA,EACA,IACA,IACA,GACA,IACA,GACA,MAGE0c,EAAS,IAAI1c,WAAW,CAC1B,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,EACA,IACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,EACA,EACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,EACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,MAqBW2c,E,kCAjBJC,eAAP,SAAsB5lB,EAAmB6O,QAAiC,IAAjCA,OAAkB,GACvD,IAAMnR,EAAM,IAAIkC,IAYhB,OAXAlC,EAAImC,QAAUP,IAAWQ,MAErBpC,EAAI2C,KADJwO,EACW4W,EAEAC,EAEfhoB,EAAIqC,SAAWrC,EAAI2C,KAAK4K,WACxBvN,EAAIsC,UAAYkJ,KAAKmO,MAAMrX,GAC3BtC,EAAIyC,UAAY,EAChBzC,EAAI0C,QAAU,EACd1C,EAAI4C,MAAO,EACJ5C,G,2KChxBf,IA+lBemoB,E,WAlkBX,WAAYxV,EAAoByV,EAAmBjX,GAAwB,KArBnEnR,I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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Las\"] = factory();\n\telse\n\t\troot[\"Las\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","const LasEvents = {\n    MEDIA_INFO: 'mediaInfo',\n    PARSING_INIT_SEGMENT: 'parsingInitSegment',\n    PARSING_DATA: 'parsingData',\n    PARSED_DATA: 'parsedData',\n    SCRIPT_PARSED: 'scriptParsed',\n    LOAD_END: 'loadEnd',\n    DISCONTINUITY: 'discontinuity',\n    ERROR: 'lasError',\n    LEVEL_SWITCH_FAILED: 'levelSwitchFailed',\n    LEVEL_SWITCHING: 'levelSwitching',\n    LEVEL_SWITCHED: 'levelSwitched',\n    MANIFEST_PARSED: 'manifestParsed',\n    BUFFER_FLUSHING: 'bufferFlushing',\n    INIT_PTS_FOUND: 'initPTSFound',\n    FLV_HEAD: 'flvHead',\n    REPORT: 'report',\n    HEARTBEAT: 'heartbeat',\n};\n\nexport default LasEvents;\n","const GLOBAL_TAG = 'kwai-k';\nconst FORCE_GLOBAL_TAG = true;\n\n/**\n * 处理log参数\n * @param {string=} tag tag\n * @param {Array=} msg messages\n * @returns {Array} msg\n */\n/**\n * 处理log参数\n * @param tag\n * @param msg\n */\nfunction formatter(tag: string, msg: any[]): any[] {\n    if (!msg || msg.length === 0) {\n        msg = [tag];\n        tag = '';\n    }\n    tag = FORCE_GLOBAL_TAG ? GLOBAL_TAG + (tag ? '::' + tag : '') : tag || GLOBAL_TAG;\n    msg.unshift('[' + tag + '] > ');\n\n    return msg;\n}\n\nenum LOG_LEVEL {\n    LEVEL_ERROR = 'e', // 日志等级-error，只输出error日志\n    LEVEL_WARN = 'w', // 日志等级-warn，输出error，warn日志\n    LEVEL_INFO = 'i', // 日志等级-info，输出error, warn, info日志\n    LEVEL_DEBUG = 'd', // 日志等级-debug，输出error, warn, info, debug日志\n    LEVEL_VERBOSE = 'v' // 日志等级-verbose，输出error, warn, info, debug, verbose日志\n}\n\n/**\n * console日志\n * @class\n */\nclass Log {\n    public static ENABLE_ERROR: boolean = true;\n    public static ENABLE_WARN: boolean = false;\n    public static ENABLE_INFO: boolean = false;\n    public static ENABLE_DEBUG: boolean = false;\n    public static ENABLE_VERBOSE: boolean = false;\n\n    /**\n     * 设置日志输出等级\n     * @param l 日志等级\n     */\n    static level(l: LOG_LEVEL) {\n        Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = Log.ENABLE_VERBOSE = false;\n        switch (l) {\n            case LOG_LEVEL.LEVEL_WARN:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = true;\n                break;\n            case LOG_LEVEL.LEVEL_INFO:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = true;\n                break;\n            case LOG_LEVEL.LEVEL_DEBUG:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = true;\n                break;\n            case LOG_LEVEL.LEVEL_VERBOSE:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = Log.ENABLE_VERBOSE = true;\n                break;\n            default:\n                Log.ENABLE_ERROR = true;\n                break;\n        }\n    }\n\n    /**\n     * error日志\n     * @param tag tag\n     * @param msg 日志信息\n     */\n    static e(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_ERROR) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.error || console.warn || console.log).apply(console, out);\n    }\n\n    /**\n     * warn日志\n     * @param tag tag\n     * @param msg 日志信息\n     */\n    static w(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_WARN) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.warn || console.log).apply(console, out);\n    }\n\n    /**\n     * info日志\n     * @param tag tag\n     * @param msg 日志信息\n     */\n    static i(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_INFO) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.info || console.log).apply(console, out);\n    }\n\n    /**\n     * debug日志\n     * @param tag tag\n     * @param msg 日志信息\n     */\n    static d(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_DEBUG) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.debug || console.log).apply(console, out);\n    }\n\n    /**\n     * verbose日志\n     * @param tag tag\n     * @param msg 日志信息\n     */\n    static v(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_VERBOSE) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        console.log.apply(console, out);\n    }\n}\n\nexport { Log, LOG_LEVEL };\n","export enum ErrorTypes {\n    // 网络错误\n    NETWORK_ERROR = 'networkError',\n    // video错误\n    MEDIA_ERROR = 'mediaError',\n    // 转封装错误\n    MUX_ERROR = 'muxError',\n    // 其他错误\n    OTHER_ERROR = 'otherError',\n    // MSE错误\n    MSE_ERROR = 'mseError'\n};\n\nexport enum ErrorDetails {\n    // NETWORK_ERROR < 100\n    LOAD_ERROR = 10,\n\n    VIDEO_ERROR = 101,\n    UNSUPPORTED = 102,\n    CONFIG_ERROR = 103,\n    MEDIASOURCE_ERROR = 200, // mediaSourceError 初始化MSE错误，MediaSource未定义时触发\n    ADDSOURCEBUFFER_ERROR = 201, // addSourceBufferError MSE增加SourceBuffer失败\n    SOURCEBUFFER_ERROR = 202, // sourceBufferError MSE的SourceBuffer触发错误\n    ENDOFSTREAM_ERROR = 203, // endOfStreamError MSE结束流错误\n    APPENDBUFFER_ERROR = 204, // appendBufferError MSE填充buffer错误\n    PARSING_ERROR = 301, // 解封装错误\n    REMUX_ERROR = 302, // 重新封装错误\n    REMUX_ALLOC_ERROR = 303, // 重新封装alloc mdat存储错误\n};\n","export enum FlvTagType {\n    AUDIO = 8,\n    VIDEO = 9,\n    SCRIPT = 18\n}\n\nexport const FlvSize = {\n    FLV_HEAD_LEN: 13,\n    FLV_TAG_HEAD_LEN: 11,\n    FLV_TAG_SIZE_LEN: 4,\n    AVC_KEY_FRAME_CHECK_LEN: 2\n}\n\nexport class FlvTag {\n    public tagType: FlvTagType = FlvTagType.VIDEO;\n    public dataSize: number = 0;\n    public timestamp: number = 0;\n    public size: number = 0;\n    public cts: number = 0;\n    public frameType: number = 0;\n    public codecId: number = 0;\n    public body: Uint8Array | null = null;\n    public fill?: boolean;\n}\n","/* eslint-disable */\nexport const ObjectAssign\n    = Object.assign\n    || function assign(target, varArgs) {\n        // .length of function is 2\n\n        if (target == null) {\n            // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        const to = Object(target);\n\n        for (let index = 1; index < arguments.length; index++) {\n            const nextSource = arguments[index];\n\n            if (nextSource != null) {\n                // Skip over if undefined or null\n                for (const nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n        return to;\n    };\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nvar Browser: any = {};\n\nfunction detect() {\n    // modified from jquery-browser-plugin\n\n    const ua = self.navigator.userAgent.toLowerCase();\n\n    const match =\n        /(edge)\\/([\\w.]+)/.exec(ua) ||\n        /(opr)[\\/]([\\w.]+)/.exec(ua) ||\n        /(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n        /(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(msie) ([\\w.]+)/.exec(ua) ||\n        (ua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua)) ||\n        (ua.indexOf('compatible') < 0 && /(firefox)[ \\/]([\\w.]+)/.exec(ua)) ||\n        [];\n\n    const platform_match =\n        /(ipad)/.exec(ua) ||\n        /(ipod)/.exec(ua) ||\n        /(windows phone)/.exec(ua) ||\n        /(iphone)/.exec(ua) ||\n        /(kindle)/.exec(ua) ||\n        /(android)/.exec(ua) ||\n        /(windows)/.exec(ua) ||\n        /(mac)/.exec(ua) ||\n        /(linux)/.exec(ua) ||\n        /(cros)/.exec(ua) ||\n        [];\n\n    const matched = {\n        browser: match[5] || match[3] || match[1] || '',\n        version: match[2] || match[4] || '0',\n        majorVersion: match[4] || match[2] || '0',\n        platform: platform_match[0] || ''\n    };\n\n    const browser: any = {};\n    if (matched.browser) {\n        browser[matched.browser] = true;\n\n        const versionArray = matched.majorVersion.split('.');\n        browser.version = {\n            major: parseInt(matched.majorVersion, 10),\n            string: matched.version\n        };\n        if (versionArray.length > 1) {\n            browser.version.minor = parseInt(versionArray[1], 10);\n        }\n        if (versionArray.length > 2) {\n            browser.version.build = parseInt(versionArray[2], 10);\n        }\n    }\n\n    if (matched.platform) {\n        browser[matched.platform] = true;\n    }\n\n    if (browser.chrome || browser.opr || browser.safari) {\n        browser.webkit = true;\n    }\n\n    // MSIE. IE11 has 'rv' identifer\n    if (browser.rv || browser.iemobile) {\n        if (browser.rv) {\n            delete browser.rv;\n        }\n        const msie = 'msie';\n        matched.browser = msie;\n        browser[msie] = true;\n    }\n\n    // Microsoft Edge\n    if (browser.edge) {\n        delete browser.edge;\n        const msedge = 'msedge';\n        matched.browser = msedge;\n        browser[msedge] = true;\n    }\n\n    // Opera 15+\n    if (browser.opr) {\n        const opera = 'opera';\n        matched.browser = opera;\n        browser[opera] = true;\n    }\n\n    // Stock android browsers are marked as Safari\n    if (browser.safari && browser.android) {\n        const android = 'android';\n        matched.browser = android;\n        browser[android] = true;\n    }\n\n    browser.name = matched.browser;\n    browser.platform = matched.platform;\n\n    for (const key in Browser as any) {\n        if (Browser.hasOwnProperty(key)) {\n            delete Browser[key];\n        }\n    }\n    Browser = browser;\n    // Object.assign(Browser, browser);\n}\n\ndetect();\n\nexport default Browser;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","import { EventEmitter } from 'events';\n\nclass Observer extends EventEmitter {\n    trigger(event: string | symbol, ...args: any[]): boolean {\n        return super.emit(event, event, ...args);\n    };\n}\n\nexport default Observer;\n","export enum TrackType {\n    video = 'video',\n    audio = 'audio'\n}\n\nexport enum RemuxerTrackIdConfig {\n    video = 1,\n    audio\n}\n\nexport interface Track {\n    id: number;\n    type: TrackType;\n    codec: string;\n    manifestCodec?: string;\n    container: string;\n    timescale: number;\n    duration: number;\n    samples: any[];\n    inputTimeScale: number;\n    sequenceNumber: number;\n    pid: number;\n}\nexport interface ATrack extends Track {\n    config: number[];\n    isAAC: boolean;\n    samplerate: number;\n    channelCount: number;\n}\nexport interface VTrack extends Track {\n    width: number;\n    height: number;\n    codecWidth: number;\n    codecHeight: number;\n    sps: Uint8Array[];\n    pps: Uint8Array[];\n    pixelRatio: number[];\n    profile: string;\n    level: string;\n    chromaFormat: string;\n    fps: number;\n    dropped: number;\n    refSampleDuration: number;\n}\n\nexport interface Sample {\n    key: boolean;\n    pts: number;\n    dts: number;\n    units: [];\n    debug: string;\n}\n\nexport interface TypeSupported {\n    mp4: boolean;\n    mpeg: boolean;\n    mp3: boolean;\n}\n\nexport interface IRemuxer {\n    readonly ISGenerated: boolean;\n    destroy(): void;\n    setExtra(data: any): void;\n    resetTimeStamp(): void;\n    resetInitSegment(): void;\n    getLastPTS(): any;\n    flush(): any;\n    resetStash(): void;\n    remux(\n        audioTrack: ATrack,\n        videoTrack: VTrack,\n        timeOffset: number,\n        contiguous: boolean,\n        accurateTimeOffset: boolean,\n        isFlush: boolean\n    ): void;\n}\n","export const isFiniteNumber\n    = Number.isFinite\n    || function (value) {\n        return typeof value === 'number' && isFinite(value);\n    };\n","/**\n *  AAC helper\n */\n\nclass AAC {\n    static getSilentFrame(codec: string, channelCount: number): Uint8Array | null {\n        switch (codec) {\n            case 'mp4a.40.2':\n                if (channelCount === 1) {\n                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n                } else if (channelCount === 2) {\n                    return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n                } else if (channelCount === 3) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x8e\n                    ]);\n                } else if (channelCount === 4) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x80,\n                        0x2c,\n                        0x80,\n                        0x08,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 5) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 6) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x00,\n                        0xb2,\n                        0x00,\n                        0x20,\n                        0x08,\n                        0xe0\n                    ]);\n                }\n\n                break;\n            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n            default:\n                if (channelCount === 1) {\n                    /* ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a\n                    4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    */\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x4e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x1c,\n                        0x6,\n                        0xf1,\n                        0xc1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 2) {\n                    /* ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a\n                        4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    */\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 3) {\n                    /* ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a\n                        4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                     */\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                }\n                break;\n        }\n        return null;\n    }\n}\n\nexport default AAC;\n","/**\n * Generate MP4 Box\n */\nimport { TrackType, Track, ATrack, VTrack } from '../types/remux';\nconst UINT32_MAX = Math.pow(2, 32) - 1;\n\nclass MP4 {\n    static types: Record<string, number[]>;\n    static HDLR_TYPES: Record<string, Uint8Array>;\n\n    static STTS: Uint8Array;\n    static STSC: Uint8Array;\n    static STCO: Uint8Array;\n    static STSZ: Uint8Array;\n    static VMHD: Uint8Array;\n    static SMHD: Uint8Array;\n    static STSD: Uint8Array;\n    static FTYP_AVC: Uint8Array;\n    static FTYP_HEVC: Uint8Array;\n    static DINF: Uint8Array;\n\n    static init() {\n        MP4.types = {\n            'avc1': [], // codingname\n            'avcC': [],\n            'btrt': [],\n            'dinf': [],\n            'dref': [],\n            'esds': [],\n            'ftyp': [],\n            'hdlr': [],\n            'mdat': [],\n            'mdhd': [],\n            'mdia': [],\n            'mfhd': [],\n            'minf': [],\n            'moof': [],\n            'moov': [],\n            'mp4a': [],\n            '.mp3': [],\n            'mvex': [],\n            'mvhd': [],\n            'pasp': [],\n            'sdtp': [],\n            'stbl': [],\n            'stco': [],\n            'stsc': [],\n            'stsd': [],\n            'stsz': [],\n            'stts': [],\n            'tfdt': [],\n            'tfhd': [],\n            'traf': [],\n            'trak': [],\n            'trun': [],\n            'trex': [],\n            'tkhd': [],\n            'vmhd': [],\n            'smhd': [],\n            'hev1': [],\n            'hvcC': []\n        };\n\n        let i;\n        for (i in MP4.types) {\n            if (MP4.types.hasOwnProperty(i)) {\n                MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n            }\n        }\n\n        const videoHdlr = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined\n            0x76,\n            0x69,\n            0x64,\n            0x65, // handler_type: 'vide'\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x56,\n            0x69,\n            0x64,\n            0x65,\n            0x6f,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'VideoHandler'\n        ]);\n\n        const audioHdlr = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined\n            0x73,\n            0x6f,\n            0x75,\n            0x6e, // handler_type: 'soun'\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x53,\n            0x6f,\n            0x75,\n            0x6e,\n            0x64,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'SoundHandler'\n        ]);\n\n        MP4.HDLR_TYPES = {\n            video: videoHdlr,\n            audio: audioHdlr\n        };\n\n        const dref = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01, // entry_count\n            0x00,\n            0x00,\n            0x00,\n            0x0c, // entry_size\n            0x75,\n            0x72,\n            0x6c,\n            0x20, // 'url' type\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x01 // entry_flags\n        ]);\n\n        const stco = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00 // entry_count\n        ]);\n\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n        MP4.STSZ = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00, // sample_size\n            0x00,\n            0x00,\n            0x00,\n            0x00 // sample_count\n        ]);\n        MP4.VMHD = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x01, // flags\n            0x00,\n            0x00, // graphicsmode\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00 // opcolor\n        ]);\n        MP4.SMHD = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00, // balance\n            0x00,\n            0x00 // reserved\n        ]);\n\n        MP4.STSD = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01\n        ]); // entry_count\n\n        const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n        const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n        const hev1Brand = new Uint8Array([104, 101, 118, 49]); // hev1\n        const minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n        MP4.FTYP_AVC = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n        MP4.FTYP_HEVC = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, hev1Brand);\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    }\n\n    static box(type: number[], ...payload: Uint8Array[]) {\n        let size = 8,\n            i = payload.length,\n            len = i,\n            result;\n        // calculate the total size we need to allocate\n        while (i--) {\n            size += payload[i].byteLength;\n        }\n\n        result = new Uint8Array(size);\n        result[0] = size >> 24 & 0xff;\n        result[1] = size >> 16 & 0xff;\n        result[2] = size >> 8 & 0xff;\n        result[3] = size & 0xff;\n        result.set(type, 4);\n        // copy the payload into the result\n        for (i = 0, size = 8; i < len; i++) {\n            // copy payload[i] array @ offset size\n            result.set(payload[i], size);\n            size += payload[i].byteLength;\n        }\n        return result;\n    }\n\n    static hdlr(type: string) {\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    }\n\n    static mdat(data: Uint8Array) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n\n    static mdhd(timescale: number, duration: number) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(\n            MP4.types.mdhd,\n            new Uint8Array([\n                0x01, // version 1\n                0x00,\n                0x00,\n                0x00, // flags\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x02, // creation_time\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x03, // modification_time\n                timescale >> 24 & 0xff,\n                timescale >> 16 & 0xff,\n                timescale >> 8 & 0xff,\n                timescale & 0xff, // timescale\n                upperWordDuration >> 24,\n                upperWordDuration >> 16 & 0xff,\n                upperWordDuration >> 8 & 0xff,\n                upperWordDuration & 0xff,\n                lowerWordDuration >> 24,\n                lowerWordDuration >> 16 & 0xff,\n                lowerWordDuration >> 8 & 0xff,\n                lowerWordDuration & 0xff,\n                0x55,\n                0xc4, // 'und' language (undetermined)\n                0x00,\n                0x00\n            ])\n        );\n    }\n\n    static mdia(track: Track) {\n        return MP4.box(\n            MP4.types.mdia,\n            MP4.mdhd(track.timescale, track.duration),\n            MP4.hdlr(track.type),\n            MP4.minf(track)\n        );\n    }\n\n    static mfhd(sequenceNumber: number) {\n        return MP4.box(\n            MP4.types.mfhd,\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00,\n                0x00, // flags\n                sequenceNumber >> 24,\n                sequenceNumber >> 16 & 0xff,\n                sequenceNumber >> 8 & 0xff,\n                sequenceNumber & 0xff // sequence_number\n            ])\n        );\n    }\n\n    static minf(track: Track) {\n        if (track.type === 'audio') {\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n        }\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n\n    static moof(sn: number, baseMediaDecodeTime: number, track: Track) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    }\n    /**\n     * @param tracks... (optional) {array} the tracks associated with this movie\n     */\n    static moov(tracks: Track[]) {\n        let i = tracks.length,\n            boxes = [];\n\n        while (i--) {\n            boxes[i] = MP4.trak(tracks[i]);\n        }\n        return MP4.box(\n            MP4.types.moov,\n            ...[MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks))\n        );\n    }\n\n    static mvex(tracks: Track[]) {\n        let i = tracks.length;\n        const boxes = [];\n\n        while (i--) {\n            boxes[i] = MP4.trex(tracks[i]);\n        }\n\n        return MP4.box(MP4.types.mvex, ...boxes);\n    }\n\n    static mvhd(timescale: number, duration: number) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        const bytes = new Uint8Array([\n            0x01, // version 1\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02, // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03, // modification_time\n            timescale >> 24 & 0xff,\n            timescale >> 16 & 0xff,\n            timescale >> 8 & 0xff,\n            timescale & 0xff, // timescale\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x00,\n            0x01,\n            0x00,\n            0x00, // 1.0 rate\n            0x01,\n            0x00, // 1.0 volume\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x40,\n            0x00,\n            0x00,\n            0x00, // transformation: unity matrix\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined\n            0xff,\n            0xff,\n            0xff,\n            0xff // next_track_ID\n        ]);\n        return MP4.box(MP4.types.mvhd, bytes);\n    }\n\n    static sdtp(track: Track) {\n        let samples = track.samples || [],\n            bytes = new Uint8Array(4 + samples.length),\n            flags,\n            i;\n        // leave the full box header (4 bytes) all zero\n        // write the sample table\n        for (i = 0; i < samples.length; i++) {\n            flags = samples[i].flags;\n            bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n        }\n\n        return MP4.box(MP4.types.sdtp, bytes);\n    }\n\n    static stbl(track: Track) {\n        return MP4.box(\n            MP4.types.stbl,\n            MP4.stsd(track),\n            MP4.box(MP4.types.stts, MP4.STTS),\n            MP4.box(MP4.types.stsc, MP4.STSC),\n            MP4.box(MP4.types.stsz, MP4.STSZ),\n            MP4.box(MP4.types.stco, MP4.STCO)\n        );\n    }\n\n    static avc1(track: VTrack) {\n        let sps: any = [],\n            pps: any = [],\n            i,\n            data,\n            len;\n        // assemble the SPSs\n\n        for (i = 0; i < track.sps.length; i++) {\n            data = track.sps[i];\n            len = data.byteLength;\n            sps.push(len >>> 8 & 0xff);\n            sps.push(len & 0xff);\n\n            // SPS\n            sps = sps.concat(Array.prototype.slice.call(data));\n        }\n\n        // assemble the PPSs\n        for (i = 0; i < track.pps.length; i++) {\n            data = track.pps[i];\n            len = data.byteLength;\n            pps.push(len >>> 8 & 0xff);\n            pps.push(len & 0xff);\n\n            pps = pps.concat(Array.prototype.slice.call(data));\n        }\n\n        const avcc = MP4.box(\n                MP4.types.avcC,\n                new Uint8Array(\n                    [\n                        0x01, // version\n                        sps[3], // profile\n                        sps[4], // profile compat\n                        sps[5], // level\n                        0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n                        0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n                    ]\n                        .concat(sps)\n                        .concat([\n                            track.pps.length // numOfPictureParameterSets\n                        ])\n                        .concat(pps)\n                )\n            ), // \"PPS\"\n            width = track.width,\n            height = track.height,\n            hSpacing = track.pixelRatio[0],\n            vSpacing = track.pixelRatio[1];\n\n        return MP4.box(\n            MP4.types.avc1,\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // data_reference_index\n                0x00,\n                0x00, // pre_defined\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // pre_defined\n                width >> 8 & 0xff,\n                width & 0xff, // width\n                height >> 8 & 0xff,\n                height & 0xff, // height\n                0x00,\n                0x48,\n                0x00,\n                0x00, // horizresolution\n                0x00,\n                0x48,\n                0x00,\n                0x00, // vertresolution\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // frame_count\n                0x12,\n                0x64,\n                0x61,\n                0x69,\n                0x6c, // dailymotion/hls.js\n                0x79,\n                0x6d,\n                0x6f,\n                0x74,\n                0x69,\n                0x6f,\n                0x6e,\n                0x2f,\n                0x68,\n                0x6c,\n                0x73,\n                0x2e,\n                0x6a,\n                0x73,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // compressorname\n                0x00,\n                0x18, // depth = 24\n                0x11,\n                0x11\n            ]), // pre_defined = -1\n            avcc,\n            MP4.box(\n                MP4.types.btrt,\n                new Uint8Array([\n                    0x00,\n                    0x1c,\n                    0x9c,\n                    0x80, // bufferSizeDB\n                    0x00,\n                    0x2d,\n                    0xc6,\n                    0xc0, // maxBitrate\n                    0x00,\n                    0x2d,\n                    0xc6,\n                    0xc0\n                ])\n            ), // avgBitrate\n            MP4.box(\n                MP4.types.pasp,\n                new Uint8Array([\n                    hSpacing >> 24, // hSpacing\n                    hSpacing >> 16 & 0xff,\n                    hSpacing >> 8 & 0xff,\n                    hSpacing & 0xff,\n                    vSpacing >> 24, // vSpacing\n                    vSpacing >> 16 & 0xff,\n                    vSpacing >> 8 & 0xff,\n                    vSpacing & 0xff\n                ])\n            )\n        );\n    }\n\n    static hev1(track: VTrack) {\n        const hvcc = track.hvcc;\n        const width = track.codecWidth,\n            height = track.codecHeight;\n        const data = new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved(4)\n            0x00,\n            0x00,\n            0x00,\n            0x01, // reserved(2) + data_reference_index(2)\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined(2) + reserved(2)\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined: 3 * 4 bytes\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            width >>> 8 & 0xff, // width: 2 bytes\n            width & 0xff,\n            height >>> 8 & 0xff, // height: 2 bytes\n            height & 0xff,\n            0x00,\n            0x48,\n            0x00,\n            0x00, // horizresolution: 4 bytes\n            0x00,\n            0x48,\n            0x00,\n            0x00, // vertresolution: 4 bytes\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved: 4 bytes\n            0x00,\n            0x01, // frame_count\n            0x0a, // strlen\n            0x78,\n            0x71,\n            0x71,\n            0x2f, // compressorname: 32 bytes\n            0x66,\n            0x6c,\n            0x76,\n            0x2e,\n            0x6a,\n            0x73,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x18, // depth\n            0xff,\n            0xff // pre_defined = -1\n        ]);\n        return MP4.box(MP4.types.hev1, data, MP4.box(MP4.types.hvcC, hvcc));\n    }\n\n    static esds(track: ATrack) {\n        const configlen = track.config.length;\n        return new Uint8Array(\n            [\n                0x00, // version 0\n                0x00,\n                0x00,\n                0x00, // flags\n\n                0x03, // descriptor_type\n                0x17 + configlen, // length\n                0x00,\n                0x01, // es_id\n                0x00, // stream_priority\n\n                0x04, // descriptor_type\n                0x0f + configlen, // length\n                0x40, // codec : mpeg4_audio\n                0x15, // stream_type\n                0x00,\n                0x00,\n                0x00, // buffer_size\n                0x00,\n                0x00,\n                0x00,\n                0x00, // maxBitrate\n                0x00,\n                0x00,\n                0x00,\n                0x00, // avgBitrate\n\n                0x05 // descriptor_type\n            ]\n                .concat([configlen])\n                .concat(track.config)\n                .concat([0x06, 0x01, 0x02])\n        ); // GASpecificConfig)); // length + audio config descriptor\n    }\n\n    static mp4a(track: ATrack) {\n        const samplerate = track.samplerate;\n        return MP4.box(\n            MP4.types.mp4a,\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // data_reference_index\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                track.channelCount, // channelcount\n                0x00,\n                0x10, // sampleSize:16bits\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved2\n                samplerate >> 8 & 0xff,\n                samplerate & 0xff, //\n                0x00,\n                0x00\n            ]),\n            MP4.box(MP4.types.esds, MP4.esds(track))\n        );\n    }\n\n    static mp3(track: ATrack) {\n        const samplerate = track.samplerate;\n        return MP4.box(\n            MP4.types['.mp3'],\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // data_reference_index\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                track.channelCount, // channelcount\n                0x00,\n                0x10, // sampleSize:16bits\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved2\n                samplerate >> 8 & 0xff,\n                samplerate & 0xff, //\n                0x00,\n                0x00\n            ])\n        );\n    }\n\n    static stsd(track: Track) {\n        if (track.type === TrackType.audio) {\n            if (!(<ATrack>track).isAAC && track.codec === 'mp3') {\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(<ATrack>track));\n            }\n\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(<ATrack>track));\n        }\n        if (track.codec.indexOf('hev1') === 0) {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.hev1(<VTrack>track));\n        }\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(<VTrack>track));\n    }\n\n    static tkhd(track: ATrack & VTrack) {\n        const id = track.id,\n            duration = track.duration * track.timescale,\n            upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),\n            lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        let width = 0,\n            height = 0;\n        if (track.hasOwnProperty('width')) {\n            width = track.width;\n        }\n        if (track.hasOwnProperty('height')) {\n            height = track.height;\n        }\n        return MP4.box(\n            MP4.types.tkhd,\n            new Uint8Array([\n                0x01, // version 1\n                0x00,\n                0x00,\n                0x07, // flags\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x02, // creation_time\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x03, // modification_time\n                id >> 24 & 0xff,\n                id >> 16 & 0xff,\n                id >> 8 & 0xff,\n                id & 0xff, // track_ID\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                upperWordDuration >> 24,\n                upperWordDuration >> 16 & 0xff,\n                upperWordDuration >> 8 & 0xff,\n                upperWordDuration & 0xff,\n                lowerWordDuration >> 24,\n                lowerWordDuration >> 16 & 0xff,\n                lowerWordDuration >> 8 & 0xff,\n                lowerWordDuration & 0xff,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00, // layer\n                0x00,\n                0x00, // alternate_group\n                0x00,\n                0x00, // non-audio track volume\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x01,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x40,\n                0x00,\n                0x00,\n                0x00, // transformation: unity matrix\n                width >> 8 & 0xff,\n                width & 0xff,\n                0x00,\n                0x00, // width\n                height >> 8 & 0xff,\n                height & 0xff,\n                0x00,\n                0x00 // height\n            ])\n        );\n    }\n\n    static traf(track: Track, baseMediaDecodeTime: number) {\n        const sampleDependencyTable = MP4.sdtp(track),\n            id = track.id,\n            upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),\n            lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n        return MP4.box(\n            MP4.types.traf,\n            MP4.box(\n                MP4.types.tfhd,\n                new Uint8Array([\n                    0x00, // version 0\n                    0x00,\n                    0x00,\n                    0x00, // flags\n                    id >> 24,\n                    id >> 16 & 0xff,\n                    id >> 8 & 0xff,\n                    id & 0xff // track_ID\n                ])\n            ),\n            MP4.box(\n                MP4.types.tfdt,\n                new Uint8Array([\n                    0x01, // version 1\n                    0x00,\n                    0x00,\n                    0x00, // flags\n                    upperWordBaseMediaDecodeTime >> 24,\n                    upperWordBaseMediaDecodeTime >> 16 & 0xff,\n                    upperWordBaseMediaDecodeTime >> 8 & 0xff,\n                    upperWordBaseMediaDecodeTime & 0xff,\n                    lowerWordBaseMediaDecodeTime >> 24,\n                    lowerWordBaseMediaDecodeTime >> 16 & 0xff,\n                    lowerWordBaseMediaDecodeTime >> 8 & 0xff,\n                    lowerWordBaseMediaDecodeTime & 0xff\n                ])\n            ),\n            MP4.trun(\n                track,\n                sampleDependencyTable.length\n                + 16 // tfhd\n                + 20 // tfdt\n                + 8 // traf header\n                + 16 // mfhd\n                + 8 // moof header\n                    + 8\n            ), // mdat header\n            sampleDependencyTable\n        );\n    }\n\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n    static trak(track: Track): Uint8Array {\n        // TODO:\n        // track.duration = track.duration || 0xffffffff;\n        return MP4.box(MP4.types.trak, MP4.tkhd(<ATrack & VTrack>track), MP4.mdia(track));\n    }\n\n    static trex(track: Track): Uint8Array {\n        const id = track.id;\n        return MP4.box(\n            MP4.types.trex,\n            new Uint8Array([\n                0x00, // version 0\n                0x00,\n                0x00,\n                0x00, // flags\n                id >> 24,\n                id >> 16 & 0xff,\n                id >> 8 & 0xff,\n                id & 0xff, // track_ID\n                0x00,\n                0x00,\n                0x00,\n                0x01, // default_sample_description_index\n                0x00,\n                0x00,\n                0x00,\n                0x00, // default_sample_duration\n                0x00,\n                0x00,\n                0x00,\n                0x00, // default_sample_size\n                0x00,\n                0x01,\n                0x00,\n                0x01 // default_sample_flags\n            ])\n        );\n    }\n\n    static trun(track: Track, offset: number) {\n        let samples = track.samples || [],\n            len = samples.length,\n            arraylen = 12 + 16 * len,\n            array = new Uint8Array(arraylen),\n            i,\n            sample,\n            duration,\n            size,\n            flags,\n            cts;\n        offset += 8 + arraylen;\n        array.set(\n            [\n                0x00, // version 0\n                0x00,\n                0x0f,\n                0x01, // flags\n                len >>> 24 & 0xff,\n                len >>> 16 & 0xff,\n                len >>> 8 & 0xff,\n                len & 0xff, // sample_count\n                offset >>> 24 & 0xff,\n                offset >>> 16 & 0xff,\n                offset >>> 8 & 0xff,\n                offset & 0xff // data_offset\n            ],\n            0\n        );\n        for (i = 0; i < len; i++) {\n            sample = samples[i];\n            duration = sample.duration;\n            size = sample.size;\n            flags = sample.flags;\n            cts = sample.cts;\n            array.set(\n                [\n                    duration >>> 24 & 0xff,\n                    duration >>> 16 & 0xff,\n                    duration >>> 8 & 0xff,\n                    duration & 0xff, // sample_duration\n                    size >>> 24 & 0xff,\n                    size >>> 16 & 0xff,\n                    size >>> 8 & 0xff,\n                    size & 0xff, // sample_size\n                    flags.isLeading << 2 | flags.dependsOn,\n                    flags.isDependedOn << 6\n                        | flags.hasRedundancy << 4\n                        | flags.paddingValue << 1\n                        | flags.isNonSync,\n                    flags.degradPrio & 0xf0 << 8,\n                    flags.degradPrio & 0x0f, // sample_flags\n                    cts >>> 24 & 0xff,\n                    cts >>> 16 & 0xff,\n                    cts >>> 8 & 0xff,\n                    cts & 0xff // sample_composition_time_offset\n                ],\n                12 + 16 * i\n            );\n        }\n        return MP4.box(MP4.types.trun, array);\n    }\n\n    static initSegment<T extends Track>(tracks: T[]) {\n        if (!MP4.types) {\n            MP4.init();\n        }\n        let ftyp = MP4.FTYP_AVC;\n        let i = tracks.length;\n        while (i--) {\n            if (tracks[i].type === 'video' && tracks[i].codec.indexOf('hev1') === 0) {\n                ftyp = MP4.FTYP_HEVC;\n            }\n        }\n        const movie = MP4.moov(tracks);\n        const result = new Uint8Array(ftyp.byteLength + movie.byteLength);\n        result.set(ftyp);\n        result.set(movie, ftyp.byteLength);\n        return result;\n    }\n}\n\nexport default MP4;\n","/**\n * fMP4 remuxer\n */\n\nimport { ErrorDetails, ErrorTypes } from '../core/errors';\nimport LasEvents from '../core/events';\nimport Observer from '../core/observer';\nimport { FLVTransConfig } from '../types/core';\nimport { ATrack, IRemuxer, TypeSupported, VTrack } from '../types/remux';\nimport Browser from '../utils/browser';\nimport { Log } from '../utils/log';\nimport AAC from './aac-helper';\nimport MP4 from './mp4-generator';\n\n\n\n// 100 seconds\nconst MAX_SILENT_FRAME_DURATION = 100 * 1000;\n\ntype StashInfo = { timeOffset: number; accurateTimeOffset: boolean; track: VTrack; sequenceNumber: number };\n\ntype Stat = {\n    ISGenerated: boolean;\n    nextAudioPts?: number;\n    nextAvcDts?: number;\n    initPTS?: number;\n    initDTS?: number;\n    videoTime: {\n        nbSamples: number;\n        firstDTS: number;\n        sampleDuration: number;\n        vLastPTS: number;\n        aLastPTS: number;\n        endDts?: number;\n    };\n};\n\nclass MP4Remuxer implements IRemuxer {\n    private _observer: Observer;\n    private _config: FLVTransConfig;\n    private _typeSupported: TypeSupported;\n    private _isSafari: boolean;\n    private _forceFirstIDR: boolean;\n    private _stash: boolean;\n    private _stashInfo: StashInfo;\n    private _stashLastVideoSample: any;\n    private _ISGenerated: boolean = false;\n    private _videoTime!: {\n        nbSamples: number;\n        firstDTS: number;\n        sampleDuration: number;\n        vLastPTS: number;\n        aLastPTS: number;\n        endDts?: number;\n    };\n    private _extra: any;\n\n    private _nextAudioPts?: number;\n    private _nextAvcDts?: number;\n    private _initPTS?: number;\n    private _initDTS?: number;\n    private _initSegment: Record<string, Uint8Array> = {};\n\n    constructor(observer: Observer, config: FLVTransConfig, typeSupported: TypeSupported, vendor: string = '') {\n        this._observer = observer;\n        this._config = config;\n        this._typeSupported = typeSupported;\n        const userAgent = navigator.userAgent;\n        this._isSafari = !!(vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS'));\n        this._ISGenerated = false;\n        this._stash = !config.gopRemux;\n        // 计算平均sampleDuration\n        this._resetVideoTime();\n        this._stashInfo = <StashInfo>{};\n        if (!MP4.types) {\n            MP4.init();\n        }\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR =\n            Browser.chrome &&\n                (Browser.version.major < 50 || (Browser.version.major === 50 && Browser.version.build < 2661))\n                ? true\n                : false;\n    }\n\n    get ISGenerated(): boolean {\n        return this._ISGenerated;\n    }\n\n    public setStat(stat: Stat): void {\n        if (stat) {\n            this._ISGenerated = stat.ISGenerated;\n            this._nextAudioPts = stat.nextAudioPts;\n            this._nextAvcDts = stat.nextAvcDts;\n            this._initPTS = stat.initPTS;\n            this._initDTS = stat.initDTS;\n            this._videoTime.nbSamples = stat.videoTime.nbSamples;\n            this._videoTime.firstDTS = stat.videoTime.firstDTS;\n            this._videoTime.sampleDuration = stat.videoTime.sampleDuration;\n            this._videoTime.vLastPTS = stat.videoTime.vLastPTS;\n            this._videoTime.aLastPTS = stat.videoTime.aLastPTS;\n            this._videoTime.endDts = stat.videoTime.endDts;\n        }\n    }\n    public getStat(): Stat {\n        return {\n            ISGenerated: this._ISGenerated,\n            nextAudioPts: this._nextAudioPts,\n            nextAvcDts: this._nextAvcDts,\n            initPTS: this._initPTS,\n            initDTS: this._initDTS,\n            videoTime: {\n                nbSamples: this._videoTime.nbSamples,\n                firstDTS: this._videoTime.firstDTS,\n                sampleDuration: this._videoTime.sampleDuration,\n                vLastPTS: this._videoTime.vLastPTS,\n                aLastPTS: this._videoTime.aLastPTS,\n                endDts: this._videoTime.endDts\n            }\n        };\n    }\n\n    destroy() { }\n\n    setExtra(data: any) {\n        this._extra = data;\n    }\n\n    resetTimeStamp(defaultTimeStamp?: number) {\n        this._initPTS = this._initDTS = defaultTimeStamp;\n        this._resetVideoTime();\n    }\n\n    resetInitSegment() {\n        this._ISGenerated = false;\n        this._initSegment = {};\n        this.resetStash();\n    }\n\n    getLastPTS() {\n        return { video: this._videoTime.vLastPTS, audio: this._videoTime.aLastPTS };\n    }\n\n    flush(audioTrackLength = 0) {\n        let videoData = null;\n        if (this._stash && this._stashLastVideoSample) {\n            const info = this._stashInfo;\n            info.track.samples = [this._stashLastVideoSample];\n            this._stashLastVideoSample = null;\n            info.sequenceNumber += 1;\n            videoData = this.remuxVideo(info.track, info.timeOffset, true, audioTrackLength, info.accurateTimeOffset);\n        }\n        this.resetStash();\n        return videoData;\n    }\n\n    resetStash() {\n        this._stashLastVideoSample = null;\n        this._stashInfo = <StashInfo>{};\n    }\n\n    remux(\n        audioTrack: ATrack,\n        videoTrack: VTrack,\n        timeOffset: number,\n        contiguous: boolean,\n        accurateTimeOffset: boolean,\n        isFlush: boolean = false\n    ) {\n        // generate Init Segment if needed\n        if (!this._ISGenerated) {\n            this.generateIS(audioTrack, videoTrack, timeOffset);\n        }\n\n        // 兼容safari\n        if (!contiguous && videoTrack.samples.length) {\n            videoTrack.samples[0].pts = videoTrack.samples[0].dts;\n        }\n\n        if (this._ISGenerated) {\n            const nbVideoStashSamples = isFlush && this._stashLastVideoSample ? 1 : 0;\n            const nbAudioSamples = audioTrack.samples.length;\n            const nbVideoSamples = videoTrack.samples.length;\n            let audioTimeOffset = timeOffset;\n            let videoTimeOffset = timeOffset;\n            if (nbAudioSamples && nbVideoSamples) {\n                if (!contiguous && accurateTimeOffset) {\n                    // 利用首个视频帧填充视频帧，accurateTimeOffset=true会根据timeoffset填充音频帧\n                    if (audioTrack.samples[0].pts - videoTrack.samples[0].pts < 0) {\n                        const sample = Object.assign({}, videoTrack.samples[0]);\n                        sample.dts = sample.pts = audioTrack.samples[0].pts;\n                        videoTrack.samples.unshift(sample);\n                    }\n                } else {\n                    // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n                    // if first audio DTS is not aligned with first video DTS then we need to take that into account\n                    // when providing timeOffset to remuxAudio / remuxVideo.\n                    // if we don't do that, there might be a permanent / small drift between audio and video streams\n                    const audiovideoDeltaDts =\n                        (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;\n                    audioTimeOffset += Math.max(0, audiovideoDeltaDts);\n                    videoTimeOffset += Math.max(0, -audiovideoDeltaDts);\n                }\n            }\n            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is\n            // calculated in remuxAudio.\n            // Log.v('nb AAC samples:' + audioTrack.samples.length);\n            if (nbAudioSamples) {\n                // if initSegment was generated without video samples, regenerate it again\n                if (!audioTrack.timescale) {\n                    Log.w('regenerate InitSegment as audio detected');\n                    this.generateIS(audioTrack, videoTrack, timeOffset);\n                }\n                const audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);\n                // Log.v('nb AVC samples:' + videoTrack.samples.length);\n                let audioTrackLength;\n                if (audioData) {\n                    audioTrackLength = audioData.endPTS - audioData.startPTS;\n                }\n                if (nbVideoSamples) {\n                    // if initSegment was generated without video samples, regenerate it again\n                    if (!videoTrack.timescale) {\n                        Log.w('regenerate InitSegment as video detected');\n                        this.generateIS(audioTrack, videoTrack, timeOffset);\n                    }\n                    this.remuxVideo(\n                        videoTrack,\n                        videoTimeOffset,\n                        contiguous,\n                        audioTrackLength,\n                        accurateTimeOffset,\n                        isFlush\n                    );\n                } else {\n                    this.flush(audioTrackLength);\n                }\n            } else {\n                // Log.v('nb AVC samples:' + videoTrack.samples.length);\n                let videoData = null;\n                if (nbVideoSamples) {\n                    videoData = this.remuxVideo(\n                        videoTrack,\n                        videoTimeOffset,\n                        contiguous,\n                        0,\n                        accurateTimeOffset,\n                        isFlush\n                    );\n                } else if (nbVideoStashSamples) {\n                    videoData = this.flush();\n                }\n                if (\n                    videoData &&\n                    audioTrack.codec &&\n                    Number.isFinite(videoData.startDTS) &&\n                    Number.isFinite(videoData.endDTS)\n                ) {\n                    this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);\n                }\n            }\n        }\n    }\n\n    generateIS(audioTrack: ATrack, videoTrack: VTrack, timeOffset: number) {\n        const observer = this._observer,\n            audioSamples = audioTrack.samples,\n            videoSamples = videoTrack.samples,\n            typeSupported = this._typeSupported,\n            tracks: any = {},\n            data = { tracks: tracks },\n            computePTSDTS = typeof this._initPTS === 'undefined';\n        let container = 'audio/mp4',\n            initPTS,\n            initDTS;\n\n        if (computePTSDTS) {\n            initPTS = initDTS = Infinity;\n        }\n\n        if (audioTrack.config && audioSamples.length) {\n            // let's use audio sampling rate as MP4 time scale.\n            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n            // using audio sampling rate here helps having an integer MP4 frame duration\n            // this avoids potential rounding issue and AV sync issue\n            audioTrack.timescale = audioTrack.samplerate;\n            Log.v(`audio sampling rate : ${audioTrack.samplerate}`);\n            if (!audioTrack.isAAC) {\n                if (typeSupported.mpeg) {\n                    // Chrome and Safari\n                    container = 'audio/mpeg';\n                    audioTrack.codec = '';\n                } else if (typeSupported.mp3) {\n                    // Firefox\n                    audioTrack.codec = 'mp3';\n                }\n            }\n            this._initSegment.audio =\n                !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : MP4.initSegment([audioTrack]);\n            tracks.audio = {\n                container: container,\n                codec: audioTrack.codec,\n                metadata: {\n                    channelCount: audioTrack.channelCount,\n                    audioSampleRate: audioTrack.samplerate\n                }\n            };\n            if (computePTSDTS) {\n                // remember first PTS of this demuxing context. for audio, PTS = DTS\n                initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;\n            }\n        }\n\n        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n            // let's use input time scale as MP4 video timescale\n            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n            const inputTimeScale = videoTrack.inputTimeScale;\n            videoTrack.timescale = inputTimeScale;\n            this._initSegment.video = MP4.initSegment([videoTrack]);\n            tracks.video = {\n                container: 'video/mp4',\n                codec: videoTrack.codec,\n                metadata: {\n                    width: videoTrack.width,\n                    height: videoTrack.height,\n                    fps: videoTrack.fps,\n                    profile: videoTrack.profile,\n                    level: videoTrack.level,\n                    chromaFormat: videoTrack.chromaFormat\n                }\n            };\n            if (computePTSDTS) {\n                initPTS = Math.min(initPTS ? initPTS : Infinity, videoSamples[0].pts - inputTimeScale * timeOffset);\n                initDTS = Math.min(initDTS ? initDTS : Infinity, videoSamples[0].dts - inputTimeScale * timeOffset);\n                this._observer.trigger(LasEvents.INIT_PTS_FOUND, { initPTS: initPTS });\n            }\n        }\n\n        if (Object.keys(tracks).length) {\n            observer.trigger(LasEvents.PARSING_INIT_SEGMENT, data);\n            this._ISGenerated = true;\n            if (computePTSDTS) {\n                this._initPTS = initPTS;\n                this._initDTS = initDTS;\n            }\n        } else {\n            observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: false,\n                reason: 'no audio/video samples found'\n            });\n        }\n    }\n\n    remuxVideo(\n        track: VTrack,\n        timeOffset: number,\n        contiguous: boolean,\n        audioTrackLength?: number,\n        accurateTimeOffset: boolean = false,\n        isFlush: boolean = false\n    ) {\n        const timeScale = track.timescale,\n            inputSamples = track.samples,\n            outputSamples = [],\n            ptsNormalize = this._PTSNormalize,\n            initPTS = this._initPTS,\n            streamDTS = inputSamples[0].streamDTS / 1000,\n            key = inputSamples[0].key,\n            time = this._videoTime;\n        let offset = 8,\n            mp4SampleDuration = 0,\n            mdat,\n            moof = null,\n            firstPTS = 0,\n            firstDTS = 0,\n            lastPTS = 0,\n            lastDTS = 0,\n            nbSamples = inputSamples.length;\n        if (typeof initPTS === 'undefined') {\n            return;\n        }\n        // for (let i = 0; i < track.samples.length; i++) {\n        //   let avcSample = track.samples[i];\n        //   let units = avcSample.units;\n        //   let unitsString = '';\n        //   for (let j = 0; j < units.length ; j++) {\n        //     unitsString += units[j].type + ',';\n        //     if (units[j].data.length < 500) {\n        //       unitsString += Hex.hexDump(units[j].data);\n        //     }\n        //   }\n        //   Log.v(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);\n        // }\n\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        let nextAvcDts = this._nextAvcDts;\n\n        const isSafari = this._isSafari;\n        if (nbSamples === 0 || track.timescale === 0) {\n            return null;\n        }\n\n        // Safari does not like overlapping DTS on consecutive fragments.\n        // let's use nextAvcDts to overcome this if fragments are consecutive\n        if (isSafari) {\n            // also consider consecutive fragments as being contiguous (even if a level switch occurs),\n            // for sake of clarity:\n            // consecutive fragments are frags with\n            //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n            //  - less than 200 ms PTS gaps (timeScale/5)\n            contiguous =\n                contiguous ||\n                !!(\n                    inputSamples.length &&\n                    nextAvcDts &&\n                    ((accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1) ||\n                        Math.abs(inputSamples[0].pts - nextAvcDts - initPTS) < timeScale / 5)\n                );\n        }\n\n        if (!contiguous) {\n            // if not contiguous, let's use target timeOffset\n            nextAvcDts = timeOffset * timeScale;\n            this._resetVideoTime();\n        }\n        if (typeof nextAvcDts === 'undefined') {\n            return;\n        }\n        // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n        // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n        inputSamples.forEach(function (sample) {\n            sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);\n            sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);\n        });\n\n        // sort video samples by DTS then PTS then demux id order\n        inputSamples.sort(function (a, b) {\n            const deltadts = a.dts - b.dts;\n            const deltapts = a.pts - b.pts;\n            return deltadts || (deltapts || a.id - b.id);\n        });\n\n        // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)\n        const PTSDTSshift = inputSamples.reduce(\n            (prev, curr) => Math.max(Math.min(prev, curr.pts - curr.dts), -18000),\n            0\n        );\n        if (PTSDTSshift < 0) {\n            Log.w(\n                `PTS < DTS detected in video samples, shifting DTS by ${Math.round(\n                    PTSDTSshift / 90\n                )} ms to overcome this issue`\n            );\n            for (let i = 0; i < inputSamples.length; i++) {\n                inputSamples[i].dts += PTSDTSshift;\n            }\n        }\n        // 删除最后一个sample并缓存，用于计算remux最后一个sampleDuration\n        if (this._stash) {\n            this._stashInfo.timeOffset = timeOffset;\n            this._stashInfo.accurateTimeOffset = accurateTimeOffset;\n            this._stashInfo.track = track;\n            if (this._stashLastVideoSample) {\n                nbSamples++;\n                inputSamples.unshift(this._stashLastVideoSample);\n                this._stashLastVideoSample = null;\n            }\n            if (inputSamples.length > 1 && !isFlush) {\n                this._stashLastVideoSample = inputSamples.pop();\n                nbSamples--;\n            }\n        }\n        // compute first DTS and last DTS, normalize them against reference value\n        let sample = inputSamples[0];\n        firstDTS = Math.max(sample.dts, 0);\n        firstPTS = Math.max(sample.pts, 0);\n\n        // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)\n        const delta = Math.round((firstDTS - nextAvcDts) / 90);\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        if (contiguous) {\n            if (delta) {\n                if (delta > 1) {\n                    Log.v(`AVC:${delta} ms hole between fragments detected,filling it`);\n                } else if (delta < -1) {\n                    Log.v(`AVC:${-delta} ms overlapping between fragments detected`);\n                }\n\n                firstPTS = Math.max(firstPTS - (firstDTS - nextAvcDts), nextAvcDts);\n                // remove hole/gap : set DTS to next expected DTS\n                firstDTS = nextAvcDts;\n                inputSamples[0].dts = firstDTS;\n                // offset PTS as well, ensure that PTS is smaller or equal than new DTS\n                inputSamples[0].pts = firstPTS;\n                Log.v(\n                    `Video/PTS/DTS adjusted: ${Math.round(firstPTS / 90)}/${Math.round(\n                        firstDTS / 90\n                    )},delta:${delta} ms`\n                );\n            }\n        }\n\n        // compute lastPTS/lastDTS\n        sample = inputSamples[inputSamples.length - 1];\n        lastDTS = Math.max(sample.dts, 0);\n        lastPTS = Math.max(sample.pts, 0, lastDTS);\n\n        // on Safari let's signal the same sample duration for all samples\n        // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n        // set this constant duration as being the avg delta between consecutive DTS.\n        if (isSafari) {\n            mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));\n        }\n\n        let nbNalu = 0,\n            naluLen = 0;\n        for (let i = 0; i < nbSamples; i++) {\n            // compute total/avc sample length and nb of NAL units\n            const sample = inputSamples[i],\n                units = sample.units,\n                nbUnits = units.length;\n            let sampleLen = 0;\n            for (let j = 0; j < nbUnits; j++) {\n                sampleLen += units[j].data.length;\n            }\n\n            naluLen += sampleLen;\n            nbNalu += nbUnits;\n            sample.length = sampleLen;\n\n            // normalize PTS/DTS\n            if (isSafari) {\n                // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples\n                sample.dts = firstDTS + i * mp4SampleDuration;\n            } else {\n                // ensure sample monotonic DTS\n                sample.dts = Math.max(sample.dts, firstDTS);\n            }\n            // ensure that computed value is greater or equal than sample DTS\n            sample.pts = Math.max(sample.pts, sample.dts);\n        }\n\n        /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n        const mdatSize = naluLen + 4 * nbNalu + 8;\n        try {\n            mdat = new Uint8Array(mdatSize);\n        } catch (err) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ALLOC_ERROR,\n                fatal: false,\n                bytes: mdatSize,\n                reason: `fail allocating video mdat ${mdatSize}`\n            });\n            return null;\n        }\n        const view = new DataView(mdat.buffer);\n        view.setUint32(0, mdatSize);\n        mdat.set(MP4.types.mdat, 4);\n\n        for (let i = 0; i < nbSamples; i++) {\n            const avcSample = inputSamples[i],\n                avcSampleUnits = avcSample.units;\n            let mp4SampleLength = 0,\n                compositionTimeOffset;\n            // convert NALU bitstream to MP4 format (prepend NALU with size field)\n            for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {\n                const unit = avcSampleUnits[j],\n                    unitData = unit.data,\n                    unitDataLen = unit.data.byteLength;\n                view.setUint32(offset, unitDataLen);\n                offset += 4;\n                mdat.set(unitData, offset);\n                offset += unitDataLen;\n                mp4SampleLength += 4 + unitDataLen;\n            }\n\n            if (!isSafari) {\n                // expected sample duration is the Decoding Timestamp diff of consecutive samples\n                if (i < nbSamples - 1) {\n                    mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;\n                } else {\n                    const config = this._config;\n                    let lastFrameDuration = 0;\n                    if (this._stashLastVideoSample) {\n                        lastFrameDuration = this._stashLastVideoSample.dts - avcSample.dts;\n                    } else {\n                        lastFrameDuration =\n                            track.refSampleDuration ||\n                            time.sampleDuration ||\n                            avcSample.dts - inputSamples[i > 0 ? i - 1 : i].dts;\n                    }\n                    lastFrameDuration = Math.floor(lastFrameDuration / 90) * 90;\n                    if (config.stretchShortVideoTrack && this._nextAudioPts) {\n                        // In some cases, a segment's audio track duration may exceed the video track duration.\n                        // Since we've already remuxed audio, and we know how long the audio track is, we look to\n                        // see if the delta to the next segment is longer than maxBufferHole.\n                        // If so, playback would potentially get stuck, so we artificially inflate\n                        // the duration of the last frame to minimize any potential gap between segments.\n\n                        const maxBufferHole = config.maxBufferHole,\n                            gapTolerance = Math.floor(maxBufferHole * timeScale),\n                            deltaToFrameEnd =\n                                (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this._nextAudioPts) -\n                                avcSample.pts;\n                        if (deltaToFrameEnd > gapTolerance) {\n                            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                            if (mp4SampleDuration < 0) {\n                                mp4SampleDuration = lastFrameDuration;\n                            }\n\n                            Log.v(\n                                `It is approximately ${deltaToFrameEnd /\n                                90} ms to the next segment; using duration ${mp4SampleDuration /\n                                90} ms for the last video frame.`\n                            );\n                        } else {\n                            mp4SampleDuration = lastFrameDuration;\n                        }\n                    } else {\n                        mp4SampleDuration = lastFrameDuration;\n                    }\n                }\n                compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n            } else {\n                compositionTimeOffset = Math.max(\n                    0,\n                    mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration)\n                );\n            }\n\n            // 无法根据多个sample计算mp4SampleDuration时，利用fps和平均duration计算当前duration\n            if (mp4SampleDuration < 0 || isNaN(mp4SampleDuration)) {\n                let fix = 0;\n                if (contiguous && inputSamples.length < 2) {\n                    fix = delta * 90;\n                }\n                mp4SampleDuration = Math.max((track.refSampleDuration || time.sampleDuration) - fix, 90);\n            }\n            // console.log('mp4SampleDuration', mp4SampleDuration);\n            outputSamples.push({\n                size: mp4SampleLength,\n                // constant duration\n                duration: mp4SampleDuration,\n                cts: compositionTimeOffset,\n                flags: {\n                    isLeading: 0,\n                    isDependedOn: 0,\n                    hasRedundancy: 0,\n                    degradPrio: 0,\n                    dependsOn: avcSample.key ? 2 : 1,\n                    isNonSync: avcSample.key ? 0 : 1\n                }\n            });\n        }\n        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n\n        this._nextAvcDts = lastDTS + mp4SampleDuration;\n        const dropped = track.dropped;\n        track.dropped = 0;\n        if (outputSamples.length && this._forceFirstIDR) {\n            const flags = outputSamples[0].flags;\n            // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue\n            // https://code.google.com/p/chromium/issues/detail?id=229412\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n        }\n        track.samples = outputSamples;\n        moof = MP4.moof(track.sequenceNumber++, firstDTS, track);\n        track.samples = [];\n\n        const data: any = {\n            payload: this._mergeBoxes('video', moof, mdat),\n            startPTS: firstPTS / timeScale,\n            endPTS: (lastPTS + mp4SampleDuration) / timeScale,\n            startDTS: firstDTS / timeScale,\n            endDTS: this._nextAvcDts / timeScale,\n            type: 'video',\n            hasAudio: false,\n            hasVideo: true,\n            nb: outputSamples.length,\n            dropped: dropped,\n            streamDTS,\n            key,\n            extra: this._extra,\n        };\n        this._videoTime.vLastPTS = data.endPTS;\n        this._observer.trigger(LasEvents.PARSING_DATA, data);\n\n        // 记录数据计算平均duration\n        if (time.nbSamples === 0) {\n            time.firstDTS = firstDTS;\n        }\n        time.nbSamples += nbSamples;\n        time.sampleDuration = Math.round((this._nextAvcDts - time.firstDTS) / time.nbSamples);\n        time.endDts = this._nextAvcDts;\n\n        return data;\n    }\n\n    remuxAudio(track: ATrack, timeOffset: number, contiguous: boolean, accurateTimeOffset: boolean = false) {\n        if (!track.samples.length) {\n            return null;\n        }\n        const inputTimeScale = track.inputTimeScale,\n            mp4timeScale = track.timescale,\n            scaleFactor = inputTimeScale / mp4timeScale,\n            mp4SampleDuration = track.isAAC ? 1024 : 1152,\n            inputSampleDuration = mp4SampleDuration * scaleFactor,\n            ptsNormalize = this._PTSNormalize,\n            initPTS = this._initPTS,\n            rawMPEG = !track.isAAC && this._typeSupported.mpeg,\n            outputSamples = [],\n            streamDTS = track.samples[0].streamDTS / 1000;\n        let offset = rawMPEG ? 0 : 8,\n            mp4Sample,\n            fillFrame,\n            mdat,\n            moof,\n            firstPTS,\n            lastPTS,\n            inputSamples = track.samples,\n            nextAudioPts = this._nextAudioPts,\n            resetPts = false;\n        if (typeof initPTS === 'undefined') {\n            return;\n        }\n        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n        // for sake of clarity:\n        // consecutive fragments are frags with\n        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n        //  - less than 20 audio frames distance\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        // this helps ensuring audio continuity and this also avoids audio glitches/cut when switching quality,\n        // or reporting wrong duration on first audio frame\n        contiguous =\n            contiguous ||\n            !!(\n                inputSamples.length &&\n                nextAudioPts &&\n                ((accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1) ||\n                    Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration)\n            );\n\n        // compute normalized PTS\n        inputSamples.forEach(function (sample) {\n            sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);\n        });\n\n        // filter out sample with negative PTS that are not playable anyway\n        // if we don't remove these negative samples, they will shift all audio samples forward.\n        // leading to audio overlap between current / next fragment\n        inputSamples = inputSamples.filter(function (sample) {\n            return sample.pts >= 0;\n        });\n\n        // in case all samples have negative PTS, and have been filtered out, return now\n        if (inputSamples.length === 0) {\n            return null;\n        }\n        if (!contiguous || typeof nextAudioPts === 'undefined') {\n            if (!accurateTimeOffset) {\n                // if frag are mot contiguous and if we cant trust time offset,\n                // let's use first sample PTS as next audio PTS\n                nextAudioPts = inputSamples[0].pts;\n            } else {\n                // if timeOffset is accurate, let's use it as predicted next audio PTS\n                nextAudioPts = timeOffset * inputTimeScale;\n            }\n            resetPts = true;\n        }\n        // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n        // In an effort to prevent this from happening, we inject frames here where there are gaps.\n        // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n        // frame.\n        if (typeof nextAudioPts === 'undefined') {\n            return;\n        }\n        if (track.isAAC) {\n            const maxAudioFramesDrift = this._config.maxAudioFramesDrift;\n            for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {\n                // First, let's see how far off this frame is from where we expect it to be\n                const sample = inputSamples[i],\n                    pts = sample.pts,\n                    delta = pts - nextPts;\n\n                const duration = Math.abs((1000 * delta) / inputTimeScale);\n\n                // If we're overlapping by more than a duration, drop this sample\n                if (delta <= -maxAudioFramesDrift * inputSampleDuration) {\n                    Log.w(\n                        `Dropping 1 audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(\n                            duration\n                        )} ms overlap.`\n                    );\n                    inputSamples.splice(i, 1);\n                    // Don't touch nextPtsNorm or i\n                } // eslint-disable-line brace-style\n\n                // Insert missing frames if:\n                // 1: We're more than maxAudioFramesDrift frame away\n                // 2: Not more than MAX_SILENT_FRAME_DURATION away\n                // 3: currentTime (aka nextPtsNorm) is not 0\n                else if (\n                    delta >= maxAudioFramesDrift * inputSampleDuration &&\n                    duration < MAX_SILENT_FRAME_DURATION &&\n                    nextPts\n                ) {\n                    const missing = Math.round(delta / inputSampleDuration);\n                    Log.w(\n                        `Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(\n                            3\n                        )}s due to ${Math.round((1000 * delta) / inputTimeScale)} ms gap.`\n                    );\n                    for (let j = 0; j < missing; j++) {\n                        const newStamp = Math.max(nextPts, 0);\n                        fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                        if (!fillFrame) {\n                            Log.v('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                            fillFrame = sample.unit.subarray();\n                        }\n                        inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });\n                        nextPts += inputSampleDuration;\n                        i++;\n                    }\n\n                    // Adjust sample to next expected pts\n                    sample.pts = sample.dts = nextPts;\n                    nextPts += inputSampleDuration;\n                    i++;\n                } else {\n                    // Otherwise, just adjust pts\n                    if (Math.abs(delta) > 0.1 * inputSampleDuration) {\n                        // Log.v(\n                        //     `Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(\n                        //         pts / 90\n                        //     )} (should be ${Math.round(inputSampleDuration)}).`\n                        // );\n                    }\n                    sample.pts = sample.dts = nextPts;\n                    nextPts += inputSampleDuration;\n                    i++;\n                }\n            }\n        }\n\n        // compute mdat size, as we eventually filtered/added some samples\n        let nbSamples = inputSamples.length;\n        let mdatSize = 0;\n        while (nbSamples--) {\n            mdatSize += inputSamples[nbSamples].unit.byteLength;\n        }\n\n        for (let j = 0, nbSamples = inputSamples.length; j < nbSamples; j++) {\n            const audioSample = inputSamples[j];\n            const unit = audioSample.unit;\n            let pts = audioSample.pts;\n            // console.log('audioSample.pts', audioSample);\n            // Log.v(`Audio/PTS:${Math.round(pts/90)}`);\n            // if not first sample\n            if (typeof lastPTS !== 'undefined' && mp4Sample) {\n                mp4Sample.duration = Math.round((pts - lastPTS) / scaleFactor);\n            } else {\n                const delta = Math.round((1000 * (pts - nextAudioPts)) / inputTimeScale);\n                let numMissingFrames = 0;\n                // if fragment are contiguous, detect hole/overlapping between fragments\n                // contiguous fragments are consecutive fragments from same quality level\n                // (same level, new SN = old SN + 1)\n                if (contiguous && track.isAAC) {\n                    // log delta\n                    if (delta) {\n                        if (delta > 0 && delta < MAX_SILENT_FRAME_DURATION) {\n                            numMissingFrames = Math.round((pts - nextAudioPts) / inputSampleDuration);\n                            Log.v(`${delta} ms hole between AAC samples detected,filling it`);\n                            if (numMissingFrames > 0) {\n                                fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                                if (!fillFrame) {\n                                    fillFrame = unit.subarray();\n                                }\n\n                                mdatSize += numMissingFrames * fillFrame.length;\n                            }\n                            // if we have frame overlap, overlapping for more than half a frame duraion\n                        } else if (delta < -12) {\n                            // drop overlapping audio frames... browser will deal with it\n                            Log.v(\n                                `drop overlapping AAC sample, expected/parsed/delta:${(\n                                    nextAudioPts / inputTimeScale\n                                ).toFixed(3)}s/${(pts / inputTimeScale).toFixed(3)}s/${-delta}ms`\n                            );\n                            mdatSize -= unit.byteLength;\n                            continue;\n                        }\n                        // set PTS/DTS to expected PTS/DTS\n                        pts = nextAudioPts;\n                    }\n                }\n                // remember first PTS of our audioSamples\n                firstPTS = pts;\n                if (mdatSize > 0) {\n                    mdatSize += offset;\n                    try {\n                        mdat = new Uint8Array(mdatSize);\n                    } catch (err) {\n                        this._observer.trigger(LasEvents.ERROR, {\n                            type: ErrorTypes.MUX_ERROR,\n                            details: ErrorDetails.REMUX_ALLOC_ERROR,\n                            fatal: false,\n                            bytes: mdatSize,\n                            reason: `fail allocating audio mdat ${mdatSize}`\n                        });\n                        return null;\n                    }\n                    if (!rawMPEG) {\n                        const view = new DataView(mdat.buffer);\n                        view.setUint32(0, mdatSize);\n                        mdat.set(MP4.types.mdat, 4);\n                    }\n                } else {\n                    track.samples = [];\n                    // no audio samples\n                    return null;\n                }\n                for (let i = 0; i < numMissingFrames; i++) {\n                    fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                    if (!fillFrame) {\n                        Log.v('Unable to get silent frame for given audio codec; duplicating this frame instead.');\n                        fillFrame = unit.subarray();\n                    }\n                    mdat.set(fillFrame, offset);\n                    offset += fillFrame.byteLength;\n                    mp4Sample = {\n                        size: fillFrame.byteLength,\n                        cts: 0,\n                        duration: 1024,\n                        flags: {\n                            isLeading: 0,\n                            isDependedOn: 0,\n                            hasRedundancy: 0,\n                            degradPrio: 0,\n                            dependsOn: 1\n                        }\n                    };\n                    outputSamples.push(mp4Sample);\n                }\n            }\n            if (!mdat) {\n                return;\n            }\n            mdat.set(unit, offset);\n            const unitLen = unit.byteLength;\n            offset += unitLen;\n            // PTS/DTS/initDTS/normPTS/normDTS/relative PTS\n            mp4Sample = {\n                size: unitLen,\n                cts: 0,\n                duration: 0,\n                flags: {\n                    isLeading: 0,\n                    isDependedOn: 0,\n                    hasRedundancy: 0,\n                    degradPrio: 0,\n                    dependsOn: 1\n                }\n            };\n            outputSamples.push(mp4Sample);\n            lastPTS = pts;\n        }\n        let lastSampleDuration = 0;\n        nbSamples = outputSamples.length;\n        if (!mp4Sample) {\n            return;\n        }\n        // set last sample duration as being identical to previous sample\n        if (nbSamples >= 2) {\n            lastSampleDuration = outputSamples[nbSamples - 2].duration;\n            mp4Sample.duration = lastSampleDuration;\n        }\n        if (nbSamples && typeof lastPTS === 'number' && mdat) {\n            if (mp4Sample && mp4Sample.duration === 0) {\n                mp4Sample.duration = track.isAAC ? 1024 : 1152;\n            }\n            // next audio sample PTS should be equal to last sample PTS + duration\n            this._nextAudioPts = nextAudioPts = lastPTS + scaleFactor * (lastSampleDuration || mp4SampleDuration);\n            // Log.v('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));\n            track.samples = outputSamples;\n            if (rawMPEG) {\n                moof = new Uint8Array();\n            } else {\n                moof = MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);\n            }\n\n            track.samples = [];\n            const start = firstPTS / inputTimeScale;\n            const end = nextAudioPts / inputTimeScale;\n            const audioData = {\n                payload: this._mergeBoxes('audio', moof, mdat),\n                startPTS: start,\n                endPTS: end,\n                startDTS: start,\n                endDTS: end,\n                type: 'audio',\n                hasAudio: true,\n                hasVideo: false,\n                nb: nbSamples,\n                streamDTS,\n                extra: this._extra,\n            };\n            this._videoTime.aLastPTS = audioData.endPTS;\n            this._observer.trigger(LasEvents.PARSING_DATA, audioData);\n            return audioData;\n        }\n        if (resetPts) {\n            delete this._nextAudioPts;\n        }\n        track.samples = [];\n        return null;\n    }\n\n    remuxEmptyAudio(track: ATrack, timeOffset: number, contiguous: boolean, videoData: any) {\n        if (typeof this._initDTS === 'undefined') {\n            return;\n        }\n        const inputTimeScale = track.inputTimeScale,\n            mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,\n            scaleFactor = inputTimeScale / mp4timeScale,\n            nextAudioPts = this._nextAudioPts,\n            // sync with video's timestamp\n            startDTS =\n                (typeof nextAudioPts !== 'undefined' ? nextAudioPts : videoData.startDTS * inputTimeScale) +\n                this._initDTS,\n            endDTS = videoData.endDTS * inputTimeScale + this._initDTS,\n            // one sample's duration value\n            sampleDuration = 1024,\n            frameDuration = scaleFactor * sampleDuration,\n            // samples count of this segment's duration\n            nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),\n            // silent frame\n            silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n        Log.w('remux empty Audio');\n        // Can't remux if we can't generate a silent frame...\n        if (!silentFrame) {\n            Log.d('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');\n            return;\n        }\n\n        const samples = [];\n        for (let i = 0; i < nbSamples; i++) {\n            const stamp = startDTS + i * frameDuration;\n            samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n        }\n        track.samples = samples;\n\n        this.remuxAudio(track, timeOffset, contiguous);\n    }\n\n    _PTSNormalize(value: number, reference?: number) {\n        let offset;\n        if (typeof reference === 'undefined') {\n            return value;\n        }\n\n        if (reference < value) {\n            // - 2^33\n            offset = -8589934592;\n        } else {\n            // + 2^33\n            offset = 8589934592;\n        }\n        /* PTS is 33bit (from 0 to 2^33 -1)\n      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n      PTS looping occured. fill the gap */\n        while (Math.abs(value - reference) > 4294967296) {\n            value += offset;\n        }\n\n        return value;\n    }\n\n    _resetVideoTime() {\n        this._videoTime = { nbSamples: 0, firstDTS: 0, sampleDuration: 3000, vLastPTS: 0, aLastPTS: 0 };\n    }\n\n    private _mergeBoxes(type: string, ...arr: Uint8Array[]): Uint8Array {\n        if (this._initSegment[type]) {\n            arr.unshift(this._initSegment[type]);\n            delete this._initSegment[type];\n        }\n        const len = arr.reduce((prev, cur) => {\n            if (cur) {\n                return prev + cur.byteLength;\n            }\n            return prev;\n        }, 0);\n        const result = new Uint8Array(len);\n        let index = 0;\n        arr.forEach(cur => {\n            if (cur) {\n                result.set(cur, index);\n                index += cur.byteLength;\n            }\n        });\n        return result;\n    }\n}\n\nexport default MP4Remuxer;\n","import Observer from '../core/observer';\nimport { ATrack } from '../types/remux';\nimport { ASCInfo, getAudioConfig } from './get-audio-config';\n\nexport function parseData(data: Uint8Array, offset: number): ASCInfo {\n    return {\n        objectType: data[offset + 2] >>> 3, // 5 bits\n        sampleingIndex: (data[offset + 2] & 0x07) << 1 | data[offset + 3] >>> 7, // 4 bits\n        chanelConfig: (data[offset + 3] & 0x78) >>> 3 // 4 bits\n    };\n}\n\nexport function initTrackConfig(track: ATrack, observer: Observer, data: Uint8Array, offset: number, audioCodec: string = '') {\n    if (!track.samplerate) {\n        const config = getAudioConfig(observer, parseData(data, offset), audioCodec);\n        if (config) {\n            track.config = config.config;\n            track.timescale = track.samplerate = config.samplerate;\n            track.channelCount = config.channelCount;\n            track.codec = config.codec;\n            track.manifestCodec = config.manifestCodec;\n            track.isAAC = true;\n        }\n    }\n}\n\nexport function getFrameDuration(samplerate: number): number {\n    return 1024 * 1000 / samplerate;\n}\n","import LasEvents from '../core/events';\nimport Observer from '../core/observer';\nimport { ErrorTypes, ErrorDetails } from '../core/errors';\nimport { Log } from '../utils/log';\n\nexport interface ASCInfo {\n    objectType: number;\n    sampleingIndex: number;\n    chanelConfig: number;\n}\n\nexport interface ASCConfig {\n    config: number[];\n    samplerate: number;\n    channelCount: number;\n    codec: string;\n    manifestCodec: string;\n}\n\nexport function getAudioConfig(observer: Observer, info: ASCInfo, audioCodec: string = ''): ASCConfig | null {\n    let extensionSampleingIndex: number, // :int\n        config: Array<number>,\n        objectType = info.objectType,\n        sampleingIndex = info.sampleingIndex,\n        chanelConfig = info.chanelConfig;\n    const userAgent = navigator.userAgent.toLowerCase(),\n        manifestCodec = audioCodec,\n        sampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n    if (sampleingIndex < 0 || sampleingIndex >= sampleingRates.length) {\n        observer.trigger(LasEvents.ERROR, {\n            type: ErrorTypes.MUX_ERROR,\n            details: ErrorDetails.PARSING_ERROR,\n            fatal: true,\n            reason: `invalid sampling index:${sampleingIndex}`\n        });\n        return null;\n    }\n    if (chanelConfig < 0 || chanelConfig >= 8) {\n        observer.trigger(LasEvents.ERROR, {\n            type: ErrorTypes.MUX_ERROR,\n            details: ErrorDetails.PARSING_ERROR,\n            fatal: true,\n            reason: `invalid chanelConfig:${chanelConfig}`\n        });\n        return null;\n    }\n\n    Log.v(\n        `manifest codec:${audioCodec},data:type:${objectType},sampleingIndex:${sampleingIndex}[${\n            sampleingRates[sampleingIndex]\n        }Hz],channelConfig:${chanelConfig}`\n    );\n    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n    if ((/firefox/i).test(userAgent)) {\n        if (sampleingIndex >= 6) {\n            objectType = 5;\n            config = new Array(4);\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            extensionSampleingIndex = sampleingIndex - 3;\n        } else {\n            objectType = 2;\n            config = new Array(2);\n            extensionSampleingIndex = sampleingIndex;\n        }\n        // Android : always use AAC\n    } else if (userAgent.indexOf('android') !== -1) {\n        objectType = 2;\n        config = new Array(2);\n        extensionSampleingIndex = sampleingIndex;\n    } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not\n        support audio codec switch properly (like Chrome ...)\n    */\n        objectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (\n            audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1)\n            || !audioCodec && sampleingIndex >= 6\n        ) {\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            extensionSampleingIndex = sampleingIndex - 3;\n        } else {\n            /* if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1)\n                OR(manifest codec not specified and mono audio)\n                Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.\n                This is not a problem with stereo.\n            */\n            if (\n                audioCodec\n                    && audioCodec.indexOf('mp4a.40.2') !== -1\n                    && (sampleingIndex >= 6 && chanelConfig === 1 || (/vivaldi/i).test(userAgent))\n                || !audioCodec && chanelConfig === 1\n            ) {\n                objectType = 2;\n                config = new Array(2);\n            }\n            extensionSampleingIndex = sampleingIndex;\n        }\n    }\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    config[0] = objectType << 3;\n    // samplingFrequencyIndex\n    config[0] |= (sampleingIndex & 0x0e) >> 1;\n    config[1] |= (sampleingIndex & 0x01) << 7;\n    // channelConfiguration\n    config[1] |= chanelConfig << 3;\n    if (objectType === 5) {\n        // extensionSampleingIndex\n        config[1] |= (extensionSampleingIndex & 0x0e) >> 1;\n        config[2] = (extensionSampleingIndex & 0x01) << 7;\n        // objectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n    }\n    return {\n        config: config,\n        samplerate: sampleingRates[sampleingIndex],\n        channelCount: chanelConfig,\n        codec: 'mp4a.40.' + objectType,\n        manifestCodec: manifestCodec\n    };\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\n// Exponential-Golomb buffer decoder\nclass ExpGolomb {\n    private _buffer: Uint8Array | null;\n    private _buffer_index: number;\n    private _total_bytes: number;\n    private _total_bits: number;\n    private _current_word: number;\n    private _current_word_bits_left: number;\n\n    constructor(uint8array: Uint8Array) {\n        this._buffer = uint8array;\n        this._buffer_index = 0;\n        this._total_bytes = uint8array.byteLength;\n        this._total_bits = uint8array.byteLength * 8;\n        this._current_word = 0;\n        this._current_word_bits_left = 0;\n    }\n\n    destroy() {\n        this._buffer = null;\n    }\n\n    _fillCurrentWord() {\n        let buffer_bytes_left = this._total_bytes - this._buffer_index;\n        if (buffer_bytes_left <= 0 || !this._buffer) {\n            throw new Error('ExpGolomb: _fillCurrentWord() but no bytes available');\n        }\n\n        let bytes_read = Math.min(4, buffer_bytes_left);\n        let word = new Uint8Array(4);\n        word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\n        this._current_word = new DataView(word.buffer).getUint32(0, false);\n\n        this._buffer_index += bytes_read;\n        this._current_word_bits_left = bytes_read * 8;\n    }\n\n    readBits(bits: number) {\n        if (bits > 32) {\n            throw new Error('ExpGolomb: readBits() bits exceeded max 32bits!');\n        }\n\n        if (bits <= this._current_word_bits_left) {\n            let result = this._current_word >>> (32 - bits);\n            this._current_word <<= bits;\n            this._current_word_bits_left -= bits;\n            return result;\n        }\n\n        let result = this._current_word_bits_left ? this._current_word : 0;\n        result = result >>> (32 - this._current_word_bits_left);\n        let bits_need_left = bits - this._current_word_bits_left;\n\n        this._fillCurrentWord();\n        let bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\n\n        let result2 = this._current_word >>> (32 - bits_read_next);\n        this._current_word <<= bits_read_next;\n        this._current_word_bits_left -= bits_read_next;\n\n        result = (result << bits_read_next) | result2;\n        return result;\n    }\n\n    readBool() {\n        return this.readBits(1) === 1;\n    }\n\n    // ():int\n    readUByte() {\n        return this.readBits(8);\n    }\n\n    readUShort() {\n        return this.readBits(16);\n    }\n\n    readUInt() {\n        return this.readBits(32);\n    }\n\n    readByte() {\n        return this.readBits(8);\n    }\n\n    _skipLeadingZero(): number {\n        let zero_count;\n        for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\n            if ((this._current_word & (0x80000000 >>> zero_count)) !== 0) {\n                this._current_word <<= zero_count;\n                this._current_word_bits_left -= zero_count;\n                return zero_count;\n            }\n        }\n        this._fillCurrentWord();\n        return zero_count + this._skipLeadingZero();\n    }\n\n    readUEG() {\n        // unsigned exponential golomb\n        let leading_zeros = this._skipLeadingZero();\n        return this.readBits(leading_zeros + 1) - 1;\n    }\n\n    readSEG() {\n        // signed exponential golomb\n        let value = this.readUEG();\n        if (value & 0x01) {\n            return (value + 1) >>> 1;\n        } else {\n            return -1 * (value >>> 1);\n        }\n    }\n\n    readSliceType() {\n        // skip NALu type\n        this.readUByte();\n        // discard first_mb_in_slice\n        this.readUEG();\n        // return slice_type\n        return this.readUEG();\n    }\n\n    getBitsLeft() {\n        return (this._total_bytes - this._buffer_index) * 8 + this._current_word_bits_left;\n    }\n\n    get bytesAvailable() {\n        return this._total_bytes - this._buffer_index;\n    }\n}\n\nexport default ExpGolomb;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nimport ExpGolomb from './exp-golomb';\n\nconst HEVC_MAX_SPS_COUNT = 16;\nconst HEVC_MAIN: Record<number, string> = { 1: 'Main', 2: 'Main 10', 3: 'Main Still Picture', 4: 'Rext' };\nconst HEVC_LEVELS: Record<number, number> = {\n    30: 1,\n    60: 2,\n    63: 2.1,\n    90: 3,\n    93: 3.1,\n    120: 4,\n    123: 4.1,\n    150: 5,\n    153: 5.1,\n    156: 5.2,\n    180: 6,\n    183: 6.1,\n    186: 6.2,\n    255: 8.5\n};\n\ntype SPSInfo = {\n    profile_string: string; // baseline, high, high10, ...\n    level_string: string; // 3, 3.1, 4, 4.1, 5, 5.1, ...\n    bit_depth: number; // 8bit, 10bit, ...\n    chroma_format: number; // 4:2:0, 4:2:2, ...\n    chroma_format_string: string;\n    frame_rate: {\n        fixed: boolean;\n        fps: number;\n        fps_den: number;\n        fps_num: number;\n    };\n    sar_ratio: {\n        width: number;\n        height: number;\n    };\n    codec_size: {\n        width: number;\n        height: number;\n    };\n    present_size: {\n        width: number;\n        height: number;\n    };\n};\n\ntype HEVCSPSInfo = {\n    chroma_format_string: string;\n    profile_string: string;\n    level_string: string;\n    width: number;\n    height: number;\n};\n\nclass SPSParser {\n    static _ebsp2rbsp(uint8array: Uint8Array) {\n        const src = uint8array;\n        const src_length = src.byteLength;\n        const dst = new Uint8Array(src_length);\n        let dst_idx = 0;\n\n        for (let i = 0; i < src_length; i++) {\n            if (i >= 2) {\n                // Unescape: Skip 0x03 after 00 00\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                    continue;\n                }\n            }\n            dst[dst_idx] = src[i];\n            dst_idx++;\n        }\n\n        return new Uint8Array(dst.buffer, 0, dst_idx);\n    }\n\n    static parseHEVCSPS(uint8array: Uint8Array): HEVCSPSInfo | null {\n        const rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb: ExpGolomb | null = new ExpGolomb(rbsp);\n        const ptl: any = { general_ptl: {}, sub_layer_ptl: {} };\n        gb.readBits(16);\n        gb.readBits(4); // sps_video_parameter_set_id\n        let max_sub_layers = gb.readBits(3) + 1; // sps_max_sub_layers_minus1\n        gb.readBits(1); // temporalIdNested\n\n        if (!SPSParser._parsePTL(gb, ptl, max_sub_layers)) {\n            return null;\n        }\n\n        const sps_id = gb.readUEG();\n        if (sps_id >= HEVC_MAX_SPS_COUNT) {\n            return null;\n        }\n        let chroma_format_idc = gb.readUEG();\n\n        if (chroma_format_idc == 3) {\n            const separate_colour_plane_flag = gb.readBits(1);\n            if (separate_colour_plane_flag) {\n                chroma_format_idc = 0;\n            }\n        }\n\n        const width = gb.readUEG();\n        const height = gb.readUEG();\n        gb.destroy();\n        gb = null;\n        // let conformance_window_flag = gb.readBits(1);\n        return {\n            chroma_format_string: chroma_format_idc === 3 ? '4:4:4' : '4:2:0',\n            profile_string: ptl.general_ptl.profile_string,\n            level_string: ptl.general_ptl.level_string,\n            width: width,\n            height: height\n        };\n        // hvcc_parse_ptl end\n    }\n\n    static _parsePTL(gb: ExpGolomb, ptl: any, max_num_sub_layers: number) {\n        if (\n            !this._decodeProfileTierLevel(gb, ptl.general_ptl) ||\n            gb.getBitsLeft() < 8 + 8 * 2 * (max_num_sub_layers - 1 > 0 ? 1 : 0)\n        ) {\n            return false;\n        }\n\n        ptl.general_ptl.level_idc = gb.readBits(8);\n        ptl.general_ptl.level_string = this.getHEVCLevelString(ptl.general_ptl.level_idc);\n        ptl.sub_layer_profile_present_flag = [];\n        ptl.sub_layer_level_present_flag = [];\n        for (let i = 0; i < max_num_sub_layers - 1; i++) {\n            ptl.sub_layer_profile_present_flag[i] = gb.readBits(1);\n            ptl.sub_layer_level_present_flag[i] = gb.readBits(1);\n        }\n\n        if (max_num_sub_layers - 1 > 0) {\n            for (let i = max_num_sub_layers - 1; i < 8; i++) {\n                gb.readBits(2); // reserved_zero_2bits[i]\n            }\n        }\n        for (let i = 0; i < max_num_sub_layers - 1; i++) {\n            if (ptl.sub_layer_profile_present_flag[i] && this._decodeProfileTierLevel(gb, ptl.sub_layer_ptl)) {\n                return false;\n            }\n            if (ptl.sub_layer_level_present_flag[i]) {\n                if (gb.getBitsLeft() < 8) {\n                    return false;\n                } else ptl.sub_layer_ptl[i].level_idc = gb.readBits(8);\n            }\n        }\n        return true;\n    }\n\n    static _decodeProfileTierLevel(gb: ExpGolomb, ptl: any) {\n        if (gb.getBitsLeft() < 2 + 1 + 5 + 32 + 4 + 16 + 16 + 12) {\n            return false;\n        }\n\n        ptl.profile_space = gb.readBits(2);\n        ptl.tier_flag = gb.readBits(1);\n        ptl.profile_idc = gb.readBits(5);\n        ptl.profile_compatibility_flag = [];\n\n        for (let i = 0; i < 32; i++) {\n            ptl.profile_compatibility_flag[i] = gb.readBits(1);\n            if (ptl.profile_idc == 0 && i > 0 && ptl.profile_compatibility_flag[i]) ptl.profile_idc = i;\n        }\n        ptl.progressive_source_flag = gb.readBits(1);\n        ptl.interlaced_source_flag = gb.readBits(1);\n        ptl.non_packed_constraint_flag = gb.readBits(1);\n        ptl.frame_only_constraint_flag = gb.readBits(1);\n\n        gb.readBits(16);\n        gb.readBits(16);\n        gb.readBits(12);\n        ptl.profile_string = this.getHEVCProfileString(ptl.profile_idc);\n        return true;\n    }\n\n    static parseSPS(uint8array: Uint8Array): SPSInfo {\n        const rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb: ExpGolomb | null = new ExpGolomb(rbsp);\n\n        gb.readByte();\n        const profile_idc = gb.readByte(); // profile_idc\n        gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n        const level_idc = gb.readByte(); // level_idc\n        gb.readUEG(); // seq_parameter_set_id\n\n        const profile_string = SPSParser.getProfileString(profile_idc);\n        const level_string = SPSParser.getLevelString(level_idc);\n        let chroma_format_idc = 1;\n        let chroma_format = 420;\n        const chroma_format_table = [0, 420, 422, 444];\n        let bit_depth = 8;\n\n        if (\n            profile_idc === 100 ||\n            profile_idc === 110 ||\n            profile_idc === 122 ||\n            profile_idc === 244 ||\n            profile_idc === 44 ||\n            profile_idc === 83 ||\n            profile_idc === 86 ||\n            profile_idc === 118 ||\n            profile_idc === 128 ||\n            profile_idc === 138 ||\n            profile_idc === 144\n        ) {\n            chroma_format_idc = gb.readUEG();\n            if (chroma_format_idc === 3) {\n                gb.readBits(1); // separate_colour_plane_flag\n            }\n            if (chroma_format_idc <= 3) {\n                chroma_format = chroma_format_table[chroma_format_idc];\n            }\n\n            bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n            gb.readUEG(); // bit_depth_chroma_minus8\n            gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n            if (gb.readBool()) {\n                // seq_scaling_matrix_present_flag\n                const scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n                for (let i = 0; i < scaling_list_count; i++) {\n                    if (gb.readBool()) {\n                        // seq_scaling_list_present_flag\n                        if (i < 6) {\n                            SPSParser._skipScalingList(gb, 16);\n                        } else {\n                            SPSParser._skipScalingList(gb, 64);\n                        }\n                    }\n                }\n            }\n        }\n        gb.readUEG(); // log2_max_frame_num_minus4\n        const pic_order_cnt_type = gb.readUEG();\n        if (pic_order_cnt_type === 0) {\n            gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n        } else if (pic_order_cnt_type === 1) {\n            gb.readBits(1); // delta_pic_order_always_zero_flag\n            gb.readSEG(); // offset_for_non_ref_pic\n            gb.readSEG(); // offset_for_top_to_bottom_field\n            const num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n                gb.readSEG(); // offset_for_ref_frame\n            }\n        }\n        gb.readUEG(); // max_num_ref_frames\n        gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        const pic_width_in_mbs_minus1 = gb.readUEG();\n        const pic_height_in_map_units_minus1 = gb.readUEG();\n\n        const frame_mbs_only_flag = gb.readBits(1);\n        if (frame_mbs_only_flag === 0) {\n            gb.readBits(1); // mb_adaptive_frame_field_flag\n        }\n        gb.readBits(1); // direct_8x8_inference_flag\n\n        let frame_crop_left_offset = 0;\n        let frame_crop_right_offset = 0;\n        let frame_crop_top_offset = 0;\n        let frame_crop_bottom_offset = 0;\n\n        const frame_cropping_flag = gb.readBool();\n        if (frame_cropping_flag) {\n            frame_crop_left_offset = gb.readUEG();\n            frame_crop_right_offset = gb.readUEG();\n            frame_crop_top_offset = gb.readUEG();\n            frame_crop_bottom_offset = gb.readUEG();\n        }\n\n        let sar_width = 1,\n            sar_height = 1;\n        let fps = 0,\n            fps_fixed = true,\n            fps_num = 0,\n            fps_den = 0;\n\n        const vui_parameters_present_flag = gb.readBool();\n        if (vui_parameters_present_flag) {\n            if (gb.readBool()) {\n                // aspect_ratio_info_present_flag\n                const aspect_ratio_idc = gb.readByte();\n                const sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                const sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\n                } else if (aspect_ratio_idc === 255) {\n                    sar_width = (gb.readByte() << 8) | gb.readByte();\n                    sar_height = (gb.readByte() << 8) | gb.readByte();\n                }\n            }\n\n            if (gb.readBool()) {\n                // overscan_info_present_flag\n                gb.readBool(); // overscan_appropriate_flag\n            }\n            if (gb.readBool()) {\n                // video_signal_type_present_flag\n                gb.readBits(4); // video_format & video_full_range_flag\n                if (gb.readBool()) {\n                    // colour_description_present_flag\n                    gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n                }\n            }\n            if (gb.readBool()) {\n                // chroma_loc_info_present_flag\n                gb.readUEG(); // chroma_sample_loc_type_top_field\n                gb.readUEG(); // chroma_sample_loc_type_bottom_field\n            }\n            if (gb.readBool()) {\n                // timing_info_present_flag\n                const num_units_in_tick = gb.readBits(32);\n                const time_scale = gb.readBits(32);\n                fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n                fps_num = time_scale;\n                fps_den = num_units_in_tick * 2;\n                fps = fps_num / fps_den;\n            }\n        }\n\n        let sarScale = 1;\n        if (sar_width !== 1 || sar_height !== 1) {\n            sarScale = sar_width / sar_height;\n        }\n\n        let crop_unit_x = 0,\n            crop_unit_y = 0;\n        if (chroma_format_idc === 0) {\n            crop_unit_x = 1;\n            crop_unit_y = 2 - frame_mbs_only_flag;\n        } else {\n            const sub_wc = chroma_format_idc === 3 ? 1 : 2;\n            const sub_hc = chroma_format_idc === 1 ? 2 : 1;\n            crop_unit_x = sub_wc;\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n        }\n\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n        const present_width = Math.ceil(codec_width * sarScale);\n\n        gb.destroy();\n        gb = null;\n\n        return {\n            profile_string, // baseline, high, high10, ...\n            level_string, // 3, 3.1, 4, 4.1, 5, 5.1, ...\n            bit_depth, // 8bit, 10bit, ...\n            chroma_format, // 4:2:0, 4:2:2, ...\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n            frame_rate: {\n                fixed: fps_fixed,\n                fps,\n                fps_den,\n                fps_num\n            },\n\n            sar_ratio: {\n                width: sar_width,\n                height: sar_height\n            },\n\n            codec_size: {\n                width: codec_width,\n                height: codec_height\n            },\n\n            present_size: {\n                width: present_width,\n                height: codec_height\n            }\n        };\n    }\n\n    static _skipScalingList(gb: ExpGolomb, count: number) {\n        let last_scale = 8,\n            next_scale = 8;\n        let delta_scale = 0;\n        for (let i = 0; i < count; i++) {\n            if (next_scale !== 0) {\n                delta_scale = gb.readSEG();\n                next_scale = (last_scale + delta_scale + 256) % 256;\n            }\n            last_scale = next_scale === 0 ? last_scale : next_scale;\n        }\n    }\n\n    static getProfileString(profile_idc: number) {\n        switch (profile_idc) {\n            case 66:\n                return 'Baseline';\n            case 77:\n                return 'Main';\n            case 88:\n                return 'Extended';\n            case 100:\n                return 'High';\n            case 110:\n                return 'High10';\n            case 122:\n                return 'High422';\n            case 244:\n                return 'High444';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getLevelString(level_idc: number) {\n        return (level_idc / 10).toFixed(1);\n    }\n\n    static getChromaFormatString(chroma: number) {\n        switch (chroma) {\n            case 420:\n                return '4:2:0';\n            case 422:\n                return '4:2:2';\n            case 444:\n                return '4:4:4';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getHEVCProfileString(profile_idc: number) {\n        return HEVC_MAIN[profile_idc];\n    }\n\n    static getHEVCLevelString(level_idc: number) {\n        return HEVC_LEVELS[level_idc];\n    }\n}\n\nexport default SPSParser;\n","/* eslint-disable */\nfunction decodeUTF8(uint8array: Uint8Array) {\n    const out = [];\n    const input = uint8array;\n    let i = 0;\n    const length = uint8array.length;\n\n    while (i < length) {\n        if (input[i] < 0x80) {\n            out.push(String.fromCharCode(input[i]));\n            ++i;\n            continue;\n        } else if (input[i] < 0xc0) {\n            // fallthrough\n        } else if (input[i] < 0xe0) {\n            if (checkContinuation(input, i, 1)) {\n                const ucs4 = ((input[i] & 0x1f) << 6) | (input[i + 1] & 0x3f);\n                if (ucs4 >= 0x80) {\n                    out.push(String.fromCharCode(ucs4 & 0xffff));\n                    i += 2;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xf0) {\n            if (checkContinuation(input, i, 2)) {\n                const ucs4 = ((input[i] & 0xf) << 12) | ((input[i + 1] & 0x3f) << 6) | (input[i + 2] & 0x3f);\n                if (ucs4 >= 0x800 && (ucs4 & 0xf800) !== 0xd800) {\n                    out.push(String.fromCharCode(ucs4 & 0xffff));\n                    i += 3;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xf8) {\n            if (checkContinuation(input, i, 3)) {\n                let ucs4 =\n                    ((input[i] & 0x7) << 18) |\n                    ((input[i + 1] & 0x3f) << 12) |\n                    ((input[i + 2] & 0x3f) << 6) |\n                    (input[i + 3] & 0x3f);\n                if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n                    ucs4 -= 0x10000;\n                    out.push(String.fromCharCode((ucs4 >>> 10) | 0xd800));\n                    out.push(String.fromCharCode((ucs4 & 0x3ff) | 0xdc00));\n                    i += 4;\n                    continue;\n                }\n            }\n        }\n        out.push(String.fromCharCode(0xfffd));\n        ++i;\n    }\n\n    return out.join('');\n}\n\nfunction checkContinuation(uint8array: Uint8Array, start: number, checkLength: number) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n        while (checkLength--) {\n            if ((array[++start] & 0xc0) !== 0x80) return false;\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\nexport default decodeUTF8;\n","/* eslint-disable */\nimport decodeUTF8 from '../../utils/decodeUTF8';\nimport { Log } from '../../utils/log';\n\nlet tag: string = 'AMF';\n\nexport default class AMF {\n    /**\n     * 解析metadata\n     */\n    static parseMetadata(arr: ArrayBuffer) {\n        let data: any = {};\n        try {\n            let name = AMF.parseScript(arr, 0);\n            let value = AMF.parseScript(arr, name.size);\n            data[name.data] = value.data;\n        } catch (e) {\n            Log.e('AMF', e.toString());\n        }\n        return data;\n    }\n\n    static parseObject(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let name = AMF.parseString(arrayBuffer, dataOffset);\n        let value = AMF.parseScript(arrayBuffer, dataOffset + name.size);\n        let isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    static parseVariable(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        return AMF.parseObject(arrayBuffer, dataOffset);\n    }\n    static parseLongString(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let v = new DataView(arrayBuffer, dataOffset);\n        let length = v.getUint32(0);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n    static parseDate(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let v = new DataView(arrayBuffer, dataOffset);\n        let timestamp = v.getFloat64(0);\n        let localTimeOffset = v.getInt16(8);\n        timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n    static parseString(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let v = new DataView(arrayBuffer, dataOffset);\n        let length = v.getUint16(0);\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n        } else {\n            str = '';\n        }\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    static parseScript(arr: ArrayBuffer, dataOffset: number) {\n        let dataSize = arr.byteLength;\n        let offset = dataOffset;\n        // let uint8 = new Uint8Array(arr);\n        let buffer = arr;\n        let dv = new DataView(buffer, 0);\n\n        let value: any = null;\n        let type = dv.getUint8(offset);\n        offset += 1;\n        let objectEnd = false;\n\n        switch (type) {\n            case 0: // Number(Double) type\n                value = dv.getFloat64(offset);\n                offset += 8;\n                break;\n            case 1: {\n                // Boolean type\n                let b = dv.getUint8(offset);\n                value = !!b;\n                offset += 1;\n                break;\n            }\n            case 2: {\n                // String type\n                let amfstr = AMF.parseString(buffer, offset);\n                value = amfstr.data;\n                offset += amfstr.size;\n                break;\n            }\n            case 3: {\n                // Object(s) type\n                value = {};\n                let terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                if ((dv.getUint32(dataSize - 4) & 0x00ffffff) === 9) {\n                    terminal = 3;\n                }\n                while (offset < dataSize - 4) {\n                    // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                    let amfobj = AMF.parseObject(buffer, offset);\n\n                    if (amfobj.objectEnd) {\n                        break;\n                    }\n                    value[amfobj.data.name] = amfobj.data.value;\n                    // dataOffset += amfobj.size;\n                    offset = amfobj.size;\n                }\n                if (offset <= dataSize - 3) {\n                    let marker = dv.getUint32(offset - 1) & 0x00ffffff;\n                    if (marker === 9) {\n                        offset += 3;\n                    }\n                }\n                break;\n            }\n            case 8: {\n                // ECMA array type (Mixed array)\n                value = {};\n                // dataOffset += 1;\n                offset += 4; // ECMAArrayLength(UI32)\n                let terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                if ((dv.getUint32(dataSize - 4) & 0x00ffffff) === 9) {\n                    terminal = 3;\n                }\n                while (offset < dataSize - 8) {\n                    // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                    let amfvar = AMF.parseVariable(buffer, offset);\n\n                    if (amfvar.objectEnd) {\n                        break;\n                    }\n                    value[amfvar.data.name] = amfvar.data.value;\n                    offset = amfvar.size;\n                }\n                if (offset <= dataSize - 3) {\n                    let marker = dv.getUint32(offset - 1) & 0x00ffffff;\n                    if (marker === 9) {\n                        offset += 3;\n                    }\n                }\n                break;\n            }\n            case 9: // ScriptDataObjectEnd\n                value = undefined;\n                offset = 1;\n                objectEnd = true;\n                break;\n            case 10: {\n                // Strict array type\n                // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                value = [];\n                let strictArrayLength = dv.getUint32(offset);\n                offset += 4;\n                for (let i = 0; i < strictArrayLength; i++) {\n                    let val = AMF.parseScript(buffer, offset);\n                    value.push(val.data);\n                    offset = val.size;\n                }\n                break;\n            }\n            case 11: {\n                // Date type\n                let date = AMF.parseDate(buffer, offset + 1);\n                value = date.data;\n                offset += date.size;\n                break;\n            }\n            case 12: {\n                // Long string type\n                let amfLongStr = AMF.parseString(buffer, offset + 1);\n                value = amfLongStr.data;\n                offset += amfLongStr.size;\n                break;\n            }\n            default:\n                // ignore and skip\n                offset = dataSize;\n                Log.v(tag, 'AMF', 'Unsupported AMF value type ' + type);\n        }\n        return {\n            data: value,\n            size: offset,\n            objectEnd\n        };\n    }\n}\n","import { FlvTag, FlvTagType } from './flv';\n\nconst configBody = new Uint8Array([\n    23,\n    0,\n    0,\n    0,\n    0,\n    1,\n    100,\n    0,\n    10,\n    255,\n    225,\n    0,\n    24,\n    103,\n    100,\n    0,\n    10,\n    172,\n    114,\n    4,\n    68,\n    122,\n    16,\n    0,\n    0,\n    3,\n    0,\n    16,\n    0,\n    0,\n    3,\n    3,\n    32,\n    241,\n    34,\n    88,\n    70,\n    1,\n    0,\n    6,\n    104,\n    232,\n    67,\n    143,\n    44,\n    139\n]);\n\nconst frameI = new Uint8Array([\n    23,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    176,\n    6,\n    5,\n    255,\n    255,\n    172,\n    220,\n    69,\n    233,\n    189,\n    230,\n    217,\n    72,\n    183,\n    150,\n    44,\n    216,\n    32,\n    217,\n    35,\n    238,\n    239,\n    120,\n    50,\n    54,\n    52,\n    32,\n    45,\n    32,\n    99,\n    111,\n    114,\n    101,\n    32,\n    49,\n    53,\n    50,\n    32,\n    114,\n    50,\n    56,\n    53,\n    52,\n    32,\n    101,\n    57,\n    97,\n    53,\n    57,\n    48,\n    51,\n    32,\n    45,\n    32,\n    72,\n    46,\n    50,\n    54,\n    52,\n    47,\n    77,\n    80,\n    69,\n    71,\n    45,\n    52,\n    32,\n    65,\n    86,\n    67,\n    32,\n    99,\n    111,\n    100,\n    101,\n    99,\n    32,\n    45,\n    32,\n    67,\n    111,\n    112,\n    121,\n    108,\n    101,\n    102,\n    116,\n    32,\n    50,\n    48,\n    48,\n    51,\n    45,\n    50,\n    48,\n    49,\n    55,\n    32,\n    45,\n    32,\n    104,\n    116,\n    116,\n    112,\n    58,\n    47,\n    47,\n    119,\n    119,\n    119,\n    46,\n    118,\n    105,\n    100,\n    101,\n    111,\n    108,\n    97,\n    110,\n    46,\n    111,\n    114,\n    103,\n    47,\n    120,\n    50,\n    54,\n    52,\n    46,\n    104,\n    116,\n    109,\n    108,\n    32,\n    45,\n    32,\n    111,\n    112,\n    116,\n    105,\n    111,\n    110,\n    115,\n    58,\n    32,\n    99,\n    97,\n    98,\n    97,\n    99,\n    61,\n    49,\n    32,\n    114,\n    101,\n    102,\n    61,\n    49,\n    54,\n    32,\n    100,\n    101,\n    98,\n    108,\n    111,\n    99,\n    107,\n    61,\n    49,\n    58,\n    48,\n    58,\n    48,\n    32,\n    97,\n    110,\n    97,\n    108,\n    121,\n    115,\n    101,\n    61,\n    48,\n    120,\n    51,\n    58,\n    48,\n    120,\n    49,\n    51,\n    51,\n    32,\n    109,\n    101,\n    61,\n    117,\n    109,\n    104,\n    32,\n    115,\n    117,\n    98,\n    109,\n    101,\n    61,\n    49,\n    48,\n    32,\n    112,\n    115,\n    121,\n    61,\n    49,\n    32,\n    112,\n    115,\n    121,\n    95,\n    114,\n    100,\n    61,\n    49,\n    46,\n    48,\n    48,\n    58,\n    48,\n    46,\n    48,\n    48,\n    32,\n    109,\n    105,\n    120,\n    101,\n    100,\n    95,\n    114,\n    101,\n    102,\n    61,\n    49,\n    32,\n    109,\n    101,\n    95,\n    114,\n    97,\n    110,\n    103,\n    101,\n    61,\n    50,\n    52,\n    32,\n    99,\n    104,\n    114,\n    111,\n    109,\n    97,\n    95,\n    109,\n    101,\n    61,\n    49,\n    32,\n    116,\n    114,\n    101,\n    108,\n    108,\n    105,\n    115,\n    61,\n    50,\n    32,\n    56,\n    120,\n    56,\n    100,\n    99,\n    116,\n    61,\n    49,\n    32,\n    99,\n    113,\n    109,\n    61,\n    48,\n    32,\n    100,\n    101,\n    97,\n    100,\n    122,\n    111,\n    110,\n    101,\n    61,\n    50,\n    49,\n    44,\n    49,\n    49,\n    32,\n    102,\n    97,\n    115,\n    116,\n    95,\n    112,\n    115,\n    107,\n    105,\n    112,\n    61,\n    49,\n    32,\n    99,\n    104,\n    114,\n    111,\n    109,\n    97,\n    95,\n    113,\n    112,\n    95,\n    111,\n    102,\n    102,\n    115,\n    101,\n    116,\n    61,\n    45,\n    50,\n    32,\n    116,\n    104,\n    114,\n    101,\n    97,\n    100,\n    115,\n    61,\n    49,\n    32,\n    108,\n    111,\n    111,\n    107,\n    97,\n    104,\n    101,\n    97,\n    100,\n    95,\n    116,\n    104,\n    114,\n    101,\n    97,\n    100,\n    115,\n    61,\n    49,\n    32,\n    115,\n    108,\n    105,\n    99,\n    101,\n    100,\n    95,\n    116,\n    104,\n    114,\n    101,\n    97,\n    100,\n    115,\n    61,\n    48,\n    32,\n    110,\n    114,\n    61,\n    48,\n    32,\n    100,\n    101,\n    99,\n    105,\n    109,\n    97,\n    116,\n    101,\n    61,\n    49,\n    32,\n    105,\n    110,\n    116,\n    101,\n    114,\n    108,\n    97,\n    99,\n    101,\n    100,\n    61,\n    48,\n    32,\n    98,\n    108,\n    117,\n    114,\n    97,\n    121,\n    95,\n    99,\n    111,\n    109,\n    112,\n    97,\n    116,\n    61,\n    48,\n    32,\n    99,\n    111,\n    110,\n    115,\n    116,\n    114,\n    97,\n    105,\n    110,\n    101,\n    100,\n    95,\n    105,\n    110,\n    116,\n    114,\n    97,\n    61,\n    48,\n    32,\n    98,\n    102,\n    114,\n    97,\n    109,\n    101,\n    115,\n    61,\n    56,\n    32,\n    98,\n    95,\n    112,\n    121,\n    114,\n    97,\n    109,\n    105,\n    100,\n    61,\n    50,\n    32,\n    98,\n    95,\n    97,\n    100,\n    97,\n    112,\n    116,\n    61,\n    50,\n    32,\n    98,\n    95,\n    98,\n    105,\n    97,\n    115,\n    61,\n    48,\n    32,\n    100,\n    105,\n    114,\n    101,\n    99,\n    116,\n    61,\n    51,\n    32,\n    119,\n    101,\n    105,\n    103,\n    104,\n    116,\n    98,\n    61,\n    49,\n    32,\n    111,\n    112,\n    101,\n    110,\n    95,\n    103,\n    111,\n    112,\n    61,\n    48,\n    32,\n    119,\n    101,\n    105,\n    103,\n    104,\n    116,\n    112,\n    61,\n    50,\n    32,\n    107,\n    101,\n    121,\n    105,\n    110,\n    116,\n    61,\n    50,\n    53,\n    48,\n    32,\n    107,\n    101,\n    121,\n    105,\n    110,\n    116,\n    95,\n    109,\n    105,\n    110,\n    61,\n    50,\n    53,\n    32,\n    115,\n    99,\n    101,\n    110,\n    101,\n    99,\n    117,\n    116,\n    61,\n    52,\n    48,\n    32,\n    105,\n    110,\n    116,\n    114,\n    97,\n    95,\n    114,\n    101,\n    102,\n    114,\n    101,\n    115,\n    104,\n    61,\n    48,\n    32,\n    114,\n    99,\n    95,\n    108,\n    111,\n    111,\n    107,\n    97,\n    104,\n    101,\n    97,\n    100,\n    61,\n    54,\n    48,\n    32,\n    114,\n    99,\n    61,\n    99,\n    114,\n    102,\n    32,\n    109,\n    98,\n    116,\n    114,\n    101,\n    101,\n    61,\n    49,\n    32,\n    99,\n    114,\n    102,\n    61,\n    50,\n    51,\n    46,\n    48,\n    32,\n    113,\n    99,\n    111,\n    109,\n    112,\n    61,\n    48,\n    46,\n    54,\n    48,\n    32,\n    113,\n    112,\n    109,\n    105,\n    110,\n    61,\n    48,\n    32,\n    113,\n    112,\n    109,\n    97,\n    120,\n    61,\n    54,\n    57,\n    32,\n    113,\n    112,\n    115,\n    116,\n    101,\n    112,\n    61,\n    52,\n    32,\n    105,\n    112,\n    95,\n    114,\n    97,\n    116,\n    105,\n    111,\n    61,\n    49,\n    46,\n    52,\n    48,\n    32,\n    97,\n    113,\n    61,\n    49,\n    58,\n    49,\n    46,\n    48,\n    48,\n    0,\n    128,\n    0,\n    0,\n    0,\n    29,\n    101,\n    136,\n    129,\n    0,\n    5,\n    127,\n    254,\n    246,\n    115,\n    124,\n    10,\n    107,\n    109,\n    176,\n    149,\n    46,\n    5,\n    118,\n    246,\n    150,\n    55,\n    45,\n    60,\n    239,\n    89,\n    160,\n    124,\n    49,\n    129\n]);\n\nclass AVC {\n    static getFlvVideoTag(timestamp: number, config: boolean = false): FlvTag {\n        const tag = new FlvTag();\n        tag.tagType = FlvTagType.VIDEO;\n        if (config) {\n            tag.body = configBody;\n        } else {\n            tag.body = frameI;\n        }\n        tag.dataSize = tag.body.byteLength;\n        tag.timestamp = Math.round(timestamp);\n        tag.frameType = 1;\n        tag.codecId = 7;\n        tag.fill = true;\n        return tag;\n    }\n}\n\nexport default AVC;\n","import { ErrorDetails, ErrorTypes } from '../../core/errors';\nimport LasEvents from '../../core/events';\nimport Observer from '../../core/observer';\nimport { FLVTransConfig } from '../../types/core';\nimport { ATrack, IRemuxer, TrackType, VTrack } from '../../types/remux';\nimport { Log } from '../../utils/log';\nimport * as ASC from '../asc';\nimport SPSParser from '../sps-parser';\nimport AMF from './amf';\nimport AVC from './avc-helper';\nimport { FlvTag, FlvTagType } from './flv';\n\n\n// 连续Non-monotonous上限，超过上限重置remux\nconst DISCONTINUITY_ON_NON_MONOTONOUS = 10;\n\ntype TagCache = {\n    tag: FlvTag,\n    dataOffset: number\n}\n\nclass FlvDemux {\n    private tag = 'FlvDemux';\n    private _observer: Observer;\n    private _remuxer: IRemuxer;\n    private _config: FLVTransConfig;\n    private _duration: number;\n    private _naluLengthSize: number;\n    private _hasVideo: boolean;\n    private _hasAudio: boolean;\n    private _videoTrack: VTrack;\n    private _audioTrack: ATrack;\n    private _remuxStat?: { timeOffset: number; contiguous: boolean; accurateTimeOffset: boolean };\n    private _currentTimestamp: number = 0;\n    private _aLastDTS: number = 0;\n    private _vLastDTS: number = 0;\n    private _nonMonotonousCache?: Record<string, TagCache[]>;\n    private _fillAtStart = {\n        enabled: true,\n        start: 0,\n        avcConfig: true\n    };\n\n    constructor(observer: Observer, remuxer: IRemuxer, config: FLVTransConfig) {\n        this._observer = observer;\n        this._remuxer = remuxer;\n        this._config = config;\n\n        this._duration = 0;\n        this._naluLengthSize = 4;\n\n        this._hasVideo = true;\n        this._hasAudio = true;\n\n        this._videoTrack = {\n            id: 1,\n            type: TrackType.video,\n            container: '',\n            codec: '',\n            timescale: 90000,\n            duration: Infinity,\n            samples: [],\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            pid: -1,\n            width: 0,\n            height: 0,\n            codecWidth: 0,\n            codecHeight: 0,\n            sps: [],\n            pps: [],\n            pixelRatio: [],\n            profile: '',\n            level: '',\n            chromaFormat: '',\n            fps: 0,\n            dropped: 0,\n            refSampleDuration: 0,\n        };\n        this._audioTrack = {\n            id: 2,\n            type: TrackType.audio,\n            container: '',\n            codec: '',\n            timescale: 90000,\n            duration: Infinity,\n            samples: [],\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            pid: -1,\n            isAAC: true,\n            samplerate: 0,\n            channelCount: 0,\n            config: []\n        };\n    }\n\n    public append(tags: FlvTag[], timeOffset: number, contiguous: boolean, accurateTimeOffset: boolean): void {\n        if (!this._remuxStat) {\n            this._remuxStat = { timeOffset, contiguous, accurateTimeOffset };\n        }\n        if (!tags.length) return;\n        tags.forEach(tag => {\n            if (tag.tagType === FlvTagType.VIDEO && this._hasVideo) {\n                if (this._fillAtStart.enabled) {\n                    // 收到视频tag，停止填充\n                    this._fillAtStart.enabled = false;\n                    if (this._audioTrack.samples.length) {\n                        this._fillFrame(this._audioTrack.samples[this._audioTrack.samples.length - 1].dts / 90);\n                    }\n                }\n                this._parseVideoData(tag);\n            }\n            if (tag.tagType === FlvTagType.AUDIO && this._hasAudio) {\n                this._parseAudioData(tag);\n            }\n            if (tag.tagType === FlvTagType.SCRIPT) {\n                this._parseScriptTag(tag);\n            }\n        });\n\n        if (this._fillAtStart.enabled && this._audioTrack.samples.length) {\n            // 填充与音频同样长度的视频\n            let st = this._audioTrack.samples[0].dts / 90;\n            let ed = this._audioTrack.samples[this._audioTrack.samples.length - 1].dts / 90;\n            if (this._fillAtStart.start <= 0) {\n                this._fillAtStart.start = st;\n            }\n            if (ed > this._fillAtStart.start) {\n                this._fillFrame(ed);\n            }\n        }\n        this._remux();\n    }\n\n    public flvHead(hasAudio: boolean, hasVideo: boolean): void {\n        this._hasAudio = hasAudio;\n        this._hasVideo = hasVideo;\n        this._fillAtStart.enabled = this._hasVideo;\n    }\n\n    public destroy() { }\n\n    public flush() {\n        this._remux(true);\n        this._remuxStat = undefined;\n    }\n\n    public resetInitSegment() {\n        this._videoTrack.samples = [];\n        this._audioTrack.samples = [];\n        this._aLastDTS = this._vLastDTS = 0;\n        this._remuxStat = undefined;\n    }\n\n    public resetTimeStamp() { }\n\n    // 设置视频长度\n    public set duration(sec: number) {\n        this._duration = sec;\n    }\n\n    private _parseScriptTag(tag: FlvTag) {\n        if (tag.body) {\n            const scriptData = AMF.parseMetadata(tag.body.buffer);\n            scriptData.timestamp = this._currentTimestamp || 0;\n            if (scriptData.hasOwnProperty('onMetaData')) {\n                const onMetaData = scriptData.onMetaData;\n                if (typeof onMetaData.framerate === 'number') {\n                    this._videoTrack.fps = this._videoTrack.fps || onMetaData.framerate;\n                }\n                Log.i(this.tag, 'Parsed onMetaData');\n            }\n            this._observer.trigger(LasEvents.SCRIPT_PARSED, scriptData);\n        }\n    }\n\n    private _parseVideoData(tag: FlvTag) {\n        if (!tag.body) {\n            return;\n        }\n        // 获取 video tag body 第一字节\n        const spec = tag.body[0];\n        // 获取是否是关键帧\n        tag.frameType = (spec & 240) >>> 4;\n        // 获取编码格式\n        const codecId = spec & 15;\n        if (codecId !== 7 && codecId !== 12) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Unsupported codec in video frame: ${codecId}`\n            });\n            return;\n        }\n        tag.codecId = codecId;\n        // IF CodecID == 7  AVCPacketType\n        // 0 = AVC sequence header\n        // 1 = AVC NALU\n        // 2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)\n        const packetType = tag.body[1];\n        // 3字节\n        // IF AVCPacketType == 1\n        //  Composition time offset\n        // ELSE\n        //  0\n        tag.cts = ((tag.body[2] & 0xff) << 16) + ((tag.body[3] & 0xff) << 8) + (tag.body[4] & 0xff);\n\n        // IF AVCPacketType == 0 AVCDecoderConfigurationRecord（AVC sequence header）\n        // IF AVCPacketType == 1 One or more NALUs (Full frames are required)\n        if (packetType === 0) {\n            if (codecId === 7) {\n                this._parseAVCDecoderConfigurationRecord(tag, 5);\n            }\n        } else if (packetType === 1) {\n            this._parseAVCVideoData(tag, 5) || {};\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Invalid video packet type ${packetType}`\n            });\n            return;\n        }\n    }\n\n    /**\n     * AVC 初始化\n     * @param {FlvTag} tag flvtag\n     * @param {number} dataOffset tag body offset\n     */\n    private _parseAVCDecoderConfigurationRecord(tag: FlvTag, dataOffset: number) {\n        if (!tag.body) {\n            return;\n        }\n        const track = this._videoTrack;\n        const arrayBuffer = tag.body.buffer;\n        const dataSize = tag.body.byteLength - dataOffset;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        const version = v.getUint8(0); // configurationVersion\n        const avcProfile = v.getUint8(1); // avcProfileIndication\n        // const profileCompatibility = v.getUint8(2); // profile_compatibility\n        // const avcLevel = v.getUint8(3); // AVCLevelIndication\n        if (version !== 1 || avcProfile === 0) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: 'Flv: Invalid AVCDecoderConfigurationRecord'\n            });\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`\n            });\n            return;\n        }\n\n        const spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n        if (spsCount === 0 || spsCount > 1) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Invalid H264 SPS count: ${spsCount}`\n            });\n            return;\n        }\n\n        let offset = 6;\n        let spsList = [];\n        for (let i = 0; i < spsCount; i++) {\n            const len = v.getUint16(offset); // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            const sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            offset += len;\n            spsList.push(sps);\n            const config = SPSParser.parseSPS(sps);\n            const codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n\n            // sps update\n            if (\n                !!track.codec &&\n                (track.width !== config.codec_size.width ||\n                    track.height !== config.codec_size.height ||\n                    codecString !== track.codec)\n            ) {\n                if (!tag.fill) {\n                    this._remux(true);\n                }\n                if (this._remuxer.ISGenerated) {\n                    this._remuxer.resetInitSegment();\n                }\n            }\n            track.sps = spsList;\n            track.width = config.codec_size.width;\n            track.height = config.codec_size.height;\n            track.pixelRatio = [config.sar_ratio.width, config.sar_ratio.height];\n            if (config.frame_rate.fixed && config.frame_rate.fps !== 0) {\n                track.fps = config.frame_rate.fps;\n            }\n            track.codec = codecString;\n\n            track.profile = config.profile_string;\n            track.level = config.level_string;\n            track.chromaFormat = config.chroma_format_string;\n        }\n\n        const ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n        if (ppsCount === 0 || ppsCount > 1) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Invalid H264 PPS count: ${ppsCount}`\n            });\n            return;\n        }\n\n        offset++;\n        track.pps = [];\n        for (let i = 0; i < ppsCount; i++) {\n            const len = v.getUint16(offset); // pictureParameterSetLength\n            offset += 2;\n            const pps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            track.pps.push(pps);\n            if (len === 0) {\n                continue;\n            }\n            offset += len;\n        }\n        Log.v(this.tag, 'Parsed AVCDecoderConfigurationRecord');\n\n        track.duration = this._duration;\n        track.container = 'video/mp4';\n        if (track.fps) {\n            track.refSampleDuration = Math.floor(track.timescale / track.fps);\n        } else {\n            // 兼容无fps信息的情况，无fps时影响mp4sample duration估算，改为以gop为单位remux\n            // this._config.gopRemux = true;\n            track.refSampleDuration = Math.floor(track.timescale / 30);\n        }\n    }\n\n    /**\n     * 普通的AVC 片段\n     * @param {Flvtag} tag flv tag\n     * @param {number} dataOffset dataOffset\n     */\n    private _parseAVCVideoData(tag: FlvTag, dataOffset: number, ignoreNonMonotonous: boolean = false) {\n        if (!tag.body) {\n            return;\n        }\n        let info;\n        const arrayBuffer = tag.body.buffer;\n        const dataSize = tag.body.byteLength - dataOffset;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        const units = [];\n        let length = 0;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        const dts = tag.timestamp;\n        let keyframe = tag.frameType === 1; // from FLV Frame Type constants\n        // 处理Non-monotonous DTS及丢帧时间修正后可能出现的时间重叠，加速播放\n        if (!ignoreNonMonotonous && dts <= this._vLastDTS && this._vLastDTS > 0) {\n            Log.w(this.tag, `debug Non-monotonous DTS dts:${dts} last:${this._vLastDTS}`);\n            this._onNonMonotonous({ tag, dataOffset }, TrackType.video);\n            return;\n        }\n        if (!ignoreNonMonotonous && this._nonMonotonousCache) {\n            this._flushNonMonotonousCache();\n        }\n        const pts = dts + tag.cts;\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                Log.v(this.tag, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break; // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset); // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                Log.v(this.tag, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n            const data = new Uint8Array(arrayBuffer, dataOffset + offset + 4, lengthSize + naluSize - 4);\n            let unitType;\n            if (tag.codecId === 7) {\n                // AVC\n                unitType = v.getUint8(offset + lengthSize) & 0x1f;\n                if (unitType === 5) {\n                    keyframe = true;\n                }\n            }\n\n            const unit = { type: unitType, data };\n            units.push(unit);\n            length += data.byteLength;\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            const track = this._videoTrack;\n            const avcSample = {\n                units,\n                length,\n                dts: dts * 90,\n                cts: tag.cts * 90,\n                pts: pts * 90,\n                streamDTS: dts,\n                key: keyframe\n            };\n            track.samples.push(avcSample);\n        }\n        this._vLastDTS = dts;\n        return info;\n    }\n\n    private _parseAudioData(tag: FlvTag, ignoreNonMonotonous: boolean = false) {\n        if (!tag.body) {\n            return;\n        }\n        const dataSize = tag.body.byteLength;\n        let aacFrameLen;\n        if (dataSize <= 1) {\n            Log.v(this.tag, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n        const track = this._audioTrack;\n\n        const packetType = tag.body[1];\n\n        if (packetType === 0) {\n            if (tag.body.byteLength < 4) {\n                return;\n            }\n            ASC.initTrackConfig(track, this._observer, tag.body, 0, this._config.audioCodec);\n            track.duration = this._duration;\n\n            return;\n        } else if (packetType === 1) {\n            const aacData = tag.body.subarray(2);\n            // AAC raw frame data\n            let dts = tag.timestamp;\n            // 通过时间计算的dts与通过帧长度计算的dts比对，判断是否发生了跳帧\n            // aac帧长度\n            aacFrameLen = ASC.getFrameDuration(track.samplerate);\n            let maxAudioFramesDrift = aacFrameLen * this._config.maxAudioFramesDrift;\n            if (this._aLastDTS > 0) {\n                // 默认使用时间戳累加\n                dts = this._aLastDTS + aacFrameLen;\n                const dtsDiff = tag.timestamp - dts;\n                if (!ignoreNonMonotonous && dtsDiff < -maxAudioFramesDrift) {\n                    this._onNonMonotonous({ tag }, TrackType.audio);\n                    return;\n                }\n            }\n            if (!ignoreNonMonotonous && this._nonMonotonousCache) {\n                this._flushNonMonotonousCache();\n            }\n\n            const sampleDts = (dts * track.inputTimeScale) / 1000;\n            const aacSample = {\n                unit: aacData,\n                dts: sampleDts,\n                pts: sampleDts,\n                streamDTS: tag.timestamp,\n                length: aacData.byteLength\n            };\n            this._aLastDTS = dts;\n            track.samples.push(aacSample);\n        } else {\n            Log.v(this.tag, `Flv: Unsupported AAC data type ${packetType}`);\n        }\n    }\n\n    /**\n     * 检测到Non-monotonous，连续出现Non-monotonous按照中断重推处理\n     * @param {object} data tag相关数据\n     * @param {string} type audio|video\n     */\n    private _onNonMonotonous(data: any, type: TrackType) {\n        if (!this._nonMonotonousCache) {\n            this._nonMonotonousCache = {\n                video: [],\n                audio: []\n            };\n        }\n        const cache = this._nonMonotonousCache[type];\n        if (cache.length > DISCONTINUITY_ON_NON_MONOTONOUS) {\n            this.flush();\n            const lastPts = this._remuxer.getLastPTS();\n            let ptsSync: number = lastPts.audio;\n            if (ptsSync === 0 || (lastPts.video > 0 && lastPts.video < ptsSync)) {\n                ptsSync = lastPts.video;\n            }\n            this._videoTrack.samples = [];\n            this._audioTrack.samples = [];\n            this._aLastDTS = this._vLastDTS = 0;\n            this._remuxStat = { accurateTimeOffset: false, contiguous: false, timeOffset: ptsSync };\n            this._remuxer.resetInitSegment();\n            this._remuxer.resetTimeStamp();\n            Log.i(this.tag, 'NON_MONOTONOUS reset time');\n            this._flushNonMonotonousCache();\n        } else {\n            cache.push(data);\n        }\n    }\n\n    /**\n     * 清空Non-monotonous数据，remux\n     */\n    private _flushNonMonotonousCache() {\n        if (this._nonMonotonousCache) {\n            const nonMonotonousCache = this._nonMonotonousCache;\n            for (const key in nonMonotonousCache) {\n                const cache = nonMonotonousCache[key];\n                while (cache.length) {\n                    const data = cache.shift();\n                    if (data) {\n                        if (key === 'video') {\n                            this._parseAVCVideoData(data.tag, data.dataOffset, true);\n                        } else if (key === 'audio') {\n                            this._parseAudioData(data.tag, true);\n                        }\n                    }\n                }\n            }\n            this._nonMonotonousCache = undefined;\n        }\n    }\n\n    private _remux(end = false) {\n        const audiotrack = this._audioTrack;\n        const videotrack = this._videoTrack;\n        let contiguous = true,\n            timeOffset = 0,\n            accurateTimeOffset = false;\n        if (this._remuxStat) {\n            contiguous = this._remuxStat.contiguous;\n            timeOffset = this._remuxStat.timeOffset;\n            accurateTimeOffset = this._remuxStat.accurateTimeOffset;\n        }\n\n        if (audiotrack.samples.length === 0 && videotrack.samples.length === 0) {\n            if (end) {\n                this._remuxer.flush();\n            }\n            return;\n        }\n\n        if (!end && (this._hasAudio && audiotrack.samples.length === 0 || this._hasVideo && videotrack.samples.length < 2)) {\n            return;\n        }\n        try {\n            this._remuxer.remux(audiotrack, videotrack, timeOffset, contiguous, accurateTimeOffset, end);\n            this._remuxStat = undefined;\n        } catch (error) {\n            Log.e(this.tag, error);\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ERROR,\n                fatal: true,\n                reason: error.message\n            });\n        }\n    }\n\n    /**\n     * 填充视频空数据\n     * @param ed 结束时间戳 ms\n     */\n    private _fillFrame(ed: number) {\n        if (this._audioTrack.samples.length === 0) {\n            return;\n        }\n        let st = this._fillAtStart.start || this._audioTrack.samples[0].dts * 90;\n        if (ed > st) {\n            Log.i(this.tag, `fill video frame: ${st} ${ed}`);\n            this._fillAtStart.start = ed;\n            let tags: FlvTag[] = [AVC.getFlvVideoTag(st), AVC.getFlvVideoTag(ed - 1)];\n            if (this._fillAtStart.avcConfig) {\n                tags.unshift(AVC.getFlvVideoTag(st, true));\n                this._fillAtStart.avcConfig = false;\n            }\n            tags.forEach(tag => {\n                this._parseVideoData(tag);\n            });\n        }\n    }\n}\n\nexport default FlvDemux;\n","import LasEvents from '../../core/events';\nimport Observer from '../../core/observer';\nimport Mp4Remuxer from '../../remux/mp4-remuxer';\nimport { FLVTransConfig } from '../../types/core';\nimport FlvDemuxer from './flv-demuxer';\nimport { FlvTag } from './flv';\n\nexport interface FlvExtraData {\n    remuxId: number;\n    bitrate?: number;\n}\nclass FlvDemuxerInline {\n    private tag: string = 'Flv';\n    private _observer: Observer;\n    private _config: FLVTransConfig;\n    private _extraData: FlvExtraData;\n\n    private _demuxer!: FlvDemuxer;\n    private _remuxer!: Mp4Remuxer;\n\n    private _bitrate: number;\n    private _vendor: string;\n\n    constructor(observer: Observer, config: FLVTransConfig, extraData: FlvExtraData, vendor: string) {\n        this._observer = observer;\n        this._config = config;\n\n        this._bitrate = this._config.bitrate as number;\n        this._extraData = extraData;\n        this._vendor = vendor;\n    }\n\n    public init(): void {\n        const config = this._config,\n            observer = this._observer;\n\n        const remuxer = (this._remuxer = new Mp4Remuxer(observer, config, { mp4: true, mpeg: false, mp3: false }));\n        const demuxer = (this._demuxer = new FlvDemuxer(observer, remuxer, config));\n        remuxer.setExtra(this._extraData);\n        demuxer.duration = config.duration || 0;\n    }\n\n    public flvHead(hasAudio: boolean, hasVideo: boolean): void {\n        this._demuxer.flvHead(hasAudio, hasVideo);\n    }\n\n    public append(tags: FlvTag[], timeOffset: number, discontinuity: boolean, contiguous: boolean, accurateTimeOffset: boolean) {\n        if (discontinuity) {\n            this._demuxer.resetInitSegment();\n            this._remuxer.resetInitSegment();\n            this._demuxer.resetTimeStamp();\n            this._remuxer.resetTimeStamp();\n        }\n        this._demuxer.append(tags, timeOffset, contiguous, accurateTimeOffset);\n    }\n\n    public end(): void {\n        this._demuxer.flush();\n        this._remuxer.flush();\n        this._observer.trigger(LasEvents.LOAD_END);\n    }\n\n    public flush(): void {\n        if (this._demuxer) {\n            this._demuxer.flush();\n        }\n    }\n\n    public setExtra(data: FlvExtraData): void {\n        this._extraData = data;\n        this._extraData.bitrate = this._bitrate;\n        if (this._remuxer) {\n            this._remuxer.setExtra(this._extraData);\n        }\n    }\n\n    public destroy(): void { }\n\n}\n\nexport default FlvDemuxerInline;\n","function webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __webpack_require__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __webpack_require__.m = modules;\n\n/******/  // expose the module cache\n/******/  __webpack_require__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __webpack_require__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __webpack_require__.d = function(exports, name, getter) {\n/******/    if(!__webpack_require__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __webpack_require__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __webpack_require__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __webpack_require__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __webpack_require__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __webpack_require__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __webpack_modules__\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n","'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i\n  , whitespace = '[\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x20\\\\xA0\\\\u1680\\\\u180E\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\u2028\\\\u2029\\\\uFEFF]'\n  , left = new RegExp('^'+ whitespace +'+');\n\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(left, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address) {          // Sanitize what is left of the address\n    return address.replace('\\\\', '/');\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof global !== 'undefined') globalVar = global;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address) {\n  address = trimLeft(address);\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encodeURIComponent(key);\n      value = encodeURIComponent(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","import Observer from '../../core/observer';\nimport LasEvents from '../../core/events';\nimport FlvDemuxerInline, { FlvExtraData } from './flv-demuxer-inline';\nimport { Log } from '../../utils/log';\nimport { FLVTransConfig } from '../../types/core';\n\nexport default function (self: any) {\n    let flv: FlvDemuxerInline;\n\n    const observer = new Observer();\n    const forwardMessage = function (ev: string, data: any) {\n        self.postMessage({ event: ev, data: data });\n    };\n\n    observer.on(LasEvents.PARSING_INIT_SEGMENT, forwardMessage);\n    observer.on(LasEvents.ERROR, forwardMessage);\n    observer.on(LasEvents.SCRIPT_PARSED, forwardMessage);\n    observer.on(LasEvents.LOAD_END, forwardMessage);\n    observer.on(LasEvents.PARSING_DATA, function (ev, data) {\n        const message: any = { event: ev, data: data };\n        message.payload = data.payload;\n        delete data.payload;\n        self.postMessage(message, [message.payload.buffer]);\n    });\n\n    function init(observer: Observer, config: FLVTransConfig, data: FlvExtraData, vendor: string) {\n        flv = new FlvDemuxerInline(observer, config, data, vendor);\n        flv.init();\n    }\n\n    function destroy() {\n        if (flv) {\n            flv.destroy();\n        }\n        if (observer) {\n            observer.removeAllListeners();\n        }\n    }\n\n    self.addEventListener('message', function (e: any) {\n        const d = e.data;\n        switch (d.cmd) {\n            case 'init':\n                Log.level(d.config.debug);\n                init(observer, d.config, d.data, d.vendor);\n                break;\n            case 'destroy':\n                destroy();\n                break;\n            case 'append':\n                flv.append(d.tags, d.timeOffset, d.discontinuity, d.contiguous, d.accurateTimeOffset);\n                break;\n            case 'flvHead':\n                flv.flvHead(d.hasAudio, d.hasVideo);\n                break;\n            case 'flush':\n                flv.flush();\n                break;\n            case 'setExtra':\n                flv.setExtra(d.data);\n                break;\n            case 'end':\n                flv.end();\n                break;\n        }\n    });\n}\n","import { LasConfig } from './types/core';\nimport Browser from './utils/browser';\nimport { Log, LOG_LEVEL } from './utils/log';\n\nconst CLEANUP_DURATION_STEP = 10;\n\nconst URL_REG = new RegExp('^(http|https)://');\n\nconst DEFAULT_CONFIG = {\n    webWorker: true, // 是否开启webworker\n    autoCleanupMaxBackwardDuration: 60, // 清除sourcebuffer最大时间\n    autoCleanupMinBackwardDuration: 15, // 清除sourcebuffer最小时间\n    appendErrorMaxRetry: 3, // mse append出错后重试次数\n    credentials: false, // 请求是否带cookie\n    defaultSpts: -2000,\n    debug: LOG_LEVEL.LEVEL_ERROR,\n\n    connectionTimeout: 10000, // 流连接超时\n    transmissionTimeout: 30000, // 流传输超时\n    stretchShortVideoTrack: false,\n    maxBufferHole: 0.5,\n    maxAudioFramesDrift: 5, // used by mp4-remuxer\n};\n\nclass ConfigHelper {\n    /**\n     * 处理传入的config\n     * @param {object} userConfig 传入config\n     * @returns {object} config\n     */\n    static processConfig(userConfig: any): LasConfig {\n        const config: LasConfig = Object.assign({}, DEFAULT_CONFIG);\n        Object.assign(config, userConfig);\n        ConfigHelper.setSrc(config);\n\n        if (!(window as any).Worker) {\n            config.webWorker = false;\n        }\n        if (config.debug) {\n            Log.level(config.debug);\n        }\n        ConfigHelper.detectStreamingMux(config);\n        config.autoCleanupMaxBackwardDuration = Math.max(\n            config.autoCleanupMaxBackwardDuration,\n            config.autoCleanupMinBackwardDuration + CLEANUP_DURATION_STEP\n        );\n        return config;\n    }\n\n    static detectStreamingMux(config: LasConfig) {\n        config.gopRemux = Browser.safari || (Browser.opera && Browser.version.major < 37);\n    }\n\n    /**\n     * 重新设置config的src\n     * @param {object} config 传入config\n     * @param {*} src src或manifest\n     */\n    static setSrc(config: LasConfig, src: any = null) {\n        if (src) {\n            config.src = src;\n            config.manifest = '';\n        }\n        if (typeof config.src === 'string' && !URL_REG.test(config.src)) {\n            try {\n                config.src = JSON.parse(config.src);\n            } catch (e) {\n                config.manifest = '';\n            }\n        }\n        if (typeof config.src === 'object') {\n            config.manifest = config.src;\n            config.src = '';\n        }\n    }\n}\n\nexport { DEFAULT_CONFIG, ConfigHelper };\n\n","import { TimeRange } from '../types/core';\nimport MSEController from './mse-controller';\n\nclass Media {\n    private _video?: HTMLVideoElement;\n    private _mse?: MSEController;\n\n    private _streamTime: number = 0;\n    private _localTime: number = 0;\n\n    constructor() { }\n\n    public reset(): void {\n        this._streamTime = 0;\n        this._localTime = 0;\n    }\n\n    public attachVideo(video: HTMLVideoElement): void {\n        this._video = video;\n    }\n    public attachMSE(mse: MSEController): void {\n        this._mse = mse;\n    }\n\n    /**\n     * 指定时间是否在video缓冲区内\n     * @param sec time\n     * @returns isTimeinBuffered\n     */\n    public isTimeinBuffered(sec: number): boolean {\n        if (this._video) {\n            const buffered = this._video.buffered;\n            for (let i = 0; i < buffered.length; i++) {\n                if (sec >= buffered.start(i) && sec < buffered.end(i)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /*\n     * 计算video buffer量\n     */\n    public bufferedSec(): number {\n        if (this._video && this._video.buffered.length > 0) {\n            return Math.max(0, this._video.buffered.end(this._video.buffered.length - 1) - this._video.currentTime);\n        }\n        return 0;\n    }\n\n    /**\n     * 音频、视频的buffer长度\n     * @param type video|audio\n     */\n    public bufferedSecByType(type: string): number {\n        if (this._mse && this._video) {\n            let end = this._mse.bufferedEndByType(type);\n            if (end > 0) {\n                return this._mse.bufferedEndByType(type) - this._video.currentTime;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * 音频、视频的buffer长度\n     * @param type video|audio\n     */\n    public mseBufferedSecByType(type: string): TimeRange {\n        if (this._mse) {\n            return this._mse.bufferedByType(type);\n        }\n        return { start: 0, end: 0 };\n    }\n\n    /**\n     * 音频、视频buffer的段数\n     * @param type video|audio\n     */\n    public bufferSliceNumByType(type: string): number {\n        if (this._mse) {\n            return this._mse.bufferSliceNumByType(type);\n        }\n        return 0;\n    }\n\n    public pendingNum(): number {\n        if (this._mse) {\n            return this._mse.pendingNum();\n        }\n        return 0;\n    }\n\n    /**\n     * 待填充的buffer数据长度\n     * @param type video|audio\n     */\n    public pendingSecByType(type: string): number {\n        if (this._mse) {\n            return this._mse.pendingSecByType(type);\n        }\n        return 0;\n    }\n\n    /**\n     * 指定时间所在的buffer区域结束时间，不在任何buffer区域时返回空\n     * @param time 时间\n     */\n    public currentBuffer(time: number): TimeRange | undefined {\n        if (this._video) {\n            let buffered = this._video.buffered;\n            for (let i = 0; i < buffered.length; i++) {\n                const start = buffered.start(i);\n                const end = buffered.end(i);\n                if (start <= time && time < end) {\n                    return { start, end };\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * 指定时间所在的buffer区域结束时间，不在任何buffer区域时返回空\n     * @param time 时间\n     */\n    public nextBuffer(time: number): TimeRange | undefined {\n        if (this._video) {\n            let buffered = this._video.buffered;\n            for (let i = 0; i < buffered.length; i++) {\n                const start = buffered.start(i);\n                const end = buffered.end(i);\n                if (start > time) {\n                    return { start, end };\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * 更新转封装后的时间对应关系\n     * @param streamTime 流中的时间戳，秒\n     * @param localTime 本地时间，秒\n     */\n    public updateStreamTime(streamTime: number, localTime: number): void {\n        this._streamTime = streamTime;\n        this._localTime = localTime;\n    }\n\n    /**\n     * 根据流时间推算对应的本地时间戳\n     * @param streamTime 流时间\n     */\n    public getLocalTime(streamTime: number): number | undefined {\n        if (this._streamTime) {\n            return (streamTime - this._streamTime) + this._localTime;\n        }\n        return;\n    }\n\n    public get video(): HTMLVideoElement | undefined {\n        return this._video;\n    }\n\n    public get mse(): MSEController | undefined {\n        return this._mse;\n    }\n\n    /**\n     * 获取MSE当前状态，mse.readyState\n     */\n    public get mseReadyState(): ReadyState {\n        if (this._mse) {\n            return this._mse.readyState;\n        }\n        return 'closed';\n    }\n\n    /**\n     * 获取MSE当前状态，mse.readyState\n     */\n    public get videoReadyState(): number {\n        if (this._video) {\n            return this._video.readyState;\n        }\n        return 0;\n    }\n\n\n    /**\n     * video当前播放时间\n     */\n    public get currentTime(): number {\n        if (this._video) {\n            return this._video.currentTime;\n        }\n        return 0;\n    }\n}\n\nexport default Media;\n","/**\n * MediaSource helper\n */\n\nexport function getMediaSource (): typeof MediaSource {\n  return (window as any).MediaSource || (window as any).WebKitMediaSource;\n}\n","import { EventEmitter } from 'events';\nimport { LasConfig, TimeRange } from '../types/core';\nimport Browser from '../utils/browser';\nimport { Log } from '../utils/log';\nimport { getMediaSource } from '../utils/mediasource-helper';\nimport { ErrorDetails, ErrorTypes } from './errors';\nimport LasEvents from './events';\n\n// append关闭时queue允许缓存的长度上限\nconst QUEUE_SIZE_LIMIT = 200 * 1024 * 1024;\nconst MIN_CLEANUP_DURATION = 10;\nconst CLEANUP_DURATION_STEP = 10;\n\nconst MAX_BUFFERED = 30;\n\ntype Segment = {\n    type: string;\n    data: Uint8Array;\n    startDTS: number;\n    endDTS: number;\n    duration: number;\n};\n\nexport default class MSEController extends EventEmitter {\n    private tag: string = 'mse-controller';\n    private _config: LasConfig;\n\n    public video?: HTMLVideoElement;\n    public _sourceBuffer: { [index: string]: SourceBuffer };\n    private _mediaSource: MediaSource | null = null;\n    private _mimeCodec: { [index: string]: string };\n    private _cleanUpTask: { [index: string]: TimeRange[] };\n    private _appendQueue: { [index: string]: any[] };\n    private _hasVideo: boolean;\n    private _hasAudio: boolean;\n    private _endOfData: boolean = false;\n    private _appendEnabled: boolean;\n    private _duration: number | null = null;\n    private _appendError: number = 0;\n    private _appendBufferError: boolean = false;\n    private _sbHandler: { [index: string]: { updateend: (e: Event) => any; error: (e: Event) => any } } = {};\n    private _souceBufferLocked: boolean = false;\n\n    /**\n     * Mediasource 控制层\n     * @class Mediasource\n     * @param {Element} videoElement videoElement\n     * @param {object} config config\n     */\n    constructor(config: LasConfig) {\n        super();\n        this._config = config;\n        this._hasVideo = false;\n        this._hasAudio = false;\n        this._appendQueue = {\n            video: [],\n            audio: [],\n            audiovideo: []\n        };\n        this._sourceBuffer = {};\n        this._cleanUpTask = { video: [], audio: [], audiovideo: [] };\n        this._mimeCodec = {};\n        this._appendEnabled = true;\n    }\n\n    /**\n     * 绑定HTMLvideo\n     * @param video video\n     */\n    public attach(video: HTMLVideoElement): void {\n        this.video = video;\n        const MediaSourceDef = getMediaSource();\n        if (MediaSourceDef) {\n            const ms = (this._mediaSource = new MediaSourceDef());\n            this.video.src = URL.createObjectURL(ms);\n            this.video.load();\n            ms.addEventListener('sourceopen', this._onSourceOpen);\n            ms.addEventListener('sourceended', this._onSourceEnded);\n            ms.addEventListener('sourceclose', this._onSourceClose);\n            this._souceBufferLocked = false;\n        } else {\n            setTimeout(() => {\n                this.emit(LasEvents.ERROR, {\n                    type: ErrorTypes.MSE_ERROR,\n                    details: ErrorDetails.MEDIASOURCE_ERROR,\n                    fatal: true,\n                    reason: 'MediaSource is not support'\n                });\n            }, 0);\n        }\n    }\n\n    /**\n     * mediaSource init\n     * @param {Object} mediaInfo mediaInfo\n     */\n    public trackInfo(mediaInfo: any): void {\n        if ((this._hasAudio !== mediaInfo.hasAudio || this._hasVideo !== mediaInfo.hasVideo || !!mediaInfo.audiovideo !== !!this._mimeCodec.audiovideo) && this.video && this.hasSourceBuffer()) {\n            // 音视频轨数量发生变化时需要重建mse\n            Log.i(this.tag, 'trackInfo rebuild mse');\n            for (const type in this._sourceBuffer) {\n                if (this._sourceBuffer[type] && this._sbHandler[type]) {\n                    this._sourceBuffer[type].removeEventListener('error', this._sbHandler[type].error);\n                    this._sourceBuffer[type].removeEventListener('updateend', this._sbHandler[type].updateend);\n                }\n            }\n            this._sourceBuffer = {};\n            if (this._mediaSource) {\n                this._mediaSource.removeEventListener('sourceopen', this._onSourceOpen);\n                this._mediaSource.removeEventListener('sourceended', this._onSourceEnded);\n                this._mediaSource.removeEventListener('sourceclose', this._onSourceClose);\n            }\n            this._mimeCodec = {};\n            this.attach(this.video);\n        }\n        if (!mediaInfo.audiovideo) {\n            if (mediaInfo.hasAudio && mediaInfo.audioCodec) {\n                this._mimeCodec.audio = `audio/mp4; codecs=\"${mediaInfo.audioCodec}\"`;\n            }\n            if (mediaInfo.hasVideo && mediaInfo.videoCodec) {\n                this._mimeCodec.video = `video/mp4; codecs=\"${mediaInfo.videoCodec}\"`;\n            }\n        } else {\n            this._mimeCodec.audiovideo = `video/mp4; codecs=\"${mediaInfo.codec}\"`;\n        }\n        this._hasAudio = this._hasAudio || mediaInfo.hasAudio;\n        this._hasVideo = this._hasVideo || mediaInfo.hasVideo;\n\n        this._checkSourceBuffer();\n    }\n\n    /**\n     * 检查track是否已获取codec\n     */\n    private _checkSourceBuffer(): void {\n        let expected = (this._hasAudio ? 1 : 0) + (this._hasVideo ? 1 : 0);\n        let codecs = (this._mimeCodec.audio ? 1 : 0) + (this._mimeCodec.video ? 1 : 0);\n        if (this._mimeCodec.audiovideo) {\n            expected = 1;\n            codecs = 1;\n        }\n        Log.v(this.tag, 'checkSourceBuffer', expected, codecs, this._mimeCodec);\n        if (this._mediaSource && this._mediaSource.readyState === 'open' && expected > 0 && codecs >= expected) {\n            for (const type in this._mimeCodec) {\n                if (this._mimeCodec[type]) {\n                    this._addSourceBuffer(type);\n                }\n            }\n        }\n    }\n\n    /**\n     * mediaSource open\n     */\n    private _onSourceOpen = () => {\n        Log.i(this.tag, 'MediaSource onSourceOpen');\n        if (this._mediaSource) {\n            this._mediaSource.removeEventListener('sourceopen', this._onSourceOpen);\n            this._checkSourceBuffer();\n            this.refresh();\n            this.emit('source_open');\n        }\n    };\n\n    /**\n     * addSourceBuffer\n     * @param {String} type type\n     */\n    private _addSourceBuffer(type: string): void {\n        if (this._sourceBuffer[type] || this._souceBufferLocked) {\n            return;\n        }\n        try {\n            if (this._mediaSource) {\n                this._sourceBuffer[type] = this._mediaSource.addSourceBuffer(this._mimeCodec[type]);\n            }\n        } catch (e) {\n            Log.e(this.tag, e);\n            this.emit(LasEvents.ERROR, {\n                type: ErrorTypes.MSE_ERROR,\n                details: ErrorDetails.ADDSOURCEBUFFER_ERROR,\n                fatal: true,\n                reason: e.message\n            });\n            return;\n        }\n        const sb = this._sourceBuffer[type];\n        this._sbHandler[type] = {\n            updateend: () => {\n                this._onSourceBufferUpdateEnd(type);\n            },\n            error: (e: Event) => {\n                this._onSourceBufferError(e);\n            }\n        };\n        sb.addEventListener('error', this._sbHandler[type].error);\n        sb.addEventListener('updateend', this._sbHandler[type].updateend);\n        if (this._duration && this._mediaSource) {\n            this._mediaSource.duration = this._duration;\n        }\n    }\n\n    /**\n     * 是否有待处理的数据\n     */\n    private _hasPendingData(): boolean {\n        return !!(\n            this._appendQueue &&\n            ((this._appendQueue.video && this._appendQueue.video.length) ||\n                (this._appendQueue.audio && this._appendQueue.audio.length))\n        );\n    }\n\n    /**\n     * 刷新MSE，计算一次清理任务，尝试重启填充buffer任务\n     */\n    public refresh() {\n        for (const type in this._sourceBuffer) {\n            this._update(type);\n        }\n    }\n\n    /**\n     * 填充mse sourcebuffer\n     */\n    private _doAppend(type: string): void {\n        if (this._hasPendingData()) {\n            if (!this._appendEnabled) {\n                const size = this._getBufferQueueSize();\n                if (size > QUEUE_SIZE_LIMIT && !this._appendBufferError) {\n                    this._appendBufferError = true;\n                    this.emit(LasEvents.ERROR, {\n                        type: ErrorTypes.MSE_ERROR,\n                        details: ErrorDetails.APPENDBUFFER_ERROR,\n                        fatal: true,\n                        reason: 'bufferfull'\n                    });\n                }\n                return;\n            }\n            if (\n                this._appendQueue[type].length > 0 &&\n                this._sourceBuffer[type] &&\n                !this._sourceBuffer[type].updating &&\n                !this._appendBufferError\n            ) {\n                const data = this._appendQueue[type].shift();\n                this._appendBuffer(data, type);\n            }\n        }\n    }\n\n    /**\n     * 转封装后fmp4数据\n     * @param segment segment\n     */\n    public mediaSegment(segment: Segment): void {\n        const type = segment.type;\n        const queue = this._appendQueue[type];\n        if (!this._souceBufferLocked || this._sourceBuffer[type]) {\n            queue.push(segment);\n        }\n        if (this._sourceBuffer[type]) {\n            this._souceBufferLocked = true;\n            this._update(type);\n        }\n    }\n\n    /**\n     * mse buffer范围，秒\n     * @param type video|audio|audiovideo\n     */\n    public bufferedByType(type: string): { start: number; end: number } {\n        const sb = this._sourceBuffer[type];\n        if (sb && sb.buffered.length > 0) {\n            return { start: sb.buffered.start(0), end: sb.buffered.end(sb.buffered.length - 1) };\n        }\n        return { start: 0, end: 0 };\n    }\n\n    /**\n     * mse buffer结束时间点，秒\n     * @param type video|audio|audiovideo\n     */\n    public bufferedEndByType(type: string): number {\n        const sb = this._sourceBuffer[type];\n        if (sb && sb.buffered.length > 0) {\n            return sb.buffered.end(sb.buffered.length - 1);\n        }\n        return 0;\n    }\n\n    /**\n     * mse buffer的分段数量，正常情况不大于1\n     * @param type video|audio|audiovideo\n     */\n    public bufferSliceNumByType(type: string): number {\n        const sb = this._sourceBuffer[type];\n        if (sb) {\n            return sb.buffered.length;\n        }\n        return 0;\n    }\n\n    /**\n     * 待填充buffer长度\n     * @param type video|audio|audiovideo\n     */\n    public pendingSecByType(type: string): number {\n        const buffer = this._appendQueue[type];\n        if (buffer) {\n            return buffer.reduce((prev, current) => {\n                return prev + current.duration;\n            }, 0);\n        }\n        return 0;\n    }\n\n    /**\n     * 待填充buffer数量\n     */\n    public pendingNum(): number {\n        let num = 0;\n        for (let type in this._appendQueue) {\n            num += this._appendQueue[type].length;\n        }\n        return num;\n    }\n\n    /**\n     * 根据填充策略计算需要缓存清理的范围\n     * @param type video|audio|audiovideo\n     */\n    private _calculateRemoveRange(type: string): void {\n        const video = this.video;\n        if (!video || video.seeking) {\n            return;\n        }\n        const time = video.currentTime;\n        if (this._sourceBuffer[type]) {\n            const task = this._cleanUpTask[type];\n            const buffered = this._sourceBuffer[type].buffered;\n            if (buffered.length >= 1 && time - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n                const end = time - this._config.autoCleanupMinBackwardDuration;\n                if (task.length) {\n                    if (task[task.length - 1].start === 0 && task[task.length - 1].end === end) {\n                        return;\n                    }\n                }\n                task.push({ start: 0, end });\n            }\n        }\n    }\n\n    /**\n     * 尝试清理sourcebufer缓存\n     * @param sb 需要清理的sourceBuffer\n     * @param range 需要清理的范围\n     */\n    private _cleanUpRange(type: string, range: TimeRange): boolean {\n        const sb = this._sourceBuffer[type];\n        if (sb) {\n            if (!sb.updating) {\n                try {\n                    for (let i = 0; i < sb.buffered.length; i++) {\n                        const bufStart = Browser.firefox ? 0 : sb.buffered.start(i);\n                        const bufEnd = sb.buffered.end(i);\n                        const removeStart = Math.max(bufStart, range.start);\n                        const removeEnd = Math.min(bufEnd, range.end);\n                        /**\n                         * remove不一定准确按照指定值进行，remove长度小于500ms，可能无效\n                         */\n                        if (removeEnd > removeStart) {\n                            sb.remove(removeStart, removeEnd);\n                            this.emit('remove');\n                            // 多段buffer时可能需要多次清理\n                            if (i < sb.buffered.length - 1) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) { }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 向sourcebuffer中填充数据\n     * @param data data\n     * @param type type\n     */\n    private _appendBuffer(data: Segment, type: string): void {\n        if (!this._sourceBuffer[type] || !this.video || this.video.error) {\n            return;\n        }\n        try {\n            this._sourceBuffer[type].appendBuffer(data.data.buffer);\n        } catch (e) {\n            Log.w(this.tag, e.code, e);\n            if (e.code !== 22) {\n                if (this._appendError) {\n                    this._appendError++;\n                } else {\n                    this._appendError = 1;\n                }\n                if (this._appendError > this._config.appendErrorMaxRetry) {\n                    this._appendBufferError = true;\n                    this.emit(LasEvents.ERROR, {\n                        type: ErrorTypes.MSE_ERROR,\n                        details: ErrorDetails.APPENDBUFFER_ERROR,\n                        fatal: true,\n                        reason: e.message\n                    });\n                } else {\n                    this._appendQueue[type].unshift(data);\n                }\n            } else {\n                let v = this.video, conf = this._config;\n                this._appendEnabled = false;\n                this._appendQueue[type].unshift(data);\n                let buffered = v.buffered.end(v.buffered.length - 1) - v.currentTime;\n                // mse bufferfull 降级策略\n                let useless = v.currentTime - v.buffered.start(0);\n                if (buffered < MAX_BUFFERED) {\n                    //  修改buffer清理阈值并清理buffer\n                    if (useless < conf.autoCleanupMaxBackwardDuration) {\n                        conf.autoCleanupMaxBackwardDuration = Math.max(conf.autoCleanupMaxBackwardDuration / 2, MIN_CLEANUP_DURATION + CLEANUP_DURATION_STEP);\n                        conf.autoCleanupMinBackwardDuration = MIN_CLEANUP_DURATION;\n                    }\n                    this._calculateRemoveRange(type);\n                    if (this.hasCleanUpTask(type)) {\n                        this._cleanUp(type);\n                    }\n                } else if (useless < conf.autoCleanupMinBackwardDuration) {\n                    //  已满足buffer阈值，抛错\n                    this.emit(LasEvents.ERROR, {\n                        type: ErrorTypes.MSE_ERROR,\n                        details: ErrorDetails.APPENDBUFFER_ERROR,\n                        fatal: true,\n                        reason: 'buffer full, append error'\n                    });\n                }\n                Log.i(this.tag, 'mse bufferfull')\n                this.emit('bufferFull');\n            }\n        }\n    }\n\n    /**\n     * sourcebuffer end\n     */\n    private _onSourceEnded = () => {\n        Log.i(this.tag, 'MediaSource onSourceEnded');\n    };\n\n    /**\n     * sourcebuffer close\n     */\n    private _onSourceClose = () => {\n        Log.i(this.tag, 'MediaSource onSourceClose');\n        if (this._mediaSource) {\n            this._mediaSource.removeEventListener('sourceopen', this._onSourceOpen);\n            this._mediaSource.removeEventListener('sourceended', this._onSourceEnded);\n            this._mediaSource.removeEventListener('sourceclose', this._onSourceClose);\n        }\n    };\n\n    private _onSourceBufferUpdateEnd = (type: string) => {\n        this._update(type);\n        if (this._endOfData) {\n            this._endOfStream();\n        }\n        this.emit('updateend');\n    };\n\n    /**\n     * sourcebuffer error\n     * @param {Object} e 事件\n     */\n    private _onSourceBufferError = (e: Event) => {\n        Log.e(this.tag, `SourceBuffer Error: ${e}`);\n        this.emit(LasEvents.ERROR, {\n            type: ErrorTypes.MSE_ERROR,\n            details: ErrorDetails.SOURCEBUFFER_ERROR,\n            fatal: true,\n            reason: 'source buffer error'\n        });\n    };\n\n    /**\n     * 清理mse sourcebuffer缓存\n     * @param startSec 开始时间点，未指从0点开始\n     * @param endSec 结束时间点，未指定时结束点为正无穷大\n     * @param flushType 类型，未指定时清理所有sourcebuffe\n     */\n    public flush(startSec?: number, endSec?: number, flushType?: string): void {\n        let start = 0,\n            end = Number.POSITIVE_INFINITY;\n        this._endOfData = false;\n        // 计算清理范围\n        for (const type in this._sourceBuffer) {\n            if (flushType && flushType !== type) {\n                continue;\n            }\n            const sb = this._sourceBuffer[type];\n            if (!sb) {\n                continue;\n            }\n            // 清理未填充数据\n            if (startSec) {\n                start = Math.max(start, startSec);\n                for (let i = this._appendQueue[type].length - 1; i >= 0; i--) {\n                    if (!this._appendQueue[type][i].startPTS || this._appendQueue[type][i].startPTS >= startSec) {\n                        this._appendQueue[type].pop();\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                this._appendQueue[type] = [];\n            }\n            if (endSec) {\n                end = Math.min(end, endSec);\n            }\n            this._cleanUpTask[type].push({ start, end });\n            this._cleanUp(type);\n        }\n        this._appendEnabled = true;\n    }\n\n    /**\n     * 是否开启buffer填充\n     * @param value 开关\n     */\n    public setAppendEnabled(value: boolean): void {\n        if (!this._appendEnabled && value) {\n            this._appendEnabled = value;\n            this.refresh();\n        } else {\n            this._appendEnabled = value;\n        }\n    }\n\n    public getAppendEnabled(): boolean {\n        return this._appendEnabled;\n    }\n\n    public endOfData(): void {\n        this._endOfData = true;\n        if (!this._hasPendingData()) {\n            this._endOfStream();\n        }\n    }\n\n    public ended(): boolean {\n        return this._endOfData;\n    }\n\n    private _endOfStream(): void {\n        const ms = this._mediaSource;\n        if (!ms || ms.readyState !== 'open') {\n            return;\n        }\n        for (const type in this._sourceBuffer) {\n            const sb = this._sourceBuffer[type];\n            if (sb && sb.updating) {\n                return;\n            }\n        }\n        try {\n            ms.endOfStream();\n        } catch (error) {\n            Log.e(this.tag, error);\n            this.emit(LasEvents.ERROR, {\n                type: ErrorTypes.MSE_ERROR,\n                details: ErrorDetails.ENDOFSTREAM_ERROR,\n                fatal: true,\n                reason: error.message\n            });\n        }\n    }\n\n    /**\n     * destroy\n     */\n    public destroy(): void {\n        if (this._mediaSource) {\n            const ms = this._mediaSource;\n            // pending segments should be discard\n\n            // remove all sourcebuffers\n            this._endOfStream();\n            if (ms.readyState !== 'closed') {\n                for (const type in this._sourceBuffer) {\n                    if (this._sourceBuffer[type] && this._sbHandler[type]) {\n                        this._sourceBuffer[type].removeEventListener('error', this._sbHandler[type].error);\n                        this._sourceBuffer[type].removeEventListener('updateend', this._sbHandler[type].updateend);\n                        ms.removeSourceBuffer(this._sourceBuffer[type]);\n                    }\n                }\n            }\n            ms.removeEventListener('sourceopen', this._onSourceOpen);\n            ms.removeEventListener('sourceended', this._onSourceEnded);\n            ms.removeEventListener('sourceclose', this._onSourceClose);\n            this._mediaSource = null;\n        }\n        this.removeAllListeners();\n        this._appendQueue = {};\n        this._mimeCodec = {};\n        this._cleanUpTask = {};\n        this._sourceBuffer = {};\n        this._sbHandler = {};\n    }\n\n    /**\n     * 是否有未完成的清理任务\n     * @param type video|audio|audiovideo\n     */\n    public hasCleanUpTask(type?: string): boolean {\n        let num = 0;\n        if (typeof type === 'undefined') {\n            for (let type in this._cleanUpTask) {\n                num += this._cleanUpTask[type].length;\n            }\n        } else {\n            if (this._cleanUpTask[type]) {\n                num = this._cleanUpTask[type].length;\n            }\n        }\n        return num > 0;\n    }\n\n    public hasSourceBuffer(): boolean {\n        return !!Object.keys(this._sourceBuffer).length;\n    }\n\n    private _getBufferQueueSize(): number {\n        let num = 0;\n        for (const type in this._appendQueue) {\n            num += this._appendQueue[type].reduce((prev, current) => {\n                if (current.data && current.data.byteLength) {\n                    return prev + current.data.byteLength;\n                }\n                return prev;\n            }, 0);\n        }\n        return num;\n    }\n\n    /**\n     * 待填充队列中的数据时长\n     * @param {string} type video|audio|audiovideo，为空时返回video|audio最大值\n     * @returns {number} 时长\n     */\n    public getBufferQueueSec(type?: string): number {\n        if (!this._appendQueue) {\n            return 0;\n        }\n        let keys;\n        if (type) {\n            keys = [type];\n        } else {\n            keys = Object.keys(this._appendQueue);\n        }\n        return keys.reduce((prev, current) => {\n            if (this._appendQueue[current] && this._appendQueue[current].length > 0 && (Object.keys(this._sourceBuffer).length === 0 || this._sourceBuffer[current])) {\n                return Math.max(\n                    prev,\n                    this._appendQueue[current].reduce((prevDuration, currentSeg) => {\n                        if (currentSeg.duration) {\n                            return prevDuration + currentSeg.duration;\n                        }\n                        return prevDuration;\n                    }, 0)\n                );\n            }\n            return prev;\n        }, 0);\n    }\n\n    /**\n     * 获取MSE当前状态，mse.readyState\n     */\n    public get readyState(): ReadyState {\n        if (this._mediaSource) {\n            return this._mediaSource.readyState;\n        }\n        return 'closed';\n    }\n\n    /**\n     * 更新souceBuffer，清理或填充\n     */\n    private _update(type: string): void {\n        if (this.hasCleanUpTask(type)) {\n            this._cleanUp(type);\n        }\n        this._doAppend(type);\n    }\n\n    /**\n     * 执行清理任务\n     * @param type video|audio|audiovideo\n     */\n    private _cleanUp(type: string): void {\n        let range = this._cleanUpTask[type];\n        while (range && range.length) {\n            const item = range[0];\n            if (this._cleanUpRange(type, item)) {\n                range.shift();\n            } else {\n                return;\n            }\n        }\n        this.refresh();\n    }\n}\n","import Url from 'url-parse';\n\n/**\n * 生成切换flv的请求地址\n * @param url 流地址\n * @param spts 切换时间戳，单位毫秒。大于0：关键帧pts；小于0：直播延迟\n */\nexport function abrGetUrl(url: string, spts?: number): string {\n    if (typeof spts === 'undefined') {\n        return url;\n    }\n    const urlparse = new Url(url, true);\n    urlparse.query.lasSpts = `${spts}`;\n    return urlparse.toString();\n}","export default class AbrLevel {\n    public url: string;\n    public bitrate: number = 0;\n    public maxBitrate: number = 0;\n    public avgBitrate: number = 0;\n    public qualityType: string = '';\n    public qualityLabel: string = '';\n    public id: number = 0;\n    public codec: string = '';\n    public hidden: boolean = false;\n    public enableAdaptive: boolean = true;\n    public defaultSelect: boolean = false;\n\n    constructor(url: string) {\n        this.url = url;\n    }\n}","import AbrLevel from \"./abr-level\";\nexport type Representation = {\n    id: number,  //[int][M]\n    url: string, // [string][M]\n    backupUrl: string[], // [string][M1]\n    host: string, // [string][M2]\n    maxBitrate: number, // [int][M] maxBitrate in kbps set by transcoder\n    avgBitrate: number, // [int][M1&2] avgBitrate in kbps\n    codecs: string, // [string][O]\n    width: number,  // [int][M]\n    height: number, // [int][M]\n    frameRate: number, // [float][O]\n    qualityType: string,  // [string][M] 档位展示类型\n    qualityLabel: string, // [string][O] 档位展示字段\n    hidden: boolean, // [bool][M] false denotes the representation is show in UI and can be selected by manual model\n    disableAdaptive: boolean, // [bool][M] false denotes the representation can be selected by auto model\n    defaultSelect: boolean // [bool][M1,3,4] false denotes the representation is not selected as the initialization level\n}\n\ntype AdaptationSet = {\n    id: number;\n    duration: number;\n    representation: Representation[];\n};\n\nexport type AbrManifestData = {\n    version: string,\n    adaptationSet: AdaptationSet[];\n};\n\n/**\n * las manifest\n */\nexport class AbrManifest {\n    private _levels: AbrLevel[] = [];\n    private _abrLevels: number[] = [];\n    private _default?: number;\n\n    /**\n     * 验证las manifest数据\n     * @param data 输入数据\n     */\n    public static verify(data: any) {\n        if (\n            data &&\n            data.hasOwnProperty('version') &&\n            data.hasOwnProperty('adaptationSet') &&\n            Array.isArray(data.adaptationSet) &&\n            data.adaptationSet.length > 0\n        ) {\n            return data.adaptationSet.reduce((prev: boolean, item: any) => {\n                return !!(prev && item.representation && item.representation.length)\n            }, true);\n        }\n        return false;\n    }\n\n    constructor(manifest: AbrManifestData) {\n        if (AbrManifest.verify(manifest)) {\n\n            manifest.adaptationSet[0].representation.sort((a, b) => {\n                return a.maxBitrate - b.maxBitrate;\n            });\n\n            manifest.adaptationSet[0].representation.forEach((item, index) => {\n                let level = new AbrLevel(item.url);\n                level.id = item.id || 0;\n                level.maxBitrate = item.maxBitrate || 0;\n                level.avgBitrate = item.avgBitrate || 0;\n                level.bitrate = level.maxBitrate;\n                level.qualityType = item.qualityType || '';\n                level.qualityLabel = item.qualityLabel || '';\n                level.codec = item.codecs || '';\n                level.hidden = item.hidden || false;\n                level.enableAdaptive = typeof item.disableAdaptive === 'undefined' ? true : !item.disableAdaptive;\n                level.defaultSelect = item.defaultSelect || false;\n                this._levels.push(level);\n\n                if (level.enableAdaptive) {\n                    this._abrLevels.push(index);\n                }\n                if (level.defaultSelect && typeof this._default === 'undefined') {\n                    this._default = index;\n                }\n            });\n        } else {\n            return;\n        }\n    }\n\n    /**\n     * 码率列表\n     */\n    public get levels(): AbrLevel[] {\n        return this._levels;\n    }\n\n    /**\n     * 可用于自适应切换的码率index列表\n     */\n    public get abrLevels(): number[] {\n        return this._abrLevels;\n    }\n\n    /**\n     * 默认起播清晰度\n     */\n    public get default(): number {\n        return this._default || 0;\n    }\n}\n","export type TypedArray\n= | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Uint8ClampedArray\n    | Float32Array\n    | Float64Array;\n\nexport type TypedArrayConstructor\n= | Int8ArrayConstructor\n    | Uint8ArrayConstructor\n    | Int16ArrayConstructor\n    | Uint16ArrayConstructor\n    | Int32ArrayConstructor\n    | Uint32ArrayConstructor\n    | Uint8ClampedArrayConstructor\n    | Float32ArrayConstructor\n    | Float64ArrayConstructor;\n\nconst type: (input: TypedArray) => TypedArrayConstructor = (input: TypedArray): TypedArrayConstructor => {\n    switch (input.constructor.name) {\n        case 'Int8Array':\n            return Int8Array;\n        case 'Uint8Array':\n            return Uint8Array;\n        case 'Int16Array':\n            return Int16Array;\n        case 'Uint16Array':\n            return Uint16Array;\n        case 'Int32Array':\n            return Int32Array;\n        case 'Uint32Array':\n            return Uint32Array;\n        case 'Uint8ClampedArray':\n            return Uint8ClampedArray;\n        case 'Float64Array':\n            return Float64Array;\n        default:\n            return Float32Array;\n    }\n};\n\nconst flatten: (input: any[]) => number[] = (input: any[]): number[] =>\n    input.reduce((acc: any[], next: any) => acc.concat(Array.isArray(next) ? flatten(next) : next), []);\n\nconst shape: (input: any) => number[] = (input: any): number[] =>\n    Array.isArray(input) ? [input.length].concat(shape(input[0])) : [];\n\nconst isTypedArray: (input: any) => boolean = (input: any): boolean =>\n    !!(input && input.buffer instanceof ArrayBuffer && input.BYTES_PER_ELEMENT);\n\nexport class Matrix {\n    /**\n     * Static method. Adds two matrices `a` and `b` together.\n     */\n    public static add(a: Matrix, b: Matrix): Matrix {\n        return a.copy().add(b);\n    }\n\n    /**\n     * Static method. Subtracts the matrix `b` from matrix `a`.\n     */\n    public static subtract(a: Matrix, b: Matrix): Matrix {\n        return a.copy().subtract(b);\n    }\n\n    /**\n     * Static method. Augments two matrices `a` and `b` of matching dimensions\n     * (appends `b` to `a`).\n     */\n    public static augment(a: Matrix, b: Matrix): Matrix {\n        return a.copy().augment(b);\n    }\n\n    /**\n     * Static method. Multiplies two matrices `a` and `b` of matching dimensions.\n     */\n    public static multiply(a: Matrix, b: Matrix): Matrix {\n        return a.multiply(b);\n    }\n\n    /**\n     * Static method. Creates an `r x c` matrix containing zeros (`0`), takes an\n     * optional `type` argument which should be an instance of `TypedArray`.\n     */\n    public static zeros(r: number, c: number, type: TypedArrayConstructor = Float32Array): Matrix {\n        return Matrix.fill(r, c, 0, type);\n    }\n\n    /**\n     * Static method. Creates a `r x c` matrix containing optional 'value' (default 0), takes\n     * an optional `type` argument which should be an instance of `TypedArray`.\n     */\n    public static fill(\n        r: number,\n        c: number,\n        value: number | ((index: number) => number) = 0,\n        type: TypedArrayConstructor = Float32Array\n    ): Matrix {\n        if (r <= 0 || c <= 0) {\n            throw new Error('invalid size');\n        }\n\n        const size: number = r * c;\n        const data: TypedArray = new type(size);\n\n        return new Matrix(data, { shape: [r, c] }).fill(value);\n    }\n\n    public data: TypedArray = new Float32Array(0);\n    public length: number = 0;\n    public shape: number[] = [0];\n    public type: TypedArrayConstructor = Float32Array;\n\n    /**\n     * Static method. Creates an identity matrix of `size`, takes an optional `type` argument\n     * which should be an instance of `TypedArray`.\n     */\n    public static identity(size: number, type: TypedArrayConstructor = Float32Array): Matrix {\n        return Matrix.fill(size, size, (i: number) => i % size === Math.floor(i / size) ? 1 : 0, type);\n    }\n\n    constructor(data?: any, options?: any) {\n        if (typeof data === 'number' && typeof options === 'number') {\n            this._init(new Float32Array(data * options), { shape: [data, options] });\n        } else {\n            this._init(data, options);\n        }\n    }\n\n    private _init(\n        data?: any,\n        options?: {\n        shape: number[];\n        }\n    ) {\n        if (isTypedArray(data)) {\n            this.data = data as TypedArray;\n            this.shape = typeof options === 'object' ? options.shape : [this.data.length];\n            this.length = this.data.length;\n            this.type = type(data);\n        } else if (data instanceof Array) {\n            this.data = new Float32Array(flatten(data));\n            this.shape = shape(data);\n            this.length = this.data.length;\n        } else if (data instanceof Matrix) {\n            return data.copy();\n        }\n    }\n\n    public multiply(matrix: Matrix): Matrix {\n        const [r1, c1] = this.shape;\n        const [r2, c2] = matrix.shape;\n\n        if (c1 !== r2) {\n            throw new Error('sizes do not match');\n        }\n\n        const { data: d1 } = this;\n        const { data: d2 } = matrix;\n        const data: TypedArray = new this.type(r1 * c2);\n\n        let i: number;\n        let j: number;\n        let k: number;\n        let sum: number;\n        for (i = 0; i < r1; i += 1) {\n            for (j = 0; j < c2; j += 1) {\n                sum = 0;\n                for (k = 0; k < c1; k += 1) {\n                    sum += d1[i * c1 + k] * d2[j + k * c2];\n                }\n\n                data[i * c2 + j] = sum;\n            }\n        }\n\n        return new Matrix(data, { shape: [r1, c2] });\n    }\n\n    /**\n     * Adds `x` multiplied by `alpha` to the current array.\n     */\n    public add(x: Matrix, alpha: number = 1): this {\n        this.equilateral(x);\n        this.equidimensional(x);\n\n        const { data: d1, length: l1 } = this;\n        const { data: d2 } = x;\n\n        let i: number;\n        for (i = 0; i < l1; i += 1) {\n            d1[i] += alpha * d2[i];\n        }\n\n        return this;\n    }\n\n    /**\n     * Subtracts `x` to the current array.\n     */\n    public subtract(x: Matrix): this {\n        return this.add(x, -1);\n    }\n\n    /**\n     * Augments `matrix` with current matrix.\n     */\n    public augment(matrix: Matrix): Matrix {\n        const [r1, c1] = this.shape;\n        const [r2, c2] = matrix.shape;\n\n        if (r2 === 0 || c2 === 0) {\n            return this;\n        }\n\n        if (r1 !== r2) {\n            throw new Error('rows do not match');\n        }\n\n        const { data: d1 } = this;\n        const { data: d2 } = matrix;\n        const length: number = c1 + c2;\n        const data: TypedArray = new this.type(length * r1);\n\n        let i: number;\n        let j: number;\n        for (i = 0; i < r1; i += 1) {\n            for (j = 0; j < c1; j += 1) {\n                data[i * length + j] = d1[i * c1 + j];\n            }\n        }\n\n        for (i = 0; i < r2; i += 1) {\n            for (j = 0; j < c2; j += 1) {\n                data[i * length + j + c1] = d2[i * c2 + j];\n            }\n        }\n\n        this.shape = [r1, length];\n        this.length = data.length;\n        this.data = data;\n\n        return this;\n    }\n\n    /**\n     * Fills the array with a scalar value, takes an optional `type` argument\n     * which should be an instance of `TypedArray`.\n     */\n    public fill(value: number | ((index: number) => number) = 0): this {\n        const { data, length } = this;\n\n        let i: number;\n        for (i = 0; i < length; i += 1) {\n            data[i] = value instanceof Function ? value(i) : value;\n        }\n\n        return this;\n    }\n\n    /**\n     * Transposes a matrix (mirror across the diagonal).\n     */\n    public transpose(): Matrix {\n        const [r, c] = this.shape;\n        const data: TypedArray = new this.type(c * r);\n\n        let i: number;\n        let j: number;\n        for (i = 0; i < r; i += 1) {\n            for (j = 0; j < c; j += 1) {\n                data[j * r + i] = this.data[i * c + j];\n            }\n        }\n\n        return new Matrix(data, { shape: [c, r] });\n    }\n\n    /**\n     * Determines the inverse of any invertible square matrix using\n     * Gaussian elimination.\n     */\n    public inverse(): Matrix {\n        const [r, c] = this.shape;\n\n        if (r !== c) {\n            throw new Error('invalid dimensions');\n        }\n\n        const identity: Matrix = Matrix.identity(r);\n        const augmented: Matrix = Matrix.augment(this, identity);\n        const gauss: Matrix = augmented.gauss();\n        const left: Matrix = Matrix.zeros(r, c);\n        const right: Matrix = Matrix.zeros(r, c);\n\n        const n: number = gauss.shape[1];\n\n        let i: number;\n        let j: number;\n        for (i = 0; i < r; i += 1) {\n            for (j = 0; j < n; j += 1) {\n                if (j < c) {\n                    left.set(i, j, gauss.get(i, j));\n                } else {\n                    right.set(i, j - r, gauss.get(i, j));\n                }\n            }\n        }\n\n        if (!left.equals(Matrix.identity(r))) {\n            throw new Error('matrix is not invertible');\n        }\n\n        return right;\n    }\n\n    /**\n     * Performs Gaussian elimination on a matrix.\n     */\n    public gauss(): Matrix {\n        const [r, c] = this.shape;\n        const copy: Matrix = this.copy();\n\n        let lead: number = 0;\n        let pivot: number;\n        let leadValue: number;\n\n        let i: number;\n        let j: number;\n        let k: number;\n        for (i = 0; i < r; i += 1) {\n            if (c <= lead) {\n                throw new Error('matrix is singular');\n            }\n\n            j = i;\n            while (copy.data[j * c + lead] === 0) {\n                j += 1;\n                if (r === j) {\n                    j = i;\n                    lead += 1;\n\n                    if (c === lead) {\n                        throw new Error('matrix is singular');\n                    }\n                }\n            }\n\n            copy.swap(i, j);\n\n            pivot = copy.data[i * c + lead];\n            if (pivot !== 0) {\n                for (k = 0; k < c; k += 1) {\n                    copy.data[i * c + k] = copy.data[i * c + k] / pivot;\n                }\n            }\n\n            for (j = 0; j < r; j += 1) {\n                leadValue = copy.data[j * c + lead];\n                if (j !== i) {\n                    for (k = 0; k < c; k += 1) {\n                        copy.data[j * c + k] = copy.data[j * c + k] - copy.data[i * c + k] * leadValue;\n                    }\n                }\n            }\n\n            lead += 1;\n        }\n\n        for (i = 0; i < r; i += 1) {\n            pivot = 0;\n            for (j = 0; j < c; j += 1) {\n                if (pivot === 0) {\n                    pivot = copy.data[i * c + j];\n                }\n            }\n\n            if (pivot === 0) {\n                for (k = 0; k < c; k += 1) {\n                    copy.data[i * c + k] = copy.data[i * c + k] / pivot;\n                }\n            }\n        }\n\n        return copy;\n    }\n\n    /**\n     * Checks if current array and `x` are equal.\n     */\n    public equals(x: Matrix): boolean {\n        this.equilateral(x);\n        this.equidimensional(x);\n\n        const { data: d1, length: l1 } = this;\n        const { data: d2 } = x;\n\n        let i: number;\n        for (i = 0; i < l1; i += 1) {\n            if (d1[i] !== d2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if `i` and `j` is within the bounds for current matrix.\n     */\n    public check(i: number, j: number): void {\n        const [r, c] = this.shape;\n\n        if (isNaN(i) || isNaN(j)) {\n            throw new Error('one of the indices is not a number');\n        }\n\n        if (i < 0 || j < 0 || i > r - 1 || j > c - 1) {\n            throw new Error('index out of bounds');\n        }\n    }\n\n    /**\n     * Sets the element at row `i`, column `j` to value\n     */\n    public set(i: number, j: number, value: number): Matrix {\n        this.check(i, j);\n        this.data[i * this.shape[1] + j] = value;\n\n        return this;\n    }\n\n    /**\n     * Gets the value of the element in row `i`, column `j` of current matrix\n     */\n    public get(i: number, j: number): number {\n        this.check(i, j);\n\n        return this.data[i * this.shape[1] + j];\n    }\n\n    /**\n     * Swaps two rows `i` and `j` in a matrix\n     */\n    public swap(i: number, j: number): Matrix {\n        const [r, c] = this.shape;\n        if (i < 0 || j < 0 || i > r - 1 || j > r - 1) {\n            throw new Error('index out of bounds');\n        }\n\n        if(this.data.slice) {\n            const copy: TypedArray = this.data.slice(i * c, (i + 1) * c);\n            this.data.copyWithin(i * c, j * c, (j + 1) * c);\n            this.data.set(copy, j * c);\n        } else {\n            // IE 11 无 slice copyWithin 方法\n            const D:any = this.data.constructor;\n            const copy: TypedArray = new D(this.data.buffer.slice(0));\n            this.data.set(copy.subarray(i * c, (i + 1) * c), j * c);\n            this.data.set(copy.subarray(j * c, (j + 1) * c), i * c);\n        }\n\n        return this;\n    }\n    /**\n     * Makes a copy of the class and underlying data\n     */\n    public copy(): this {\n        const copy: Matrix = Object.assign(Object.create(Object.getPrototypeOf(this)), this) as Matrix;\n\n        copy.data = new this.type(this.data);\n        copy.shape = this.shape;\n        copy.length = this.length;\n        copy.type = this.type;\n\n        return copy as this;\n    }\n\n    /**\n     * Asserts if current array and `x` have the same shape\n     */\n    public equidimensional(x: Matrix): void {\n        const { shape: s1 } = this;\n        const { shape: s2 } = x;\n\n        if (!s1.every((dim: number, i: number) => dim === s2[i])) {\n            throw new Error(`shapes ${s1} and ${s2} do not match`);\n        }\n    }\n\n    /**\n     * Asserts if current array and `x` have the same length\n     */\n    public equilateral(x: Matrix): void {\n        const { length: l1 } = this;\n        const { length: l2 } = x;\n\n        if (l1 !== l2) {\n            throw new Error(`lengths ${l1} and ${l2} do not match`);\n        }\n    }\n}\n","import {EventEmitter} from 'events';\nimport {Log} from '../utils/log';\nimport {Matrix} from '../utils/matrix';\nimport AbrLevel from './abr-level';\nimport {AbrManifest} from './abr-manifest';\n\ntype AdaptiveConfig = {\n    beacon: boolean;\n    predictStep: number;\n    minBuffer: number; // 最小buffer长度\n    bufferOffset: number; // buffer抖动容忍\n    duration: number; // 切片长度\n    smoothRatioToTarget: number;\n    speedSmoothRatio: number;\n    switchPenalty: number;\n    slidingWindowSize: number;\n    kalmanR: number;\n    kalmanQ: number;\n    initBitrateLevel: number;\n    speedPredictNum: number;\n};\n\nconst tag = 'algorithm-flv';\n\nconst CONFIG: AdaptiveConfig = {\n    beacon: false, // 算法上报开关\n    predictStep: 5,\n    minBuffer: 0.2, // 最小buffer长度\n    bufferOffset: -1,\n    duration: 2, // 切片长度\n    smoothRatioToTarget: 0.25,\n    speedSmoothRatio: 0.5,\n    switchPenalty: 1.5 * 1e-6,\n    slidingWindowSize: 3,\n    kalmanR: 0.2 ** 2,\n    kalmanQ: 4e-4,\n    initBitrateLevel: 3, // 起播清晰度\n    speedPredictNum: 3, // 根据速度预测次数\n};\n\n/**\n * HLS自适应码率算法入口\n */\nclass AbrAlgorithm extends EventEmitter {\n    private MATRIX_E!: Matrix;\n    private MATRIX_G!: Matrix;\n\n    private _conf!: AdaptiveConfig;\n\n    private _xPrev: number = 0;\n    private _PPrev: number = 0;\n    private _pastBuffer!: number[];\n    private _pastThroughput!: number[];\n    private _levels!: AbrLevel[];\n    private _availableList?: number[];\n    private _current: number = 0; // 当前正在加载的流index\n    private _next: number = 0; // 下一个切换的流index\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * 初始化，并写入初始码率\n     * @param manifest 流信息\n     * @param config 算法配置\n     */\n    public init(manifest: AbrManifest, config?: any): void {\n        // TODO: config\n        this._processConfig(config);\n\n        Log.i(tag, 'init', manifest, config, this._conf);\n        this._levels = manifest.levels.slice(0);\n        // TODO: default与config.initBitrateLevel冲突\n        this._current = manifest.default;\n\n        // initialize the parameters\n        this._next = 0;\n        this._pastBuffer = [0, 0];\n        this._pastThroughput = new Array(this._conf.slidingWindowSize);\n        this._pastThroughput[this._conf.slidingWindowSize - 1] = 0;\n        // initialize the parameters of kalman filter\n        this._xPrev = 0;\n        this._PPrev = 0;\n        // matrix initialization\n        this.MATRIX_E = Matrix.zeros(\n            this._conf.predictStep,\n            this._conf.predictStep\n        );\n        this.MATRIX_G = Matrix.zeros(this._conf.predictStep, 2);\n\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            for (let j = 0; j < i + 1; j++) {\n                this.MATRIX_E.set(i, j, i - j + 1);\n            }\n        }\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            this.MATRIX_G.set(i, 0, i + 2);\n            this.MATRIX_G.set(i, 1, -i - 1);\n        }\n    }\n\n    /**\n     * 设置码率列表中的清晰度是否可用\n     * @param list 码率index列表\n     */\n    public setAvailableBitrates(list: number[]): void {\n        if (list.length) {\n            this._availableList = list;\n        }\n    }\n\n    /**\n     * 获取下一个清晰度\n     * @returns {number} 下个清晰度index\n     */\n    public get nextLevel(): number {\n        return this._next;\n    }\n\n    /**\n     * 收到关键帧\n     * @param buffered buffer长度（秒）\n     * @param size 下载长度\n     * @param time 下载耗时（秒）\n     */\n    public onGOP(buffered: number, size: number, time: number): void {\n        // Byte/s -> kbps: {x} * 1000 * 8 / 1024;\n        let speed = (size / time) * 8 / 1024;\n        this._next = this._nextRateIndex(\n            this._recentSpeed(speed),\n            buffered\n        );\n    }\n\n    /**\n     * 当开始加载新流\n     * @param index 清晰度index\n     */\n    public onLevelLoad(index: number): void {\n        this._current = Math.max(0, index);\n    }\n\n    /**\n     * 处理传入配置，与默认配置合并\n     * @param config 配置\n     */\n    private _processConfig(config?: any): void {\n        const c = Object.assign({}, CONFIG);\n        this._conf = Object.assign(c, config);\n    }\n\n    private _quantization(bitrate: number, speed: number): number {\n        let index = this._current;\n        for (let i = this._levels.length - 1; i >= 0; i--) {\n            if (bitrate >= this._levels[i].bitrate) {\n                index = i;\n                break;\n            }\n        }\n        if (index > this._current && speed < this._levels[index].bitrate) {\n            index -= 1;\n        }\n        return index;\n    }\n\n    /**\n     * 计算下一个使用的码率\n     * @param value 下载速度 kpbs\n     * @param buffered 当前buffer ms\n     */\n    private _nextRateIndex(value: number, buffered: number): number {\n        this._pastThroughput.shift();\n        this._pastThroughput.push(value);\n\n        let index = this._nextRateBySpeedAndBuffered(value, buffered);\n        if (index >= this._current) {\n            this._pastBuffer.shift();\n            this._pastBuffer.push(buffered);\n        } else {\n            this._pastBuffer = [buffered, buffered];\n        }\n\n        if (\n            this._availableList &&\n            this._availableList.length &&\n            this._availableList.indexOf(index) === -1\n        ) {\n            for (let i = this._availableList.length - 1; i >= 0; i--) {\n                if (this._availableList[i] <= index) {\n                    index = this._availableList[i];\n                    break;\n                }\n            }\n            index = Math.max(index, this._availableList[0]);\n        }\n        return index;\n    }\n\n    /**\n     * 重置算法\n     */\n    private _resetAlgorithm() {\n        this._pastBuffer = [0, 0];\n        this._pastThroughput = new Array(this._conf.slidingWindowSize);\n    }\n\n    /**\n     * 获取最近buffer水平\n     */\n    private _recentBuffer(): number {\n        return this._pastBuffer.reduce((a, b) => a + b) / this._pastBuffer.length;\n    }\n\n    /**\n     * 获取最近带宽水平\n     */\n    private _recentSpeed(value: number): number {\n        const speed = this._pastThroughput[this._pastThroughput.length - 1];\n        if (speed > 0) {\n            return speed * this._conf.speedSmoothRatio + value * (1 - this._conf.speedSmoothRatio);\n        }\n        return value;\n    }\n\n    /**\n     * 依据最近buffer水平，设置Target Buffer\n     */\n    private _adjustedTargetBuffer(): number {\n        const targetBuffer = Math.max(this._conf.minBuffer, this._recentBuffer() + this._conf.bufferOffset);\n        Log.v(tag, `targetBuffer:${targetBuffer}`);\n        return targetBuffer;\n    }\n\n    /**\n     * 计算码率变化值\n     * @param switchPenaltyArray 切换代价\n     * @param estimatedThroughput 预估带宽\n     * @param Bk 目标buffer水平\n     * @param br 预测buffer水平\n     */\n    private _rateChangeArray(switchPenaltyArray: Matrix, estimatedThroughput: number[], Bk: Matrix, br: number[]): any {\n        const targetBufferArray = new Matrix(br);\n        this._printFirstColumn(targetBufferArray, 'targetBufferArray');\n\n        const matrixG = this.MATRIX_G;\n        const predictedBufferArray = Matrix.multiply(matrixG, Bk);\n        this._printFirstColumn(predictedBufferArray, 'predictedBufferArray');\n\n        const matrixE = this.MATRIX_E;\n        const matrixF = matrixE.multiply(this._diag(estimatedThroughput));\n        return Matrix.multiply(\n            Matrix.multiply(\n                Matrix.add(\n                    Matrix.multiply(matrixF.transpose(), matrixF),\n                    switchPenaltyArray\n                ).inverse(),\n                matrixF.transpose()\n            ),\n            Matrix.subtract(targetBufferArray, predictedBufferArray)\n        );\n    }\n\n    /**\n     * 根据下载速度和buffer长度计算下一个码率\n     * @param speed 下载速度 kbps\n     * @param buffered 当前buffer ms\n     */\n    private _nextRateBySpeedAndBuffered(\n        speed: number,\n        buffered: number\n    ): number {\n        const switchPenaltyArray = Matrix.zeros(\n            this._conf.predictStep,\n            this._conf.predictStep\n        );\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            switchPenaltyArray.set(\n                i,\n                i,\n                this._conf.switchPenalty * (this._conf.predictStep - i)\n            );\n        }\n\n        const futureThroughput = this._multistepPred(\n            this._pastThroughput,\n            this._conf.predictStep\n        );\n        // const result = this._multistepKalmanfilter(\n        //     this._xPrev,\n        //     this._pastThroughput[this._pastThroughput.length - 1],\n        //     this._PPrev,\n        //     this._conf.predictStep\n        // );\n        // const futureThroughput = result.futureThroughput;\n        // this._xPrev = result.xRet;\n        // this._PPrev = result.PRet;\n        Log.v(tag, `futureThroughput:${futureThroughput}`);\n        const estimatedThroughput = futureThroughput.map(item => {\n            return -(this._conf.duration / item);\n        });\n\n        const Bk = new Matrix([[buffered], [this._recentBuffer()]]);\n\n        const br: any[] = [];\n        br[0] = [buffered];\n        const target = this._adjustedTargetBuffer();\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            br[i + 1] = [\n                this._conf.smoothRatioToTarget * br[i] +\n                (1 - this._conf.smoothRatioToTarget) * target\n            ];\n        }\n        const rateChangeArray = this._rateChangeArray(switchPenaltyArray, estimatedThroughput, Bk, br.slice(1));\n        Log.v(\n            tag,\n            `algorithm input speed:${speed} buffered:${buffered}`,\n            `output result:${rateChangeArray.get(0, 0)}`\n        );\n        return this._quantization(\n            (this._levels[this._current].bitrate + rateChangeArray.get(0, 0)),\n            speed\n        );\n    }\n\n    private _printFirstColumn(matrix: Matrix, name: string) {\n        let out = [];\n        for (let i = 0; i < matrix.shape[0]; ++i) {\n            out[i] = +matrix.get(i, 0).toFixed(2);\n        }\n        Log.v(tag, name, JSON.stringify(out));\n    }\n\n    private _printFirstRow(matrix: Matrix, name: string) {\n        let out = [];\n        for (let i = 0; i < matrix.shape[0]; ++i) {\n            out[i] = +matrix.get(0, i).toFixed(2);\n        }\n        Log.v(tag, name, JSON.stringify(out));\n    }\n\n    private _diag(arr: any[]): Matrix {\n        const dist = [],\n            len = arr.length;\n        for (let i = 0; i < len; i++) {\n            dist[i] = new Array(len);\n            for (let j = 0; j < len; j++) {\n                dist[i][j] = 0;\n            }\n            dist[i][i] = arr[i];\n        }\n        return new Matrix(dist, { shape: [len, len] });\n    }\n\n    private _multistepPred(\n        pastThroughput: number[],\n        predictStep: number\n    ): number[] {\n        const futureThroughput = new Array(predictStep);\n        const pastThroughputClone = pastThroughput.slice(0);\n        for (let i = 0; i < predictStep; i++) {\n            let bandwidthSum = 0,\n                nonzeroCnt = 0;\n            for (let j = 0; j < pastThroughput.length; j++) {\n                if (pastThroughputClone[j]) {\n                    bandwidthSum += 1.0 / pastThroughputClone[j];\n                    nonzeroCnt += 1;\n                }\n            }\n            if (nonzeroCnt === 0) {\n                continue;\n            } else {\n                futureThroughput[i] = 1.0 / (bandwidthSum / nonzeroCnt);\n            }\n            pastThroughputClone.shift();\n            pastThroughputClone.push(futureThroughput[i]);\n        }\n        return futureThroughput;\n    }\n\n    private _multistepKalmanfilter(\n        xLast: number,\n        z: number,\n        PLast: number,\n        predictStep: number\n    ) {\n        const R = this._conf.kalmanR,\n            Q = this._conf.kalmanQ;\n        const futureThroughput = new Array(this._conf.predictStep);\n        let xPrev = xLast,\n            PPrev = PLast,\n            xRet = 0,\n            PRet = 0;\n        for (let i = 0; i < predictStep; i++) {\n            const xMinus = xPrev,\n                PMinus = PPrev + Q,\n                K = PMinus / (PMinus + R),\n                predX = xMinus + K * (z - xMinus),\n                P = (1 - K) * PMinus;\n            if (i === 0) {\n                xRet = predX;\n                PRet = P;\n            }\n            futureThroughput[i] = predX;\n            xPrev = predX;\n            PPrev = P;\n        }\n        return { futureThroughput, xRet, PRet };\n    }\n}\n\nexport default AbrAlgorithm;\n","import LasEvents from '../core/events';\nimport Media from '../core/media';\nimport Observer from '../core/observer';\nimport { AbrConfig } from '../types/core';\nimport AbrAlgorithm from './abr-algorithm';\nimport { abrGetUrl } from './abr-get-url';\nimport AbrLevel from './abr-level';\nimport { AbrManifest } from './abr-manifest';\n\nexport type MultirateItem = {\n    url: string;\n    level: number;\n}\n/**\n * 多码率及自适应码率\n */\nclass Multirate extends Observer {\n    private _config: AbrConfig;\n    private _media: Media;\n    private _next: number = 0;\n    private _downloadSize: number = 0;\n    private _downloadStartTime: number = 0;\n    private _keyCount: number = 0;\n    private _index: number = 0;\n    private _alg: AbrAlgorithm;\n    private _manifest: AbrManifest;\n    private _autoLevelEnabled: boolean = false;\n\n    constructor(config: AbrConfig, media: Media) {\n        super();\n        this._config = config;\n        this._media = media;\n        this._manifest = new AbrManifest(config.manifest);\n        this._alg = new AbrAlgorithm();\n        this._alg.init(this._manifest);\n        this._autoLevelEnabled = this._manifest.abrLevels.length > 0\n    }\n\n    /**\n     * 初始化flv多码率\n     */\n    public init(): void {\n        this._downloadSize = 0;\n        this._downloadStartTime = performance.now();\n\n        // 当前流收到I帧计数\n        this._keyCount = 0;\n        this._index = this._next = 0;\n\n        if (this.current) {\n            if (this._autoLevelEnabled) {\n                this._index = this._next = this._alg.nextLevel;\n            }\n            this.trigger(LasEvents.MANIFEST_PARSED, {\n                levels: this._manifest.levels,\n                currentLevel: this._index\n            });\n        }\n    }\n\n    public destory(): void {\n        if (this._alg) {\n            this._alg.removeAllListeners();\n        }\n    }\n\n    public onLoaderChunk(size: number): void {\n        this._downloadSize += size;\n    }\n\n    public onLevelLoad(index: number) {\n        if (this._manifest.levels.length && index >= 0 && index < this._manifest.levels.length) {\n            this._keyCount = 0;\n            this._index = index;\n            this._downloadStartTime = performance.now();\n            this._downloadSize = 0;\n            this._alg.onLevelLoad(index);\n        }\n    }\n\n    /**\n     * 处理关键帧，是否切换码率\n     * @param time flv tag timestamp\n     */\n    public onKeyFrame(time: number): MultirateItem | undefined {\n        let levels = this._manifest.levels;\n        this._keyCount++;\n\n        if ((this._alg || this._next !== this._index) && this._keyCount > 1 && levels) {\n            let next = this._index;\n            if (this._next !== this._index) {\n                // 平滑切换\n                next = this._next;\n            } else if (this._autoLevelEnabled) {\n                // 自动\n                let now = performance.now();\n                this._alg.onGOP(this._media.bufferedSec(), this._downloadSize, (now - this._downloadStartTime) / 1000);\n                this._downloadSize = 0;\n                this._downloadStartTime = now;\n                this._next = next = this._alg.nextLevel;\n            } else {\n                return;\n            }\n            // TEST:\n            // next = (this._index + 1) % levels.length;\n            if (next !== this._index) {\n                return {\n                    url: this._getRequestUrl(next, time),\n                    level: next,\n                }\n            }\n        }\n        return;\n    }\n\n    public get autoLevelEnabled(): boolean {\n        return this._autoLevelEnabled;\n    }\n\n    /**\n     * 清晰度列表\n     */\n    public get levels(): AbrLevel[] {\n        return this._manifest.levels;\n    }\n\n    public get nextLevel(): number {\n        if (typeof this._next === 'number') {\n            return this._next;\n        } else {\n            return this._index;\n        }\n    }\n\n    public set nextLevel(value: number) {\n        if (value >= 0 && this._manifest.levels.length > value) {\n            this._autoLevelEnabled = false;\n            this._next = value;\n        } else if (value === -1) {\n            this._autoLevelEnabled = true;\n        }\n    }\n\n    public get currentLevel(): number {\n        return this._index;\n    }\n\n    public set currentLevel(value: number) {\n        if (value >= 0 && this._manifest.levels.length > value) {\n            this._autoLevelEnabled = false;\n            this._index = this._next = value;\n        } else if (value === -1) {\n            this._autoLevelEnabled = true;\n        }\n    }\n\n    private get current(): AbrLevel | undefined {\n        return this._manifest.levels[this._index];\n    }\n\n    /**\n     * 获取切换flv的请求地址\n     * @param index 码率index\n     * @param spts 切换时间戳，单位毫秒。大于0：关键帧pts；小于0：直播延迟\n     */\n    private _getRequestUrl(index: number, spts?: number): string {\n        let url = this._config.src;\n        let level = this._manifest.levels[index];\n        if (level) {\n            url = level.url;\n        }\n        return abrGetUrl(url, spts || this._config.defaultSpts);\n    }\n}\n\nexport default Multirate;\n","/**\n * Uint8Array数据缓存\n */\nclass Cache {\n    // 100m = 104857600 = 100 * 1024 * 1024\n    public static MAX_CACHE_SIZE = 104857600;\n    public static DEFAULT_CACHE_SIZE = 3145728;\n    // 初始cache大小\n    private _size: number;\n    private _readOffset: number = 0;\n    private _writeOffset: number = 0;\n    // cache\n    private _storage: ArrayBuffer;\n    private _cache: Uint8Array;\n\n    constructor(size: number = 0) {\n        if (size > 0) {\n            this._size = size;\n        } else {\n            this._size = Cache.DEFAULT_CACHE_SIZE;\n        }\n        this._storage = new ArrayBuffer(this._size);\n        this._cache = new Uint8Array(this._storage);\n    }\n\n    /**\n     * 添加至cache\n     * @param chunk 数据\n     */\n    public put(chunk: Uint8Array): void {\n        if (this._readOffset === this._writeOffset) {\n            this._readOffset = this._writeOffset = 0;\n        }\n        if (this._writeOffset + chunk.byteLength > this._size) {\n            const expected = this._writeOffset + chunk.byteLength - this._readOffset;\n            if (expected > this._size) {\n                // 扩展\n                this._collateCache();\n                this.expandCache(expected);\n            } else {\n                // 整理buffer\n                this._collateCache();\n            }\n        }\n        this._cache.set(chunk, this._writeOffset);\n        this._writeOffset += chunk.byteLength;\n    }\n\n    /**\n     * 获取数据拷贝\n     * @param len 数据长度\n     * @returns 数据\n     */\n    public get(len: number): Uint8Array | null {\n        if (len + this._readOffset > this._writeOffset) {\n            return null;\n        }\n        let data = null;\n        if (this._cache.slice) {\n            data = this._cache.slice(this._readOffset, this._readOffset + len);\n        } else {\n            const offset = this._cache.byteOffset + this._readOffset;\n            data = new Uint8Array(this._storage.slice(offset, offset + len));\n        }\n        this._readOffset += len;\n        return data;\n    }\n\n    /**\n     * 获取数据读取Uint8Array，从cache中直接读取，异步使用可能出现故障\n     * @param len 长度\n     * @returns 数据\n     */\n    public read(len: number): Uint8Array | null {\n        if (len + this._readOffset > this._writeOffset) {\n            return null;\n        }\n        return new Uint8Array(this._storage, this._readOffset, len);\n    }\n\n    /**\n     * 后移读指针\n     * @param len 数据长度\n     */\n    public skip(len: number): void {\n        if (len + this._readOffset > this._writeOffset) {\n            return;\n        }\n        this._readOffset += len;\n    }\n\n    /**\n     * 清理\n     */\n    public clear(): void {\n        this._readOffset = this._writeOffset = 0;\n    }\n\n    /**\n     * 扩展cache，cache不足时，cache容量max(翻倍,预期)\n     * @param expected 预期最小值\n     */\n    public expandCache(expected: number = 0): void {\n        this._size = Math.max(this._size * 2, expected);\n        if (this._size >= Cache.MAX_CACHE_SIZE) {\n            throw new Error('max cache size');\n        }\n        if (this._readOffset === 0 && this._writeOffset === 0) {\n            this._storage = new ArrayBuffer(this._size);\n        } else {\n            this._storage = this._transfer(this._storage, this._size);\n        }\n        this._cache = new Uint8Array(this._storage);\n    }\n\n    /**\n     * 未读取数据长度\n     */\n    public get unreadLen(): number {\n        return this._writeOffset - this._readOffset;\n    }\n\n    /**\n     * 整理cache中的数据，抛弃已读取的数据\n     */\n    private _collateCache(): void {\n        const remain = new Uint8Array(this._storage, this._readOffset, this._writeOffset - this._readOffset);\n        this._cache.set(remain);\n        this._writeOffset -= this._readOffset;\n        this._readOffset = 0;\n    }\n\n    private _transfer(source: ArrayBuffer, length: number): ArrayBuffer {\n        if (!(source instanceof ArrayBuffer)) {\n            throw new TypeError('Source must be an instance of ArrayBuffer');\n        }\n        if (length <= source.byteLength) {\n            return source.slice(0, length);\n        }\n        const sourceView = new Uint8Array(source),\n            destView = new Uint8Array(new ArrayBuffer(length));\n        destView.set(sourceView);\n        return destView.buffer;\n    }\n}\n\nexport default Cache;\n","import { IBaseLoader, ILoaderContext, IBaseLoaderCallback } from '../types/io';\nexport enum XHR_TYPE {\n    MOZ_CHUNK = 'moz-chunked-arraybuffer',\n    MS_STREAM = 'ms-stream',\n    UNKNOW = 'unknow',\n    UNSUPPORT = ''\n}\n\n/**\n * XhrLoader\n * @class XhrLoader\n */\nexport class XHR implements IBaseLoader<ILoaderContext> {\n    private static supportChunk: XHR_TYPE = XHR_TYPE.UNKNOW;\n\n    public tag: string = 'xhr';\n    private _xhr: XMLHttpRequest | null = null;\n    private _context!: ILoaderContext;\n    private _callbacks: IBaseLoaderCallback<ILoaderContext> | null = null;\n    private _reader: MSStreamReader | null = null;\n    private _msBufferOffset: number = 0;\n    private _msBufferUpper: number = 16 * 1024 * 1024; // 16MB\n    private _progress: XHR_TYPE = XHR_TYPE.UNKNOW;\n\n    static isSupportChunk() {\n        if (XHR.supportChunk !== XHR_TYPE.UNKNOW) {\n            return XHR.supportChunk;\n        }\n        try {\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            (xhr.responseType as any) = XHR_TYPE.MOZ_CHUNK;\n            if ((xhr.responseType as any) === XHR_TYPE.MOZ_CHUNK) {\n                XHR.supportChunk = XHR_TYPE.MOZ_CHUNK;\n                return XHR.supportChunk;\n            }\n        } catch (e) {\n            XHR.supportChunk = XHR_TYPE.UNSUPPORT;\n        }\n        try {\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            (xhr.responseType as any) = XHR_TYPE.MS_STREAM;\n            if ((xhr.responseType as any) === XHR_TYPE.MS_STREAM) {\n                XHR.supportChunk = XHR_TYPE.MS_STREAM;\n                return XHR.supportChunk;\n            }\n        } catch (e) {\n            XHR.supportChunk = XHR_TYPE.UNSUPPORT;\n        }\n        return XHR_TYPE.UNSUPPORT;\n    }\n\n    constructor() {\n        this._xhr = null;\n        this._msBufferOffset = 0;\n    }\n\n    /**\n     * 开始加载\n     * @param context\n     * @param callbacks\n     */\n    load(context: ILoaderContext, callbacks: IBaseLoaderCallback<ILoaderContext>) {\n        this._callbacks = callbacks;\n        this._context = context;\n        this._progress = XHR_TYPE.UNSUPPORT;\n        if (context.progress && context.responseType === 'arraybuffer') {\n            this._progress = XHR.isSupportChunk();\n            if (this._progress === XHR_TYPE.MS_STREAM) {\n                const reader = this._reader = new (self as any).MSStreamReader();\n                reader.onprogress = this._msrOnProgress.bind(this);\n                reader.onload = this._onLoadEnd.bind(this);\n                reader.onerror = this._onError.bind(this);\n            }\n        }\n\n        const xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', this._context.url, true);\n        // arraybuffer类型尝试使用chunk\n        if (this._progress === XHR_TYPE.MOZ_CHUNK) {\n            (xhr.responseType as any) = XHR_TYPE.MOZ_CHUNK;\n            xhr.onprogress = this._onProgress.bind(this);\n            xhr.onload = this._onLoadEnd.bind(this);\n        } else if (this._progress === XHR_TYPE.MS_STREAM) {\n            (xhr.responseType as any) = XHR_TYPE.MS_STREAM;\n        } else {\n            (xhr.responseType as any) = context.responseType || 'arraybuffer';\n            xhr.onload = this._onLoadEnd.bind(this);\n        }\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onerror = this._onError.bind(this);\n        xhr.withCredentials = !!context.credentials;\n\n        if (context.range) {\n            xhr.setRequestHeader('Range', context.range);\n        }\n        xhr.send();\n    }\n\n    /**\n     * abort request\n     */\n    abort() {\n        if (this._reader) {\n            // 0 EMPTY 1 LOADING 2 DONE\n            if (this._reader.readyState === 1) {\n                this._reader.abort();\n            }\n            this._reader.onprogress = null;\n            this._reader.onload = null;\n            this._reader.onerror = null;\n            this._reader = null;\n        }\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr.onprogress = null;\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr.abort();\n            this._xhr = null;\n        }\n    }\n\n    /**\n     * destroy xhr Object clean cache\n     */\n    destroy() {\n        this._callbacks = null;\n        this.abort();\n    }\n\n    _onReadyStateChange(e: Event) {\n        if (!this._xhr) {\n            return;\n        }\n        const xhr = this._xhr;\n        if (xhr.readyState === 2) {\n            this._context.responseUrl = xhr.responseURL;\n            this._context.responseHeader = xhr.getAllResponseHeaders();\n            if (this._callbacks && this._callbacks.onConnect) {\n                this._callbacks.onConnect(xhr.status);\n            }\n            if (xhr.status < 200 || xhr.status > 299) {\n                this._onError(new Error('xhr error'));\n            }\n        } else if (xhr.readyState === 3) {\n            if (this._reader && this._reader.readyState === 0 && xhr.status >= 200 && xhr.status <= 299) {\n                this._reader.readAsArrayBuffer(xhr.response);\n            }\n        }\n    }\n\n    /**\n     * xhr onProgress\n     * @param {*} e xhr回调数据\n     */\n    _onProgress(e: Event) {\n        if (!this._xhr) {\n            return;\n        }\n        const chunk = this._xhr.response;\n        if (this._callbacks && this._callbacks.onProgress && chunk) {\n            this._callbacks.onProgress(this._context, chunk);\n        }\n    }\n\n    /**\n     * ms-stream progress\n     * @param {*} e MSStreamReader回调\n     */\n    _msrOnProgress(e: any) {\n        const reader = e.target;\n        const buffer = reader.result;\n        if (!buffer) {\n            // result may be null, workaround for buggy M$\n            this._onError(new Error('ms buffer null'));\n            return;\n        }\n\n        const chunk = buffer.slice(this._msBufferOffset);\n        this._msBufferOffset = buffer.byteLength;\n\n        if (this._callbacks && this._callbacks.onProgress) {\n            this._callbacks.onProgress(this._context, chunk);\n        }\n\n        if (buffer.byteLength >= this._msBufferUpper) {\n            this._onError(new Error('ms buffer too large'));\n        }\n    }\n\n    /**\n     * xhr onLoadEnd\n     * @param {*} e xhr回调数据\n     */\n    _onLoadEnd(e: ProgressEvent) {\n        let data = null;\n        const target = this._xhr;\n        if (!this._progress && target) {\n            data = target.response;\n        }\n        if (this._callbacks) {\n            this._callbacks.onEnd(this._context, data);\n        }\n    }\n\n    /**\n     * xhr onXhrError\n     * @param {*} e xhr回调数据\n     * @private\n     */\n    _onError(e: any) {\n        if (this._callbacks && this._callbacks.onError) {\n            this._callbacks.onError(e);\n        }\n    }\n}\n","import { ErrorDetails, ErrorTypes } from '../../core/errors';\nimport LasEvents from '../../core/events';\nimport Observer from '../../core/observer';\nimport Cache from '../../io/cache';\nimport { FlvSize, FlvTag, FlvTagType } from \"./flv\";\n\nexport type AbrCallback = (time: number) => any;\n\ntype Result = {\n    list: FlvTag[];\n    abr?: any;\n}\n\nclass FlvTagDump {\n    private _observer: Observer;\n    private _cache: Cache;\n    private _tag?: FlvTag;\n    private _result: Result;\n\n    private _parseLen: number = 0;\n    private _parseFunc: Function;\n    private _onAbr: AbrCallback;\n\n    constructor(observer: Observer, onAbr: AbrCallback) {\n        this._observer = observer;\n        this._onAbr = onAbr;\n        this._cache = new Cache();\n        this._parseLen = FlvSize.FLV_HEAD_LEN;\n        this._parseFunc = this._parseFlvHead;\n        this._result = { list: [] };\n    }\n\n    public reset(): void {\n        this._parseLen = FlvSize.FLV_HEAD_LEN;\n        this._parseFunc = this._parseFlvHead;\n        this._cache.clear();\n        this._tag = undefined;\n        this._result.list = [];\n        this._result.abr = undefined;\n    }\n\n    public append(input: ArrayBuffer): Result {\n        this._cache.put(new Uint8Array(input));\n        while (this._cache.unreadLen > this._parseLen) {\n            this._parseFunc();\n        }\n        let data = { list: this._result.list.splice(0), abr: this._result.abr }\n        this._result.abr = undefined;\n        return data;\n    }\n\n    /**\n     * 解析tag头\n     */\n    private _parseFlvHead(): void {\n        const data = this._cache.read(FlvSize.FLV_HEAD_LEN);\n        if (data) {\n            if (data[0] !== 0x46 || data[1] !== 0x4c || data[2] !== 0x56 || data[3] !== 0x01) {\n                this._observer.trigger(LasEvents.ERROR, {\n                    type: ErrorTypes.MUX_ERROR,\n                    details: ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: wrong head'\n                });\n            }\n            this._observer.trigger(LasEvents.FLV_HEAD, {\n                hasAudio: (data[4] & 4) >>> 2,\n                hasVideo: (data[4] & 1)\n            });\n            // TEST:\n            // this._observer.trigger(KEvents.FLV_HEAD, {\n            //     hasAudio: true,\n            //     hasVideo: true\n            // });\n\n            this._cache.skip(FlvSize.FLV_HEAD_LEN);\n            this._parseLen = FlvSize.FLV_TAG_HEAD_LEN;\n            this._parseFunc = this._parseFlvTagHead;\n        }\n    }\n\n    /**\n     * 解析flv tag head\n     */\n    private _parseFlvTagHead(): void {\n        this._tag = new FlvTag();\n        const data = this._cache.read(FlvSize.FLV_TAG_HEAD_LEN);\n        if (data) {\n            // 取出tag类型\n            this._tag.tagType = data[0];\n            // 取出包体大小\n            this._tag.dataSize = ((data[1] & 0xff) << 16) + ((data[2] & 0xff) << 8) + (data[3] & 0xff);\n            // 取出解码时间\n            this._tag.timestamp =\n                ((data[7] & 0xff) << 24) + ((data[4] & 0xff) << 16) + ((data[5] & 0xff) << 8) + (data[6] & 0xff);\n            this._cache.skip(FlvSize.FLV_TAG_HEAD_LEN);\n            // 尝试在处理完整个tag之前判断是否为关键帧，用于自适应码率\n            if (this._tag.tagType === FlvTagType.VIDEO) {\n                this._parseFunc = this._detectKeyFrame;\n                this._parseLen = FlvSize.AVC_KEY_FRAME_CHECK_LEN;\n            } else {\n                this._parseFunc = this._parseFlvTag;\n                this._parseLen = this._tag.dataSize + FlvSize.FLV_TAG_SIZE_LEN;\n            }\n        }\n    }\n\n    /**\n     * 检测关键帧\n     */\n    private _detectKeyFrame(): void {\n        const data = this._cache.read(2);\n        if (data && this._tag) {\n            const frameType = (data[0] & 240) >>> 4;\n            const packetType = data[1];\n            this._parseFunc = this._parseFlvTag;\n            this._parseLen = this._tag.dataSize + FlvSize.FLV_TAG_SIZE_LEN;\n            // 获取是否是关键帧\n            if (frameType === 1 && packetType === 1 && this._onAbr) {\n                this._result.abr = this._onAbr(this._tag.timestamp);\n                if (this._result.abr) {\n                    this._parseLen = FlvSize.FLV_HEAD_LEN;\n                    this._parseFunc = this._parseFlvHead;\n                    this._cache.clear();\n                    this._tag = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * 解析flv tag\n     */\n    private _parseFlvTag(): void {\n        const tag = this._tag;\n        if (!tag) {\n            return;\n        }\n        if (tag.tagType === FlvTagType.SCRIPT || tag.tagType === FlvTagType.AUDIO || tag.tagType === FlvTagType.VIDEO) {\n            tag.body = this._cache.get(tag.dataSize);\n            this._cache.skip(4); // skip size\n            if (tag)\n                this._result.list.push(tag);\n            this._tag = undefined;\n        }\n        this._parseFunc = this._parseFlvTagHead;\n        this._parseLen = FlvSize.FLV_TAG_HEAD_LEN;\n    }\n}\n\nexport default FlvTagDump;\n","import { IBaseLoader, ILoaderContext, IBaseLoaderCallback } from '../types/io';\n/**\n * FetchLoader\n */\nexport default class FetchLoader implements IBaseLoader<ILoaderContext> {\n    public tag: string = 'fetch';\n    private _context!: ILoaderContext;\n    private _callbacks: IBaseLoaderCallback<ILoaderContext> | null = null;\n    private _controller: AbortController | null = null;\n    private _reader: ReadableStreamReader | null = null;\n    private _abort: boolean = false;\n\n    /**\n     * broswer is support moz-chunk\n     * @returns 是否支持\n     */\n    static isSupport(): boolean {\n        if (self.fetch && self.ReadableStream) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * 开始加载\n     * @param context context\n     * @param callbacks 回调\n     */\n    load(context: ILoaderContext, callbacks: IBaseLoaderCallback<ILoaderContext>) {\n        this._context = context;\n        this._callbacks = callbacks;\n\n        const reqHeaders = new Headers();\n        if (context.headers) {\n            context.headers.forEach(element => {\n                reqHeaders.append(element.header, element.value);\n            });\n        }\n        if (context.range) {\n            reqHeaders.append('Range', context.range);\n        }\n        const params: RequestInit = {\n            method: 'GET',\n            headers: reqHeaders,\n            mode: 'cors',\n            cache: 'default',\n            referrerPolicy: 'no-referrer-when-downgrade',\n            signal: this._getAbortSignal()\n        };\n        if (context.credentials) {\n            params.credentials = 'include';\n        }\n        fetch(context.url, params)\n            .then(res => {\n                context.responseUrl = res.url;\n                context.responseHeader = res.headers;\n                if (this._callbacks && this._callbacks.onConnect) {\n                    this._callbacks.onConnect(res.status);\n                }\n                if (res.ok) {\n                    // 兼容AbortController不可用\n                    if (this._abort) {\n                        if (res.body) {\n                            res.body.getReader().cancel();\n                        }\n                        return;\n                    }\n                    if (context.responseType === 'arraybuffer') {\n                        if (context.progress) {\n                            if (res.body) {\n                                this._reader = res.body.getReader();\n                                this._pump(this._reader);\n                            }\n                            return;\n                        }\n                        res.arrayBuffer().then(responseData => {\n                            this._onEnd(context, responseData);\n                        });\n                        return;\n                    }\n                    res.text().then(responseData => {\n                        this._onEnd(context, responseData);\n                    });\n                    return;\n                }\n                const error = new Error(res.status + ' ' + res.statusText);\n                this._onError(error);\n                return;\n            })\n            .catch(e => {\n                // 忽略AbortError，避免与timeout手动abort冲突\n                if (e.name !== 'AbortError') {\n                    this._onError(e);\n                }\n            });\n    }\n\n    abort() {\n        if (this._controller) {\n            this._controller.abort();\n        } else if (this._reader) {\n            this._reader.cancel();\n            this._reader = null;\n        }\n        this._abort = true;\n    }\n\n    destroy() {\n        this._callbacks = null;\n        this.abort();\n    }\n\n    _onProgress(context: ILoaderContext, chunk: ArrayBuffer) {\n        if (this._callbacks && this._callbacks.onProgress) {\n            this._callbacks.onProgress(context, chunk);\n        }\n    }\n\n    _onEnd(context: ILoaderContext, responseData: ArrayBuffer | string | null) {\n        if (this._callbacks && this._callbacks.onEnd) {\n            this._reader = null;\n            this._controller = null;\n            this._callbacks.onEnd(context, responseData);\n        }\n    }\n\n    _onError(e: Error) {\n        if (this._callbacks && this._callbacks.onError) {\n            this._callbacks.onError(e);\n        }\n    }\n\n    /**\n     * pump data\n     * @param reader 读取数据\n     * @private\n     */\n    _pump(reader: ReadableStreamReader) {\n        reader\n            .read()\n            .then(result => {\n                if (this._abort) {\n                    reader.cancel();\n                    return null;\n                }\n                if (result.done) {\n                    this._onEnd(this._context, null);\n                    return null;\n                }\n                const chunk = result.value.buffer;\n                this._onProgress(this._context, chunk);\n                return this._pump(reader);\n            })\n            .catch((e: Error) => {\n                if (e.name !== 'AbortError') {\n                    this._onError(e);\n                }\n            });\n    }\n\n    _getAbortSignal(): AbortSignal | null {\n        try {\n            if (AbortController) {\n                this._controller = new AbortController();\n                return this._controller.signal;\n            }\n        } catch (e) {\n            return null;\n        }\n        return null;\n    }\n}\n","import Browser from '../utils/browser';\nimport FetchLoader from './fetch';\nimport { XHR } from './xhr';\nimport { Log } from '../utils/log';\nimport {\n    IBaseLoader,\n    ILoaderContext,\n    IBaseLoaderCallback,\n    ILoaderCallback,\n    ILoaderStats,\n    ILoaderConfig,\n    ILoader\n} from '../types/io';\n\nlet ChunkLoader: any;\nlet index: number = 0;\n/**\n * 加载器封装\n * @param  {object} video config\n */\nexport default class Loader<T extends ILoaderContext> implements ILoader<T> {\n    public tag: string = 'loader';\n    public context!: T;\n    private _loader: IBaseLoader<T> | null;\n    protected _callbacks: ILoaderCallback<T> | null = null;\n    protected _config: ILoaderConfig;\n    private _loaderCallback!: IBaseLoaderCallback<T>;\n    protected _stats!: ILoaderStats;\n    protected _retryDelay: number = 0;\n    private _loading: boolean = false;\n    private _aborted: boolean = false;\n    private _requestTimeout: any;\n    private _transTimer: any;\n    private _retryTimeout: any;\n    protected _rangeStart?: number;\n    private _continuedTransmissionRetry: boolean = false;\n    private _progressTime: number = 0;\n\n    /**\n     * 获取流式加载Loader类\n     * @param useFetch 是否使用fetch\n     * @returns class\n     */\n    _getInternalLoader(useFetch: boolean) {\n        if (typeof ChunkLoader !== 'undefined') {\n            return ChunkLoader;\n        }\n        ChunkLoader = null;\n        // ms优先使用xhr，其他浏览器优先使用fetch\n        if (Browser.msie || Browser.msedge) {\n            if (useFetch) {\n                if (FetchLoader.isSupport()) {\n                    ChunkLoader = FetchLoader;\n                }\n                return ChunkLoader;\n            }\n            if (XHR.isSupportChunk()) {\n                ChunkLoader = XHR;\n            } else if (FetchLoader.isSupport()) {\n                ChunkLoader = FetchLoader;\n            }\n        } else if (FetchLoader.isSupport()) {\n            ChunkLoader = FetchLoader;\n        } else if (XHR.isSupportChunk()) {\n            ChunkLoader = XHR;\n        }\n        return ChunkLoader;\n    }\n\n    constructor() {\n        this.tag = 'loader';\n        index++;\n        this._loader = null;\n        this._config = {\n            useFetch: false,\n            connectionTimeout: 0,\n            transmissionTimeout: 0,\n            maxRetry: 0,\n            retryDelay: 0\n        };\n        this._loaderCallback = {\n            onConnect: this._onConnect.bind(this),\n            onProgress: this._onProgress.bind(this),\n            onEnd: this._onEnd.bind(this),\n            onError: this._onError.bind(this)\n        };\n    }\n\n    load(context: T, callbacks: ILoaderCallback<T>, config: ILoaderConfig) {\n        this._init(context, callbacks, config);\n        this._loadInternal();\n    }\n\n    /**\n     * destory\n     */\n    destroy() {\n        this._stopTimer();\n        this._abortInternal();\n        this._destroyLoader();\n        this._callbacks = null;\n    }\n\n    _init(context: T, callbacks: ILoaderCallback<T>, config: ILoaderConfig) {\n        this.context = context;\n        this._rangeStart = context.rangeStart\n        this._callbacks = callbacks;\n        this._config = config || this._config;\n\n        this._stats = {\n            id: '',\n            trequest: performance.now(),\n            retry: 0,\n            loaded: 0,\n            code: 0,\n            output: 0,\n            tfirst: 0,\n            tload: 0,\n            total: 0,\n            tsload: 0,\n            tstart: 0,\n            fatal: false,\n            text: ''\n        };\n        if (this._config.retryDelay) {\n            this._retryDelay = this._config.retryDelay;\n        }\n    }\n\n    /**\n     * 销毁当前loader\n     */\n    _destroyLoader() {\n        if (this._loader) {\n            this._loader.destroy();\n            this._loader = null;\n        }\n    }\n\n    /**\n     * 开始加载，非流式处理优先使用xhr\n     */\n    _loadInternal() {\n        this._loading = true;\n        this._aborted = false;\n        const stats = this._stats;\n        stats.code = 0;\n        stats.tfirst = 0;\n        stats.loaded = 0;\n        if (this._retryTimeout) {\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n        }\n        if (this.context.progress) {\n            this._loader = new (this._getInternalLoader(!!this._config.useFetch))();\n        } else {\n            this._loader = new XHR();\n        }\n        if (!this._loader) {\n            return;\n        }\n        stats.id = `${this._loader.tag}-${index}`;\n        // 连接超时\n        if (this._config.connectionTimeout) {\n            this._requestTimeout = setTimeout(this._onTimeout.bind(this), this._config.connectionTimeout);\n        }\n        if (this.context.rangeEnd) {\n            this.context.range = 'bytes=' + this.context.rangeStart + '-' + (this.context.rangeEnd - 1);\n        } else if (this.context.rangeStart) {\n            this.context.range = 'bytes=' + this.context.rangeStart + '-';\n        }\n        stats.tsload = Date.now();\n        stats.tstart = performance.now();\n        this._loader.load(this.context, this._loaderCallback);\n    }\n\n    _abortInternal() {\n        if (this._callbacks && this._callbacks.onAbort && !this._aborted && this._loading) {\n            this._callbacks.onAbort(this.context, this._stats);\n        }\n        this._aborted = true;\n        if (this._loader) {\n            this._loader.abort();\n        }\n    }\n\n    abort() {\n        this._stopTimer();\n        this._abortInternal();\n    }\n\n    /**\n     * 停止所有计时器\n     * 连接超时、重试延迟、传输超时\n     */\n    _stopTimer() {\n        if (this._requestTimeout) {\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n        }\n        if (this._retryTimeout) {\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n        }\n        this._stopTransmissionTimer();\n    }\n\n    _onConnect(status: number) {\n        if (this._requestTimeout) {\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n        }\n        this._startTransmissionTimer();\n        this._stats.code = status;\n        this._stats.tfirst = Math.max(this._stats.trequest, performance.now());\n    }\n    _onProgress(context: T, chunk: ArrayBuffer) {\n        const stats = this._stats;\n        this._progressTime = performance.now();\n        // 流式下载错误重试后，从中断位置继续抛出数据，与range断点续传冲突，不支持range时使用\n        if (!this._continuedTransmissionRetry && stats.output > stats.loaded) {\n            const size = stats.loaded + chunk.byteLength - stats.output;\n            if (size > 0) {\n                const tmp = chunk.slice(stats.output - stats.loaded);\n                this._callProgress(this.context, tmp, stats);\n            }\n        } else {\n            this._callProgress(this.context, chunk, stats);\n        }\n        stats.loaded += chunk.byteLength;\n    }\n    _callProgress(context: T, chunk: ArrayBuffer, stats: ILoaderStats) {\n        this._stats.output += chunk.byteLength;\n        if (this._callbacks && this._callbacks.onProgress) {\n            this._callbacks.onProgress(context, chunk, stats);\n        }\n    }\n    _onEnd(context: T, responseData: string | ArrayBuffer | null) {\n        this._stopTimer();\n        const stats = this._stats;\n        if (responseData) {\n            if (typeof responseData === 'string') {\n                stats.total = stats.loaded = responseData.length || 0;\n            } else {\n                stats.total = stats.loaded = responseData.byteLength || 0;\n            }\n        } else {\n            stats.total = stats.loaded;\n        }\n        stats.tload = Math.max(stats.tfirst, performance.now());\n        this._loading = false;\n        stats.output = 0;\n        if (this._callbacks) {\n            this._callbacks.onEnd(context, responseData, stats);\n        }\n    }\n\n    _onError(e: Error) {\n        Log.i(this.tag, e);\n        this._stopTimer();\n        this._destroyLoader();\n        const stats = this._stats;\n        const config = this._config;\n        this._loading = false;\n\n        stats.fatal = !config.maxRetry || (stats.retry >= config.maxRetry || !config.maxRetry);\n        stats.text = e.message || 'load error';\n        if (this._callbacks && this._callbacks.onError) {\n            this._callbacks.onError(this.context, stats);\n        }\n        if (stats.fatal) {\n            return;\n        }\n        // 尝试使用range做断点续传\n        if (this._stats.output && this._stats.loaded > 0) {\n            if (this._rangeStart) {\n                this.context.rangeStart = this._rangeStart + this._stats.output;\n            } else {\n                this.context.rangeStart = this._stats.output;\n            }\n            this._continuedTransmissionRetry = true;\n        } else {\n            this.context.rangeStart = this._rangeStart;\n            this._continuedTransmissionRetry = false;\n        }\n        stats.retry++;\n        if (this._callbacks) {\n            if (this._retryDelay) {\n                this._retryTimeout = setTimeout(this._loadInternal.bind(this), this._retryDelay);\n                this._retryDelay = 2 * this._retryDelay;\n            } else {\n                this._loadInternal();\n            }\n        }\n    }\n\n    _onTimeout() {\n        this._loading = false;\n        this._abortInternal();\n        const e = new Error('timeout');\n        this._onError(e);\n    }\n\n    // 传输超时\n    _startTransmissionTimer() {\n        this._stopTransmissionTimer();\n        this._progressTime = performance.now();\n        let timeout = this._config.transmissionTimeout || 0;\n        if (timeout) {\n            this._transTimer = setInterval(() => {\n                if (performance.now() - this._progressTime > timeout) {\n                    this._onTimeout();\n                }\n            }, 1000);\n        }\n    }\n\n    _stopTransmissionTimer() {\n        if (this._transTimer) {\n            clearInterval(this._transTimer);\n            this._transTimer = null;\n        }\n    }\n}\n","export const REPORT_TYPES = {\n    START_LOAD_STREAM: 'startLoadStream',\n    LOADER_CHUNK_ARRIVAL: 'loader-chunk-arrival',\n    KEY_FRAME: 'keyFrame',\n};\n","import work from 'webworkify-webpack';\nimport { abrGetUrl } from '../abr/abr-get-url';\nimport { AbrManifest } from '../abr/abr-manifest';\nimport Multirate, { MultirateItem } from '../abr/multirate';\nimport { FlvTag } from '../demux/flv/flv';\nimport FlvDemuxerInline from '../demux/flv/flv-demuxer-inline';\nimport FlvTagDump from '../demux/flv/flv-tag-dump';\nimport Loader from '../io/loader';\nimport { FLVTransConfig } from '../types/core';\nimport { ILoaderCallback, ILoaderConfig, ILoaderContext, ILoaderStats } from '../types/io';\nimport { Log } from '../utils/log';\nimport { ErrorDetails, ErrorTypes } from './errors';\nimport LasEvents from './events';\nimport Media from './media';\nimport Observer from './observer';\nimport { REPORT_TYPES } from './report-types';\n\n/**\n * TransFLV\n * @class TransFLV\n * @param {object} config 配置\n */\nconst tag = 'TransFLV';\nexport default class TransFLV extends Observer {\n    private _config: FLVTransConfig;\n    private _media: Media;\n    private _w?: Worker;\n    private _flv?: FlvDemuxerInline;\n    private _observer: Observer;\n\n    private _loader: Loader<ILoaderContext> | null = null;\n    private _loaderConf: ILoaderConfig;\n    private _loaderCallbacks: ILoaderCallback<ILoaderContext>;\n    private _multirate?: Multirate;\n    private _contiguous: boolean;\n    private _remuxId: number;\n    private _discontinuity: boolean = false;\n    private _accurateTimeOffset: boolean = false;\n    private _baseTimeSec: number = 0;\n    private _tagDump: FlvTagDump;\n    private _currentUrl?: any;\n    private _lastDTS: number = 0;\n    private _isAbr: boolean = false;\n    private _progressTime: number = 0;\n\n    constructor(config: FLVTransConfig, media: Media) {\n        super();\n        this._config = config;\n        this._media = media;\n\n        if (config.manifest) {\n            if (AbrManifest.verify(config.manifest)) {\n                this._isAbr = true;\n            } else {\n                config.hasVideo = config.manifest.hasVideo;\n                config.hasAudio = config.manifest.hasAudio;\n            }\n        }\n\n        this._loaderConf = {\n            connectionTimeout: this._config.connectionTimeout,\n            transmissionTimeout: this._config.transmissionTimeout,\n            maxRetry: 0,\n            retryDelay: 0,\n            useFetch: true\n        };\n        this._loaderCallbacks = {\n            onProgress: this._onProgress.bind(this),\n            onError: this._onLoaderError.bind(this),\n            onEnd: this._onLoaderEnd.bind(this),\n            onAbort: this._onAbort.bind(this)\n        };\n        this._contiguous = false;\n        this._remuxId = 1;\n\n        const observer = (this._observer = new Observer());\n        const onMessage = this._onMessage;\n        observer.on(LasEvents.PARSING_INIT_SEGMENT, onMessage);\n        observer.on(LasEvents.PARSING_DATA, onMessage);\n        observer.on(LasEvents.ERROR, onMessage);\n        observer.on(LasEvents.SCRIPT_PARSED, onMessage);\n        observer.on(LasEvents.DISCONTINUITY, onMessage);\n        observer.on(LasEvents.FLV_HEAD, onMessage);\n\n        this._tagDump = new FlvTagDump(observer, this._onKeyframe);\n\n        if (this._config.webWorker) {\n            Log.i(tag, 'webWorker');\n            this._onWorkMessage = this._onWorkMessage.bind(this);\n            this._w = work(require.resolve('../demux/flv/flv-demuxer-worker'));\n            if (this._w) {\n                this._w.addEventListener('message', this._onWorkMessage);\n                this._w.postMessage({\n                    cmd: 'init',\n                    config: this._config,\n                    data: { remuxId: this._remuxId },\n                    vendor: navigator.vendor\n                });\n                return;\n            }\n        }\n        this._flv = new FlvDemuxerInline(observer, this._config, { remuxId: this._remuxId }, navigator.vendor);\n        this._flv.init();\n    }\n\n    public init(): void {\n        if (this._isAbr && !this._multirate) {\n            this._multirate = new Multirate(this._config, this._media);\n            this._multirate.on(LasEvents.MANIFEST_PARSED, this._onMessage);\n            this._multirate.init();\n        }\n    }\n\n    private _onWorkMessage(ev: any) {\n        const data = ev.data;\n        if (ev.data.event === LasEvents.PARSING_DATA) {\n            data.data.payload = data.payload;\n        }\n        this._onMessage(ev.data.event, data.data);\n    }\n\n    private _onKeyframe = (timestamp: number): MultirateItem | undefined => {\n        if (this._multirate) {\n            let result = this._multirate.onKeyFrame(timestamp);\n            if (result) {\n                if (this._tagDump) {\n                    this._tagDump.reset();\n                }\n                // 平滑切换\n                let info = Object.assign({}, result);\n                this._baseTimeSec = this._lastDTS;\n                this.emit(LasEvents.LEVEL_SWITCHING, { level: info.level, startSec: this._baseTimeSec, smooth: true });\n                this._media.updateStreamTime(0, 0);\n                return info;\n            }\n        }\n        return;\n    }\n\n    /**\n     * instance ioloader\n     */\n    public loadSource(): void {\n        let mr = this._multirate;\n        if (mr) {\n            let data = mr.levels[mr.currentLevel];\n            if (data) {\n                this._load(abrGetUrl(data.url, this._config.defaultSpts), mr.currentLevel);\n            } else {\n                this.emit(LasEvents.ERROR, {\n                    type: ErrorTypes.OTHER_ERROR,\n                    details: ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'manifest parse error'\n                });\n            }\n        } else {\n            this._load(this._config.src);\n        }\n    }\n\n    /**\n     * destroy\n     */\n    public destroy(): void {\n        if (this._loader) {\n            this._loader.destroy();\n            this._loader = null;\n        }\n        if (this._w) {\n            this._w.postMessage({ cmd: 'destroy' });\n            this._w.removeEventListener('message', this._onWorkMessage);\n            this._w.terminate();\n        }\n        if (this._flv) {\n            this._flv.destroy();\n            this._flv = undefined;\n        }\n\n        if (this._multirate) {\n            this._multirate.removeAllListeners();\n            this._multirate.destory();\n        }\n\n        const observer = this._observer;\n        if (observer) {\n            observer.removeAllListeners();\n        }\n    }\n\n    public get autoLevelEnabled(): boolean {\n        if (this._multirate) {\n            return this._multirate.autoLevelEnabled;\n        }\n        return false;\n    }\n\n    public get levels() {\n        if (this._multirate) {\n            return this._multirate.levels;\n        }\n        return [];\n    }\n\n    public get nextLevel(): number {\n        if (this._multirate) {\n            return this._multirate.nextLevel;\n        }\n        return 0;\n    }\n\n    public set nextLevel(value: number) {\n        const mr = this._multirate;\n        if (mr) {\n            mr.nextLevel = value;\n        }\n    }\n\n    public get currentLevel(): number {\n        if (this._multirate) {\n            return this._multirate.currentLevel;\n        }\n        return 0;\n    }\n\n    public set currentLevel(value: number) {\n        const mr = this._multirate;\n        if (mr) {\n            let load = value >= 0 || value !== mr.currentLevel;\n            mr.currentLevel = value;\n            const data = mr.levels[mr.currentLevel];\n            if (load && data) {\n                this._currentUrl = abrGetUrl(data.url, this._config.defaultSpts);\n                this._refreshRemuxId();\n                this._contiguous = false;\n                this._discontinuity = true;\n                this._accurateTimeOffset = false;\n                if (this._tagDump) {\n                    this._tagDump.reset();\n                }\n                this._baseTimeSec = this._media.currentTime;\n                this.emit(LasEvents.LEVEL_SWITCHING, { level: mr.currentLevel, startSec: this._baseTimeSec, smooth: false });\n                this._load(this._currentUrl, mr.currentLevel);\n            }\n        }\n    }\n\n\n    private _onMessage = (ev: string, data: any): void => {\n        switch (ev) {\n            case LasEvents.FLV_HEAD:\n                if (this._w) {\n                    this._w.postMessage({ cmd: 'flvHead', hasAudio: data.hasAudio, hasVideo: data.hasVideo });\n                } else if (this._flv) {\n                    this._flv.flvHead(data.hasAudio, data.hasVideo);\n                }\n                break;\n            case LasEvents.PARSING_INIT_SEGMENT:\n                this.emit(LasEvents.PARSING_INIT_SEGMENT, data);\n                break;\n            case LasEvents.PARSING_DATA:\n                {\n                    if (data.extra && data.extra.remuxId !== this._remuxId) {\n                        // 过期\n                        break;\n                    }\n                    if (data.type === 'audio' && data.startDTS > this._baseTimeSec) {\n                        this._media.updateStreamTime(data.streamDTS, data.startDTS);\n                    }\n                    this._lastDTS = data.startDTS;\n                    this.emit(LasEvents.PARSING_DATA, {\n                        data: data.payload,\n                        type: data.type,\n                        startDTS: data.startDTS || 0,\n                        endDTS: data.endDTS || 0,\n                        startPTS: data.startPTS || 0,\n                        endPTS: data.endPTS || 0,\n                        duration: data.endDTS - data.startDTS,\n                        framesInfo: data.framesInfo\n                    });\n                }\n                break;\n            case LasEvents.DISCONTINUITY:\n                if (this._w) {\n                    this._w.postMessage({ cmd: 'flush' });\n                } else if (this._flv) {\n                    this._flv.flush();\n                }\n                this._tagDump.reset();\n                this._discontinuity = true;\n                this._accurateTimeOffset = false;\n                this._contiguous = false;\n                this._baseTimeSec = data;\n                break;\n            default:\n                // LOST_FRAMES SCRIPT_PARSED REPORT ERROR END\n                this.emit(ev, data);\n                break;\n        }\n    }\n\n    private _load(url: string, index: number = 0): void {\n        if (this._loader) {\n            this._loader.destroy();\n            this._loader = null;\n        }\n        if (this._multirate) {\n            this._multirate.onLevelLoad(index);\n        }\n        this._currentUrl = url;\n        let level = this.levels[index]\n        this.emit(LasEvents.REPORT, {\n            type: REPORT_TYPES.START_LOAD_STREAM,\n            url,\n            sync: this._baseTimeSec,\n            index: index,\n            bitrate: level ? level.bitrate : 0\n        });\n        if (!this._loader) {\n            this._loader = new Loader();\n        }\n        const context = {\n            url,\n            progress: true,\n            responseType: 'arraybuffer',\n            credentials: this._config.credentials\n        };\n        if (this._loader instanceof Loader) {\n            this._loader.load(context, this._loaderCallbacks, this._loaderConf);\n        }\n    }\n\n    private _append(\n        tags: FlvTag[],\n        timeOffset: number,\n        discontinuity: boolean,\n        contiguous: boolean,\n        accurateTimeOffset: boolean\n    ): void {\n        if (this._w) {\n            this._w.postMessage({\n                cmd: 'append',\n                tags,\n                timeOffset: timeOffset || 0,\n                discontinuity,\n                contiguous,\n                accurateTimeOffset\n            });\n        } else if (this._flv) {\n            this._flv.append(tags, timeOffset || 0, discontinuity, contiguous, accurateTimeOffset);\n        }\n    }\n\n    private _onProgress(context: ILoaderContext, data: string | ArrayBuffer, stats: ILoaderStats): void {\n        if (!(data instanceof ArrayBuffer)) {\n            return;\n        }\n        if (this._multirate) {\n            this._multirate.onLoaderChunk(data.byteLength);\n        }\n        this.emit(LasEvents.REPORT, {\n            type: REPORT_TYPES.LOADER_CHUNK_ARRIVAL,\n            byteLength: data.byteLength,\n            timeCost: performance.now() - this._progressTime || stats.trequest,\n            header: context.responseHeader\n        });\n        this._progressTime = performance.now();\n        const result = this._tagDump.append(data);\n        this._append(result.list, this._baseTimeSec, this._discontinuity, this._contiguous, this._accurateTimeOffset);\n        this._accurateTimeOffset = true;\n        this._contiguous = true;\n        this._discontinuity = false;\n\n        // 是否需要切换\n        if (result.abr) {\n            this._load(result.abr.url, result.abr.level);\n        }\n    }\n\n    private _onAbort(): void { }\n\n    private _onLoaderError(context: ILoaderContext, status: ILoaderStats): void {\n        if (!status.fatal) {\n            return;\n        }\n        const errInfo = {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LOAD_ERROR,\n            fatal: true,\n            reason: status.text,\n            statusCode: status.code,\n            url: context.url\n        };\n        this.emit(LasEvents.ERROR, errInfo);\n    }\n\n    private _onLoaderEnd(): void {\n        if (this._w) {\n            this._w.postMessage({ cmd: 'end' });\n        } else if (this._flv) {\n            this._flv.end();\n        }\n    }\n\n    private _refreshRemuxId(): void {\n        this._remuxId++;\n        const data = { remuxId: this._remuxId };\n        if (this._w) {\n            this._w.postMessage({ cmd: 'setExtra', data: data });\n        } else if (this._flv) {\n            this._flv.setExtra(data);\n        }\n    }\n}\n","import { ErrorDetails } from '../core/errors';\n\nconst ErrorCodeList: Record<number|string, string> = {\n    400: '01', // http 400\n    401: '02', // http 401\n    403: '03', // http 403\n    404: '04', // http 404\n    other4xx: '05', // http 4xx\n    serverError: '06', // http 5xx\n    timeoutOpen: '07',\n    timeoutIO: '08',\n    200: '09',\n    206: '09'\n};\n\nexport function getErrorCode(detail: ErrorDetails, reason: string, httpStatusCode: number = 0): number {\n    if (detail >= 100) {\n        return detail;\n    }\n    let code = '00';\n    if (reason === 'timeout') {\n        if (!httpStatusCode) {\n            code = ErrorCodeList.timeoutOpen || code;;\n        } else {\n            code = ErrorCodeList.timeoutIO || code;;\n        }\n    } else if (ErrorCodeList.hasOwnProperty(httpStatusCode)) {\n        code = ErrorCodeList[httpStatusCode] || code;\n    } else if ((/^4\\d{2}$/).test(httpStatusCode.toString())) {\n        code = ErrorCodeList.other4xx || code;;\n    } else if ((/^5\\d{2}$/).test(httpStatusCode.toString())) {\n        code = ErrorCodeList.serverError || code;;\n    }\n    return parseInt(detail + code, 10);\n}\n","/*\n * FPS Controller\n */\n\nconst { performance } = window;\n\nclass FPS {\n    private tag: string = 'fps';\n    private _lastDroppedFrames: number = 0;\n    private _lastDecodedFrames: number = 0;\n    private _video: HTMLVideoElement | null = null;\n    private _isVideoPlaybackQualityAvailable: boolean = false;\n    private _lastTime: number = 0;\n    private _decoded: number = 0;\n    private _dropped: number = 0\n\n    constructor() {\n    }\n\n    public attachMedia(media: HTMLVideoElement) {\n        const video = this._video = media instanceof (window as any).HTMLVideoElement ? media : null;\n        if (video) {\n            // 部分浏览器seek后帧数信息归零的问题\n            this._isVideoPlaybackQualityAvailable = typeof video.getVideoPlaybackQuality === 'function';\n        }\n    }\n\n    public destory() {\n    }\n\n    public reset() {\n        this._lastTime = performance.now();\n        this._lastDroppedFrames = this._lastDecodedFrames = this._decoded = this._dropped = 0;\n        const video = this._video;\n        if (video) {\n            try {\n                if (this._isVideoPlaybackQualityAvailable) {\n                    const videoPlaybackQuality = video.getVideoPlaybackQuality();\n                    this._lastDecodedFrames = videoPlaybackQuality.totalVideoFrames;\n                    this._lastDroppedFrames = videoPlaybackQuality.droppedVideoFrames;\n                } else {\n                    this._lastDecodedFrames = (video as any).webkitDecodedFrameCount;\n                    this._lastDroppedFrames = (video as any).webkitDroppedFrameCount;\n                }\n            } catch (e) {\n                return;\n            }\n        }\n    }\n\n    public checkFPSInterval(): null | {\n        decoded: number,\n        dropped: number,\n        decodedFPS: number,\n        droppedFPS: number\n    } {\n        const video = this._video;\n        const currentTime = performance.now();\n        let info: any = null, decoded = 0, dropped = 0;\n\n        if (video) {\n            if (this._isVideoPlaybackQualityAvailable) {\n                const videoPlaybackQuality = video.getVideoPlaybackQuality();\n                decoded = videoPlaybackQuality.totalVideoFrames;\n                dropped = videoPlaybackQuality.droppedVideoFrames;\n            } else {\n                decoded = (video as any).webkitDecodedFrameCount || 0;\n                dropped = (video as any).webkitDroppedFrameCount || 0;\n            }\n        }\n\n        if (decoded) {\n            if (decoded < this._lastDecodedFrames) {\n                this._lastDecodedFrames = 0;\n                this._lastDroppedFrames = 0;\n            }\n            let currentPeriod = currentTime - this._lastTime,\n                currentDropped = dropped - this._lastDroppedFrames,\n                currentDecoded = decoded - this._lastDecodedFrames,\n                droppedFPS = 0,\n                decodedFPS = 0;\n            if (this._lastTime) {\n                droppedFPS = parseFloat((1000 * currentDropped / currentPeriod).toFixed(2)),\n                    decodedFPS = parseFloat((1000 * currentDecoded / currentPeriod).toFixed(2));\n            }\n            this._decoded = this._decoded += currentDecoded;\n            this._dropped = this._dropped += currentDropped;\n            this._lastTime = currentTime;\n            this._lastDroppedFrames = dropped;\n            this._lastDecodedFrames = decoded;\n\n            info = {\n                decoded: this._decoded,\n                dropped: this._dropped,\n                decodedFPS,\n                droppedFPS\n            };\n        }\n        this._lastTime = currentTime;\n        return info;\n    }\n}\n\nexport default FPS;\n","const RECORD_NUM_LIMIT = 10;\nconst RECORD_DOWNLOAD_NUM_LIMIT = 200;\nconst RECORD_SEGMRNT_NUM_LIMIT = 100;\n\ntype StreamQOS = {\n    index: number;\n    startPos: number;\n    url: string;\n    bitrate: number;\n    mediaInfo?: any;\n    traffic: number;\n    loadTimeCost: number;\n    keyFrame: number;\n    videoDataRate: number;\n    audioDataRate: number;\n    segments: Partial<Record<string, { duration: number; dts: number; len: number }[]>>;\n};\ntype DownloadLog = {\n    byteLength: number;\n    timeCost: number;\n    ts: number;\n};\ntype QOS = {\n    traffic: number;\n    streams: StreamQOS[];\n    download: DownloadLog[];\n};\n\n/**\n * 监测流下载、remux质量信息\n */\nclass StreamMonitor {\n    private _qos!: QOS;\n    constructor() {\n        this.reset();\n    }\n\n    /**\n     * 重置状态\n     */\n    public reset() {\n        this._qos = {\n            traffic: 0,\n            streams: [],\n            download: []\n        };\n    }\n\n    /**\n     * 收到关键帧\n     */\n    public onKeyFrame() {\n        this._qos.streams[this._qos.streams.length - 1].keyFrame++;\n    }\n\n    /**\n     * 开始加载新流，增加一调流记录\n     * @param index 流id\n     * @param startPos 流开始位置\n     * @param url 流地址\n     * @param bitrate 流码率\n     */\n    public onStreamOpen(index: number, startPos: number, url: string, bitrate: number): void {\n        if (this._qos.streams.length > RECORD_NUM_LIMIT) {\n            this._qos.streams.shift();\n        }\n        this._qos.streams.push({\n            index,\n            startPos,\n            url,\n            bitrate,\n            traffic: 0,\n            loadTimeCost: 0,\n            keyFrame: 0,\n            videoDataRate: 0,\n            audioDataRate: 0,\n            segments: {}\n        });\n    }\n\n    /**\n     * 收到媒体信息，解完音视频头之后\n     * @param data 媒体信息\n     */\n    public onMediaInfo(data: any) {\n        const info = this.loadingInfo;\n        if (info) {\n            info.mediaInfo = Object.assign({}, data);\n        }\n    }\n\n    /**\n     * 数据下载相关信息\n     * @param data 下载信息\n     */\n    public onDataReceive(data: { byteLength: number; timeCost: number; ts: number }): void {\n        this._qos.traffic += data.byteLength;\n        const log = this._qos.download;\n        if (log.length > RECORD_DOWNLOAD_NUM_LIMIT) {\n            log.pop();\n        }\n        log.unshift(data);\n        const info = this._qos.streams[this._qos.streams.length - 1];\n        info.traffic += data.byteLength;\n        info.loadTimeCost += data.timeCost;\n    }\n\n    public onMediaSegment(data: {\n        type: string;\n        duration: number;\n        dts: number;\n        byteLength: number;\n        framesInfo: any[];\n    }): void {\n        const qos = this._qos;\n        const stream = qos.streams[qos.streams.length - 1];\n        const log = stream.segments[data.type] || [];\n        stream.segments[data.type] = log;\n        log.push({ duration: data.duration, dts: data.dts, len: data.byteLength });\n\n        // datarate\n        if (log.length > RECORD_SEGMRNT_NUM_LIMIT) {\n            log.shift();\n        }\n        let duration = 0;\n        let totalLen = 0;\n        for (let i = 0; i < log.length; i++) {\n            totalLen += log[i].len;\n            duration += log[i].duration;\n        }\n        if (duration > 0) {\n            if (data.type === 'video') {\n                stream.videoDataRate = Math.round(totalLen * 8 / duration);\n            } else if (data.type === 'audio') {\n                stream.audioDataRate = Math.round(totalLen * 8 / duration);\n            }\n        }\n    }\n\n    /**\n     * 获取指定位置的流质量信息\n     * @param sec 视频时间轴时间（毫秒）\n     */\n    public getInfoByTime(sec: number): StreamQOS | null {\n        for (let i = this._qos.streams.length - 1; i >= 0; i--) {\n            if (this._qos.streams[i].startPos < sec) {\n                return this._qos.streams[i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * 更新当前下载流的开始时间\n     * @param sec 时间（毫秒）\n     */\n    public updateStartPos(sec: number): void {\n        if (this._qos.streams.length) {\n            this._qos.streams[this._qos.streams.length - 1].startPos = sec;\n        }\n    }\n\n    /**\n     * 获取当前正在加载的流质量信息\n     */\n    public get loadingInfo(): StreamQOS | null {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1];\n        }\n        return null;\n    }\n\n    /**\n     * 当前下载速度\n     */\n    public get downloadSpeed() {\n        const qos = this._qos;\n        const tsEnd = performance.now();\n        let len = 0,\n            timeCost = 0;\n        for (let i = 0; i < qos.download.length; i++) {\n            if (qos.download[i].ts > tsEnd - 1000) {\n                len += qos.download[i].byteLength;\n                timeCost += qos.download[i].timeCost;\n            } else {\n                break;\n            }\n        }\n        return Math.round(len / timeCost * 1000) || 0;\n    }\n\n    /**\n     * 当前加载流信息\n     */\n    public get mediaInfo(): any {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].mediaInfo;\n        }\n        return null;\n    }\n\n    /**\n     * 当前加载流视频视频码率\n     */\n    public get videoDataRate(): number {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].videoDataRate;\n        }\n        return 0;\n    }\n\n    /**\n     * 当前加载流视频音频码率\n     */\n    public get audioDataRate(): number {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].audioDataRate;\n        }\n        return 0;\n    }\n\n    /**\n     * 当前加载流视频码率\n     */\n    public get bitrate(): number {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].bitrate;\n        }\n        return 0;\n    }\n    /**\n     * 下载数据量（字节）\n     */\n    public get traffic(): number {\n        return this._qos.traffic;\n    }\n    /**\n     * 下载，remux质量数据\n     */\n    public get data(): QOS {\n        return this._qos;\n    }\n}\n\nexport { StreamMonitor };\n\n","import { EventEmitter } from 'events';\nimport LasEvents from '../core/events';\nimport Media from '../core/media';\nimport { REPORT_TYPES } from '../core/report-types';\nimport { getNewMonitorData, MonitorData } from '../types/monitor-data';\nimport FPS from './fps';\nimport { StreamMonitor } from './stream-monitor';\n\nconst HEARTBEAT_INTERVAL = 1000;\n\n/**\n * 播放日志处理。收集播放器事件，集中处理\n */\nclass Monitor extends EventEmitter {\n    private _media: Media;\n    private _fps?: FPS;\n    private _data!: MonitorData;\n    private _playing: boolean = false;\n    private _sm: StreamMonitor;\n    private _hbTimer: any;\n\n    constructor(media: Media) {\n        super();\n        this._sm = new StreamMonitor();\n        this._media = media;\n        this.reset();\n    }\n\n    /**\n     * 重置状态\n     */\n    public reset(): void {\n        this._data = getNewMonitorData();\n        this._sm.reset();\n        if (this._fps) {\n            this._fps.reset();\n        }\n        this._refresh();\n    }\n\n    /**\n     * 记录事件及对应的数据\n     * @param {object} event 事件数据\n     * @param {string} type 事件类型\n     */\n    public onReport(event: any): void {\n        event.ts = event.ts || performance.now();\n        const data = this._data;\n        switch (event.type) {\n            case REPORT_TYPES.LOADER_CHUNK_ARRIVAL:\n                data.downloadedBytes += event.byteLength;\n                this._sm.onDataReceive(event);\n                break;\n            case REPORT_TYPES.START_LOAD_STREAM:\n                this._sm.onStreamOpen(event.index || 0, event.sync, event.url, event.bitrate);\n                break;\n            case REPORT_TYPES.KEY_FRAME:\n                this._sm.onKeyFrame();\n                break;\n        }\n    }\n\n    public destroy(): void {\n        if (this._fps) {\n            this._fps.destory();\n            this._fps = undefined;\n        }\n        this._stopHeartbeat();\n    }\n\n    public onLoad(): void {\n        this._startHeartbeat();\n        if (this._media.video) {\n            this._fps = new FPS();\n            this._fps.attachMedia(this._media.video);\n        }\n    }\n\n    public onSegmentInit(data: any): void {\n        this._sm.onMediaInfo(data);\n    }\n\n    public onLoadeddata(): void {\n        this._onFirstFrame();\n        this._waitingEnd();\n    }\n\n    public onCanplay(): void {\n        this._onFirstFrame();\n        this._waitingEnd();\n    }\n\n    public onPlaying(): void {\n        this._playing = true;\n        this._waitingEnd();\n    }\n\n    public onEnd(): void {\n        this._waitingEnd();\n    }\n\n    public onWaiting(block: boolean): void {\n        if (this._playing && this._data.firstFrameTime && block) {\n            this._waitingStart();\n        }\n    }\n\n    public onStopLoad(): void {\n        this._stopHeartbeat();\n    }\n\n    public onSegment(data: any) {\n        this._sm.onMediaSegment(data);\n    }\n\n    public get data() {\n        return this._data;\n    }\n\n    private _refresh(): void {\n        let fps;\n        if (this._fps) {\n            fps = this._fps.checkFPSInterval();\n        }\n        const data = this._data;\n        if (fps) {\n            data.decodedFPS = fps.decodedFPS;\n            data.droppedFPS = fps.droppedFPS;\n            data.droppedFrames = fps.dropped;\n            data.decodedFrames = fps.decoded;\n        } else {\n            data.decodedFPS = data.droppedFPS = data.droppedFrames = data.decodedFrames = 0;\n        }\n    }\n\n    private _onFirstFrame(): void {\n        if (!this._data.firstFrameTime) {\n            this._data.firstFrameTime = performance.now();\n        }\n    }\n\n    private _waitingStart() {\n        if (!this._data.bufferingStartMS) {\n            this._data.blockCount++;\n            this._data.bufferingStartMS = this._data.bufferingStartMS || performance.now();\n        }\n    }\n\n    private _waitingEnd() {\n        if (this._data.bufferingStartMS) {\n            this._data.blockDuration += performance.now() - this._data.bufferingStartMS;\n        }\n        this._data.bufferingStartMS = null;\n    }\n\n    private _heartbeat = () => {\n        this._refresh();\n\n        const data = this._data;\n        const sm = this._sm;\n        const hb = {\n            totalReceive: sm.traffic,\n            speed: sm.downloadSpeed,\n            videoDataRate: sm.videoDataRate,\n            audioDataRate: sm.audioDataRate,\n            decodedFPS: data.decodedFPS,\n            droppedFPS: data.droppedFPS,\n            decodedFrames: data.decodedFrames,\n            droppedFrames: data.droppedFrames\n        };\n\n        this.emit(LasEvents.HEARTBEAT, hb);\n    }\n\n    private _startHeartbeat(): void {\n        if (!this._hbTimer) {\n            this._hbTimer = setInterval(this._heartbeat, HEARTBEAT_INTERVAL)\n        }\n    }\n\n    private _stopHeartbeat(): void {\n        if (this._hbTimer) {\n            clearInterval(this._hbTimer);\n            this._hbTimer = undefined;\n        }\n    }\n}\n\nexport default Monitor;\n","export type MonitorData = {\n    decodedFPS: number,\n    droppedFPS: number,\n    decodedFrames: number,\n    droppedFrames: number,\n    loadStartTime: number,\n    firstFrameTime: number,\n    blockDuration: number,\n    blockCount: number,\n    downloadedBytes: number,\n} & Record<string, any>\n\nexport function getNewMonitorData(): MonitorData {\n    return {\n        decodedFPS: 0,\n        droppedFPS: 0,\n        decodedFrames: 0,\n        droppedFrames: 0,\n        loadStartTime: 0,\n        firstFrameTime: 0,\n        blockDuration: 0,\n        blockCount: 0,\n        downloadedBytes: 0,\n    }\n}\n","import { EventEmitter } from 'events';\nimport AbrLevel from './abr/abr-level';\nimport { ConfigHelper } from './config';\nimport { ErrorDetails, ErrorTypes } from './core/errors';\nimport LasEvents from './core/events';\nimport Media from './core/media';\nimport MSEController from './core/mse-controller';\nimport TransFlv from './core/trans-flv';\nimport { LasConfig } from './types/core';\nimport Browser from './utils/browser';\nimport { getErrorCode } from './utils/get-error-code';\nimport { isSupported } from './utils/is-supported';\nimport { Log } from './utils/log';\nimport Monitor from './monitor/monitor';\n\n// 循环计时器间隔，毫秒\nconst MAIN_TIMER_INTERVAL = 200;\n\nconst BUFFER_THRESHOLD_DEFAULT = 0.5;\nconst BUFFER_THRESHOLD_STEP = 1;\nconst BUFFER_THRESHOLD_MAX = 3.5;\n\nenum STAT {\n    NONE,\n    WAITING,\n    SEEK,\n    SELECT_BITRATE,\n    INIT\n}\n/**\n * Las controller\n * @export\n * @class Las\n */\nexport default class Las extends EventEmitter {\n    private tag: string = 'las';\n    private _config: LasConfig;\n    private _video?: HTMLVideoElement;\n    private _mse!: MSEController;\n    private _trans?: TransFlv;\n\n    private _stat: STAT = STAT.INIT;\n    private _seekOnCanplay: boolean = false;\n    private _audioCodecSwap: boolean = false;\n    private _error: any;\n    private _audioCodec: string = '';\n    private _recoverMediaErrorTime: number = 0;\n    private _mainTimer: any;\n    private _media: Media;\n\n    private _nextLevel: any[] = [];\n    private _mediaInfo: any;\n    // (秒)发生卡顿时的buffer阈值，大于该阈值认为浏览器播放卡住，并尝试进行修正\n    private _bufferThreshold: number = BUFFER_THRESHOLD_DEFAULT;\n    private _loadStopped: boolean = false;\n    private _seekOnUpdateEnd: boolean = false;\n    private _playingLevel?: number;\n    private _startLevel?: number;\n    private _monitor!: Monitor;\n\n    static isSupport(): boolean {\n        return isSupported();\n    }\n\n    static get version() {\n        return __VERSION__;\n    }\n\n\n    static get Events() {\n        return LasEvents;\n    }\n\n    static get ErrorTypes() {\n        return ErrorTypes;\n    }\n\n    static get ErrorDetails() {\n        return ErrorDetails;\n    }\n\n    constructor(config?: LasConfig) {\n        super();\n        if (!this.off) {\n            this.off = this.removeListener;\n        }\n        this._config = ConfigHelper.processConfig(config);\n        this._media = new Media();\n        if (!this._config) {\n            setTimeout(() => {\n                this._onError({\n                    type: ErrorTypes.OTHER_ERROR,\n                    details: ErrorDetails.CONFIG_ERROR,\n                    fatal: true,\n                    reason: 'config data error'\n                });\n            }, 0);\n            return;\n        }\n        if (!Las.isSupport()) {\n            setTimeout(() => {\n                this._onError({\n                    type: ErrorTypes.OTHER_ERROR,\n                    details: ErrorDetails.UNSUPPORTED,\n                    fatal: true,\n                    reason: 'unsupported'\n                });\n            }, 0);\n            return;\n        }\n        this._mainTimer = null;\n        this._stat = STAT.INIT;\n        this._startMainTimer();\n        this._initMonitor();\n        Log.i(this.tag, Las.version, this._config);\n    }\n\n    /**\n     * 绑定video并初始化MSE\n     */\n    public attachMedia(video: HTMLVideoElement): void {\n        this._video = video;\n        this._media.attachVideo(this._video);\n        this._initMSE(video);\n        this._bindVideoEvents();\n    }\n\n    /**\n     * load\n     * @param {string} src src\n     */\n    public load(src: any = undefined): void {\n        this._playingLevel = undefined;\n        this._monitor.reset();\n        if (src) {\n            ConfigHelper.setSrc(this._config, src);\n        }\n        if (!this._config.src && !this._config.manifest) {\n            this._onError({\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.CONFIG_ERROR,\n                fatal: true,\n                reason: 'url empty'\n            });\n            return;\n        }\n        this._load();\n    }\n\n    /**\n     * 恢复播放。从暂停、停止状态恢复\n     */\n    public resume() {\n        Log.i(this.tag, 'call resume');\n        if (this._loadStopped) {\n            this._loadStopped = false;\n            this._load();\n        }\n        if (this._video && this._video.paused) {\n            this._video.play();\n        }\n    }\n\n    /**\n     * destroy\n     */\n    public destroy(): void {\n        this._stopMonitor();\n        this._stopMainTimer();\n        this._unbindVideoEvents();\n        this._stopVideo();\n    }\n\n    public refresh(): void {\n        Log.i(this.tag, 'call refresh');\n        if (this._trans && this._mse && this._video) {\n            this._startLevel = this._trans.currentLevel;\n\n            this._nextLevel = [];\n\n            this._stopVideo();\n            this._initMSE(this._video);\n\n            this._initTrans();\n            if (this._trans) {\n                this._trans.loadSource();\n            }\n\n        } else {\n            Log.v(this.tag, 'transmuxer & mediaSource not ready');\n        }\n    }\n\n    /**\n     * 停止加载，内核停止，用于直播停止\n     */\n    public stopLoad(): void {\n        Log.i(this.tag, 'call stopLoad');\n        if (this._trans) {\n            this._destroyTrans();\n            this._mse.endOfData();\n            this._loadStopped = true;\n            this._monitor.onStopLoad();\n        }\n    }\n\n    public getMediaInfo(): any {\n        return Object.assign({}, this._mediaInfo);\n    }\n\n    public get autoLevelEnabled(): boolean {\n        if (this._trans) {\n            return this._trans.autoLevelEnabled;\n        }\n        return false;\n    }\n\n    public get levels(): AbrLevel[] {\n        if (this._trans) {\n            return this._trans.levels;\n        }\n        return [];\n    }\n\n    public get nextLevel(): number {\n        if (this._trans) {\n            return this._trans.nextLevel;\n        }\n        return 0;\n    }\n\n    public set nextLevel(value: number) {\n        if (!this._verifyLevel(value) || !this._trans) {\n            this.emit(LasEvents.LEVEL_SWITCH_FAILED, { level: value });\n            return;\n        }\n        this._trans.nextLevel = value;\n    }\n\n    public get currentLevel(): number {\n        if (this._trans) {\n            return this._trans.currentLevel;\n        }\n        return 0;\n    }\n\n    public set currentLevel(value: number) {\n        if (!this._verifyLevel(value) || !this._trans) {\n            this.emit(LasEvents.LEVEL_SWITCH_FAILED, { level: value });\n            return;\n        }\n\n        if (value === -1) {\n            this._trans.nextLevel = value;\n        } else {\n            this._stat = STAT.SELECT_BITRATE;\n            this._bufferThreshold = BUFFER_THRESHOLD_DEFAULT;\n            this._seekOnCanplay = true;\n            if (this._mse) {\n                this._mse.flush();\n            }\n            this._trans.currentLevel = value;\n        }\n    }\n\n    public get startLevel(): number {\n        return typeof this._startLevel === 'undefined' ? -1 : this._startLevel;\n    }\n\n    public set startLevel(value: number) {\n        this._startLevel = value;\n    }\n\n    public get monitorData() {\n        if (this._monitor) {\n            return this._monitor.data;\n        }\n        return;\n    }\n\n    private _bindVideoEvents(): void {\n        if (this._video) {\n            this._video.addEventListener('loadeddata', this._onVideoLoadeddata);\n            this._video.addEventListener('canplay', this._onVideoCanplay);\n            this._video.addEventListener('waiting', this._onVideoWaiting);\n            this._video.addEventListener('playing', this._onVideoPlaying);\n            this._video.addEventListener('play', this._onVideoPlay);\n            this._video.addEventListener('error', this._onVideoError);\n            this._video.addEventListener('ended', this._onVideoEnded);\n        }\n    }\n\n    private _unbindVideoEvents(): void {\n        if (this._video) {\n            this._video.removeEventListener('loadeddata', this._onVideoLoadeddata);\n            this._video.removeEventListener('canplay', this._onVideoCanplay);\n            this._video.removeEventListener('waiting', this._onVideoWaiting);\n            this._video.removeEventListener('playing', this._onVideoPlaying);\n            this._video.removeEventListener('play', this._onVideoPlay);\n            this._video.removeEventListener('error', this._onVideoError);\n            this._video.removeEventListener('ended', this._onVideoEnded);\n        }\n    }\n    /**\n     * 移除mediasource事件\n     * @param {MSEController} mediaSource MSEController\n     */\n    private _unbindMediaSourceEvent(mediaSource: MSEController): void {\n        mediaSource.removeAllListeners();\n    }\n\n    private _onVideoPlay = (): void => {\n        if (!this._error) {\n            if (!this._trans) {\n                this.load();\n            }\n        }\n    };\n\n    private _onVideoEnded = (): void => {\n        this._monitor.onEnd();\n        if (this._mse) {\n            this._mse.flush();\n        }\n    };\n\n    /**\n     * new mediaSource\n     */\n    private _initMSE(video: HTMLVideoElement) {\n        this._mse = new MSEController(this._config);\n        this._mse.attach(video);\n        this._media.attachMSE(this._mse);\n\n        this._mse.on(LasEvents.ERROR, (errorMessage: any) => {\n            this._onError(errorMessage);\n        });\n        this._mse.on('updateend', () => {\n            if (this._seekOnUpdateEnd && video.buffered.length) {\n                Log.i(this.tag, 'seek on updateend');\n                this._internalSeek(video.buffered.start(0));\n                this._seekOnUpdateEnd = false;\n            }\n        });\n        this._mse.on('resetDone', () => {\n            this._seekOnUpdateEnd = true;\n        });\n    }\n\n    /**\n     * 开始加载视频\n     */\n    private _load() {\n        this._loadStopped = false;\n        this._error = false;\n        this._stat = STAT.INIT;\n        this._bufferThreshold = BUFFER_THRESHOLD_DEFAULT;\n        this._nextLevel = [];\n        this._media.reset();\n\n        this._monitor.onLoad();\n        if (this._trans) {\n            this._destroyTrans();\n        }\n        if (this._mse.hasSourceBuffer() || (this._video && this._video.error)) {\n            this._resetMSE();\n        }\n        this._initTrans();\n        if (this._trans) {\n            this._trans.loadSource();\n        }\n    }\n\n    /**\n     * reset MSE，重用\n     */\n    private _resetMSE = () => {\n        this._seekOnUpdateEnd = false;\n        if (this._video) {\n            Log.i(this.tag, 'rebuild mse');\n            URL.revokeObjectURL(this._video.src);\n            this._video.src = '';\n            this._video.removeAttribute('src');\n            this._destroyMSE();\n            this._initMSE(this._video);\n        }\n    }\n\n    private _verifyLevel(value: number): boolean {\n        return !!(this._trans &&\n            this._trans.levels.length > 0 &&\n            value < this._trans.levels.length &&\n            value >= -1 &&\n            this._video && !this._video.ended);\n    }\n\n    private _transmuxerEvent(trans: TransFlv): void {\n        const mse = this._mse;\n        trans.on(LasEvents.PARSING_DATA, data => {\n            if (mse) {\n                mse.mediaSegment(data);\n            }\n            if (this._monitor) {\n                this._monitor.onSegment({\n                    type: data.type,\n                    byteLength: data.data.byteLength,\n                    dts: Math.floor(data.startDTS * 1000),\n                    duration: Math.floor(data.duration * 1000),\n                    framesInfo: data.framesInfo\n                });\n            }\n        });\n\n        trans.on(LasEvents.PARSING_INIT_SEGMENT, data => {\n            const video = data.tracks.video,\n                audio = data.tracks.audio,\n                audiovideo = data.tracks.audiovideo;\n            const info: any = {\n                segments: [],\n                audiovideo: !!audiovideo,\n                hasVideo: !!(video || audiovideo),\n                hasAudio: !!(audio || audiovideo)\n            };\n            for (const key in data.tracks) {\n                const track = data.tracks[key];\n                Object.assign(info, track.metadata);\n                if (track.initSegment) {\n                    info.segments.push({ type: key, data: new Uint8Array(track.initSegment) });\n                }\n            }\n            info.videoCodec = video ? video.codec : null;\n            info.audioCodec = audio ? audio.codec : null;\n            this._audioCodec = data.manifestAudioCodec || info.audioCodec;\n            const mediaInfo = Object.assign({}, info);\n            delete mediaInfo.segments;\n            this._monitor.onSegmentInit(mediaInfo);\n            this.emit(LasEvents.MEDIA_INFO, mediaInfo);\n            this._mediaInfo = mediaInfo;\n            if (mse) {\n                mse.trackInfo(info);\n            }\n        });\n\n        trans.on(LasEvents.ERROR, errorMessage => {\n            this._onError(errorMessage);\n        });\n\n        trans.on(LasEvents.LOAD_END, () => {\n            if (mse) {\n                mse.endOfData();\n            }\n            this.emit(LasEvents.LOAD_END);\n        });\n        trans.on(LasEvents.LEVEL_SWITCH_FAILED, data => {\n            this.emit(LasEvents.LEVEL_SWITCH_FAILED, data);\n        });\n        trans.on(LasEvents.LEVEL_SWITCHING, data => {\n            if (!data.smooth && this._mse) {\n                this._mse.flush();\n            }\n            this.emit(LasEvents.LEVEL_SWITCHING, { level: data.level });\n            this._nextLevel = this._nextLevel\n                .sort((a, b) => {\n                    return a.startSec - b.startSec;\n                })\n                .filter(value => {\n                    return value.startSec < data.startSec;\n                });\n            this._nextLevel.push(data);\n        });\n        trans.on(LasEvents.BUFFER_FLUSHING, data => {\n            if (this._mse && this._video) {\n                this._mse.flush(data.startSec, this._video.duration);\n            }\n        });\n        trans.on(LasEvents.SCRIPT_PARSED, data => {\n            this.emit(LasEvents.SCRIPT_PARSED, data);\n        });\n        trans.on(LasEvents.MANIFEST_PARSED, data => {\n            if (typeof this._playingLevel === 'number') {\n                trans.currentLevel = this._playingLevel;\n                return;\n            }\n\n            if (typeof this._startLevel === 'number') {\n                trans.currentLevel = this._startLevel;\n            }\n            data = Object.assign({ levels: this.levels.slice(0), currentLevel: this.currentLevel }, data);\n            this._playingLevel = trans.currentLevel;\n            Log.i(this.tag, LasEvents.MANIFEST_PARSED, data);\n            this.emit(LasEvents.MANIFEST_PARSED, data);\n        });\n        trans.on(LasEvents.REPORT, data => {\n            if (this._monitor) {\n                this._monitor.onReport(data);\n            }\n        });\n    }\n\n    private _internalSeek(time: number): void {\n        if (this._video) {\n            this._video.currentTime = time;\n        }\n    }\n\n    /**\n     * Check buffer length regularly and apply various policies to avoid buffering\n     */\n    private _mainLoop = (): void => {\n        const EPS = 1e-3;\n        const video = this._video;\n\n        /**\n         * 兼容非I帧开始切片，起播位置音视频不对齐，音视频数据缺失会导致buffer不连续或播放位置处于buffer外\n         * 处理方式：手动seek至buffer内\n         * 1. 忽略buffer内seek：WAITING_STAT.WAITING && !video.seeking\n         * 2. buffer外seek、切换清晰度、起播：WAITING_SEEK || WAITING_SELECT_BITRATE || WAITING_INIT\n         * 3. 无待清理buffer\n         */\n        if (video &&\n            ((this._stat === STAT.WAITING && !video.seeking) ||\n                this._stat === STAT.INIT ||\n                this._stat === STAT.SEEK ||\n                this._stat === STAT.SELECT_BITRATE) &&\n\n            this._mse &&\n            !this._mse.hasCleanUpTask() &&\n            !video.ended\n        ) {\n            const currentTime = video.currentTime;\n            const currentBuffer = this._media.currentBuffer(currentTime);\n            let jumpTo: number | undefined = undefined;\n            // 卡顿位置无buffer\n            if (!currentBuffer || currentBuffer.end - currentTime < 1) {\n                const nextBuffer = this._media.nextBuffer(currentTime);\n                if (nextBuffer) {\n                    Log.i(this.tag, 'try fix block-A');\n                    jumpTo = nextBuffer.start;\n                }\n            } else if (video.buffered.length > 1 && currentBuffer.end - currentTime > 1) {\n                // 多段buffer播放卡顿\n                Log.i(this.tag, 'try fix block-B');\n                jumpTo = currentBuffer.start;\n            }\n\n            if (jumpTo) {\n                jumpTo = jumpTo + (Browser.safari ? 0.3 : EPS);\n                this._internalSeek(jumpTo);\n                Log.i(this.tag, `jump to ${jumpTo}`);\n            }\n        }\n        if (this._nextLevel.length) {\n            this._checkLevelChange();\n        }\n    };\n\n    private _onVideoLoadeddata = (): void => {\n        Log.i(this.tag, 'loadeddata');\n        this._monitor.onLoadeddata();\n    }\n\n    /**\n     * ‘canplay’ event listener\n     */\n    private _onVideoCanplay = (): void => {\n        Log.v(this.tag, `canplay ${!!this._stat}`);\n        this._monitor.onCanplay();\n        if (this._video && this._stat !== STAT.NONE) {\n            this._stat = STAT.NONE;\n            this._detectSeekOnCanplay();\n            this._checkLevelChange();\n            if (!this._video.paused) {\n                // 兼容waiting后不触发playing\n                this._onVideoPlaying();\n            }\n        }\n    };\n\n    private _detectSeekOnCanplay(): void {\n        if (this._video && this._seekOnCanplay && this._mse && !this._mse.hasCleanUpTask()) {\n            let EPS = 1 / 30;\n            const mediaInfo = this._mediaInfo;\n            if (mediaInfo && mediaInfo.fps && mediaInfo.fps > 0) {\n                EPS = 1 / mediaInfo.fps;\n            }\n            if (this._media.isTimeinBuffered(this._video.currentTime + EPS)) {\n                Log.i(this.tag, `seek on canplay ${this._video.currentTime} + ${EPS}`);\n                this._seekOnCanplay = false;\n                this._internalSeek(this._video.currentTime + EPS);\n            }\n        }\n    }\n\n    /**\n     * 'waiting' event listener\n     */\n    private _onVideoWaiting = (): void => {\n        if (!this._video) {\n            return;\n        }\n        this._stat = this._stat || STAT.WAITING;\n        const block = !this._video.seeking && this._stat === STAT.WAITING;\n        if (block) {\n            this._bufferThreshold = Math.min(this._bufferThreshold + BUFFER_THRESHOLD_STEP, BUFFER_THRESHOLD_MAX);\n        }\n        if (block) {\n            Log.i(this.tag, 'waiting currentTime:', this._video.currentTime);\n        }\n        this._monitor.onWaiting(block);\n    };\n\n    /**\n     * 'playing' event listener\n     * 由于兼容处理，可能会重复触发，playing事件触发一次，兼容逻辑调用一次\n     */\n    private _onVideoPlaying = (): void => {\n        Log.i(this.tag, 'playing');\n        if (!this._error) {\n            this._stat = STAT.NONE;\n            this._monitor.onPlaying();\n        }\n    };\n\n    private _onVideoError = (error: any): void => {\n        Log.e(this.tag, 'video error', error);\n        if (this._error) {\n            return;\n        }\n        const now = performance.now();\n        if (!this._recoverMediaErrorTime || now - this._recoverMediaErrorTime > 3000) {\n            this._recoverMediaErrorTime = now;\n            this._config.gopRemux = true;\n            this._recoverMediaError();\n            return;\n        }\n        if (!this._audioCodecSwap && this._audioCodec) {\n            this._audioCodecSwap = true;\n            this._recoverSwapAudioCodec();\n            this._recoverMediaError();\n            return;\n        }\n\n        let reason = 'video error';\n        if (this._video && this._video.error) {\n            reason += ` code:${this._video.error.code} message:${this._video.error.message}`;\n        }\n        this._onError({\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.VIDEO_ERROR,\n            fatal: true,\n            reason\n        });\n    };\n\n    /**\n     * 错误处理\n     * @param {*} data 错误数据\n     */\n    private _onError(data: any): void {\n        Log.i(this.tag, `on error ${JSON.stringify(data)}`);\n        const errInfo: any = {};\n        if (data.type === ErrorTypes.NETWORK_ERROR) {\n            errInfo.statusCode = data.statusCode;\n            errInfo.url = data.url;\n        }\n        if (data.fatal) {\n            const errorCode = getErrorCode(data.details, data.reason, data.statusCode || 0);\n            this.stopLoad();\n            this._stopMainTimer();\n            if (data.details === ErrorDetails.VIDEO_ERROR || (this._video && this._video.error)) {\n                this._destroyMSE();\n            }\n            errInfo.code = errorCode;\n            errInfo.type = data.type;\n            errInfo.reason = data.reason;\n            if (!this._error) {\n                this._error = errInfo;\n                this.emit(LasEvents.ERROR, errInfo);\n            }\n        }\n    }\n\n    private _startMainTimer(): void {\n        if (this._mainTimer === null) {\n            this._mainTimer = setInterval(this._mainLoop, MAIN_TIMER_INTERVAL);\n        }\n    }\n\n    private _stopMainTimer(): void {\n        if (this._mainTimer) {\n            clearInterval(this._mainTimer);\n            this._mainTimer = null;\n        }\n    }\n\n    private _checkLevelChange(): void {\n        const d = this._nextLevel[0];\n        if (this._video && d && this._video.currentTime >= d.startSec && this._media.isTimeinBuffered(this._video.currentTime)) {\n            this.emit(LasEvents.LEVEL_SWITCHED, { level: d.level });\n            this._playingLevel = d.level;\n            this._nextLevel.shift();\n        }\n    }\n\n    private _stopVideo(): void {\n        if (this._video) {\n            URL.revokeObjectURL(this._video.src);\n            this._video.src = '';\n            this._video.removeAttribute('src');\n            this._destroyTrans();\n            this._destroyMSE();\n        }\n    }\n\n    private _destroyTrans(): void {\n        if (this._trans) {\n            this._trans.removeAllListeners();\n            this._trans.destroy();\n            this._trans = undefined;\n        }\n    }\n\n    private _destroyMSE(): void {\n        if (this._mse) {\n            this._unbindMediaSourceEvent(this._mse);\n            this._mse.destroy();\n        }\n    }\n\n    private _initTrans(): void {\n        this._trans = new TransFlv(this._config, this._media);\n        this._transmuxerEvent(this._trans);\n        this._trans.init();\n    }\n\n    private _initMonitor(): void {\n        if (!this._monitor) {\n            this._monitor = new Monitor(this._media);\n            this._monitor.on(LasEvents.HEARTBEAT, value => {\n                this.emit(LasEvents.HEARTBEAT, value);\n            })\n        }\n    }\n\n    private _stopMonitor(): void {\n        if (this._monitor) {\n            this._monitor.destroy();\n            this._monitor.removeAllListeners();\n        }\n    }\n\n    /**\n     * 解码错误时尝试更换audio codec string\n     */\n    private _recoverSwapAudioCodec(): void {\n        let audioCodec = this._audioCodec;\n        if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n        } else {\n            audioCodec = 'mp4a.40.5';\n        }\n        this._config.audioCodec = audioCodec;\n        this._config.audioCodecSwap = true;\n    }\n\n    /**\n     * 恢复video error，重新绑定video，加载视频\n     */\n    private _recoverMediaError(): void {\n        if (!this._video) {\n            return;\n        }\n        this._nextLevel = [];\n\n        this._stopVideo();\n        this._initMSE(this._video);\n\n        this._initTrans();\n        if (this._trans) {\n            this._trans.loadSource();\n        }\n\n    }\n}\n","import { getMediaSource } from './mediasource-helper';\nimport FetchLoader from '../io/fetch';\nimport { XHR, XHR_TYPE } from '../io/xhr';\n\nexport function isSupported(): boolean {\n    const mediaSource = getMediaSource();\n    const sourceBuffer = (window as any).SourceBuffer || (window as any).WebKitSourceBuffer;\n    const isTypeSupported: boolean =\n        mediaSource &&\n        typeof mediaSource.isTypeSupported === 'function' &&\n        mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n    const sourceBufferValidAPI =\n        !sourceBuffer ||\n        (sourceBuffer.prototype &&\n            typeof sourceBuffer.prototype.appendBuffer === 'function' &&\n            typeof sourceBuffer.prototype.remove === 'function');\n\n    let streaming = FetchLoader.isSupport() || XHR.isSupportChunk() === XHR_TYPE.MOZ_CHUNK;\n    return isTypeSupported && sourceBufferValidAPI && streaming;\n}\n"],"sourceRoot":""}